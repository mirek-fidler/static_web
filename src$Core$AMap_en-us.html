<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML lang="en-us">
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="Generator" CONTENT="U++ HTML Package">
<TITLE>AMap :: U++</TITLE>
<STYLE TYPE="text/css"><!--
.A{margin:0px 0px 0px 0px;text-indent:0px;text-align:left;color:#000000;font-family:sans-serif;font-size:10pt;font-weight:normal;font-style:normal;}
.B{font-size:12pt;}
.C{border-collapse:collapse;table-layout:auto;border: 2px solid #000000;}
.D{padding: 3px 5px 3px 5px;border-left: 1px solid #000000;border-top: 1px solid #000000;border-right: 1px solid #000000;border-bottom: 1px solid #000000;background-color:#712A00;vertical-align:middle;}
.E{margin:0px 0px 0px 0px;text-indent:0px;text-align:left;color:#e0e0e0;font-family:sans-serif;font-size:16pt;font-weight:bold;font-style:normal;}
.F{margin:0px 0px 0px 0px;text-indent:0px;text-align:left;color:#000000;font-family:sans-serif;font-size:6pt;font-weight:normal;font-style:normal;}
.G{margin:0px 0px 5px 0px;text-indent:0px;text-align:left;color:#0000ff;font-family:sans-serif;font-size:12pt;font-weight:normal;font-style:normal;}
.H{color:#000000;}
.I{color:#008000;font-weight:bold;}
.J{margin:0px 0px 5px 0px;text-indent:0px;text-align:left;color:#000000;font-family:sans-serif;font-size:10pt;font-weight:bold;font-style:normal;}
.K{color:#0000ff;font-weight:normal;}
.L{font-weight:normal;}
.M{font-style:italic;}
.N{font-weight:bold;}
.O{font-weight:bold;font-style:italic;}
.P{border-collapse:collapse;table-layout:auto;border: 2px solid #808080;}
.Q{padding: 3px 5px 3px 5px;border-left: 1px solid #808080;border-top: 1px solid #808080;border-right: 1px solid #808080;border-bottom: 1px solid #808080;background-color:#C0C0C0;vertical-align:middle;}
.R{margin:0px 0px 0px 0px;text-indent:0px;text-align:left;color:#000000;font-family:sans-serif;font-size:10pt;font-weight:bold;font-style:normal;}
.S{margin:0px 0px 5px 0px;text-indent:0px;text-align:left;color:#000000;font-family:sans-serif;font-size:10pt;font-weight:normal;font-style:normal;}
.T{margin:0px 0px 0px 57px;text-indent:0px;text-align:left;color:#000000;font-family:sans-serif;font-size:10pt;font-weight:normal;font-style:normal;}
.U{color:#0000ff;}
.V{color:#800000;font-weight:bold;}
.W{margin:0px 0px 0px 57px;text-indent:0px;text-align:left;color:#000080;font-family:sans-serif;font-size:8pt;font-weight:bold;font-style:normal;}
.X{font-family:monospace;font-weight:bold;}
.Y{color:#008080;}
.Z{color:#800000;font-family:monospace;font-weight:bold;}
.AA{margin:0px 0px 5px 0px;text-indent:0px;text-align:left;color:#0000ff;font-family:sans-serif;font-size:10pt;font-weight:normal;font-style:normal;}
.AB{color:#000000;font-weight:bold;}
.AC{color:#800000;}
.AD{margin:3px 0px 0px 57px;text-indent:0px;text-align:left;color:#000000;font-family:sans-serif;font-size:10pt;font-weight:normal;font-style:normal;}
a.l1         { text-decoration:none; font-size: 8pt; font-family: sans-serif; font-weight: normal; }
a.l1:link    { color:#000000; }
a.l1:visited { color:#000080; }
a.l1:hover   { color:#9933CC; }
a.l1:active  { color:#000000; }
a.l2         { text-decoration:none; font-size: 12pt; font-family: sans-serif; font-variant: small-caps; }
a.l2:link    { color:#0066FF; }
a.l2:visited { color:#FF6600; }
a.l2:hover   { color:#BC0624; }
a.l2:active  { color:#BC0024; }

-->
</STYLE>
<META NAME="keywords" CONTENT="framework, toolkit, widget, c++, visual, studio, dev-cpp, builder, ide, class, component,wxwidgets, qt, rapid, application, development, rad, mfc, linux, macos, gui, sdl, directx, desktop"><META name="robots" content="index,follow">
<LINK rel="alternate" type="application/rss+xml" title="SVN changes" href="svnchanges.xml">
<LINK rel="shortcut icon" type="image/png" href="favicon.png">
</HEAD><BODY BGCOLOR="#D2D9D2" ALINK="#800000" LINK="#000000" VLINK="#000080"><TABLE BORDER="0" CELLSPACING="0" CELLPADDING="0" WIDTH="100%"><TR><TD COLSPAN="3"><TABLE BORDER="0" CELLSPACING="0" CELLPADDING="0" WIDTH="100%" BGCOLOR="#FFFFFF" style="border: 1px solid #6E89AE;padding-left: 10px;padding-right: 0px;padding-top: 0px;padding-bottom: 0px;"><TR><TD><A HREF="index.html"><IMG SRC="0i.png" ALT="" BORDER="0"></A>
</TD>
<TD ALIGN="RIGHT" VALIGN="BOTTOM" STYLE="padding-bottom: 5px; background-image: url('1i.png')"><span style="font-size: 14pt; font-family: sans-serif;"><script type="text/javascript"><!--
google_ad_client = "pub-1082147624384270";
google_ad_width = 468;
google_ad_height = 60;
google_ad_format = "468x60_as";
google_ad_type = "text_image";
google_ad_channel = "";
google_color_border = "336699";
google_color_bg = "FFFFFF";
google_color_link = "0000FF";
google_color_text = "000000";
google_color_url = "008000";
//--></script>
<script type="text/javascript"
  src="https://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
&nbsp;&nbsp;</span>
</TD>
</TR>
</TABLE>
</TD>
</TR>
</TABLE>
<TABLE BORDER="0" CELLSPACING="0" CELLPADDING="0" WIDTH="100%"><TR><TD COLSPAN="3" BGCOLOR="#D2D9D2" HEIGHT="6"></TD>
</TR>
<TR><TD VALIGN="TOP" ALIGN="CENTER"><TABLE BORDER="0" CELLSPACING="0" CELLPADDING="0" WIDTH="160"><TR><TD ALIGN="CENTER"><TABLE BORDER="0" CELLSPACING="0" CELLPADDING="0" WIDTH="100%" BGCOLOR="#FFFFFF" style="border-style: solid; border-width: 1px; border-color: #6E89AE;padding: 0px"><TR><TD WIDTH="100%" VALIGN="MIDDLE" STYLE="background-image: url('2i.png'); border: 0px solid black; padding-left:12px; padding-right:0px; padding-top:6px; padding-bottom:6px;"><A HREF="www$uppweb$overview$en-us.html" CLASS="l1">Overview</A>
</TD>
</TR>
<TR><TD WIDTH="100%" VALIGN="MIDDLE" STYLE="background-image: url('2i.png'); border: 0px solid black; padding-left:12px; padding-right:0px; padding-top:6px; padding-bottom:6px; border-top: 1px solid #6E89AE;"><A HREF="www$uppweb$examples$en-us.html" CLASS="l1">Examples</A>
</TD>
</TR>
<TR><TD WIDTH="100%" VALIGN="MIDDLE" STYLE="background-image: url('2i.png'); border: 0px solid black; padding-left:12px; padding-right:0px; padding-top:6px; padding-bottom:6px; border-top: 1px solid #6E89AE;"><A HREF="www$uppweb$ss$en-us.html" CLASS="l1">Screenshots</A>
</TD>
</TR>
<TR><TD WIDTH="100%" VALIGN="MIDDLE" STYLE="background-image: url('2i.png'); border: 0px solid black; padding-left:12px; padding-right:0px; padding-top:6px; padding-bottom:6px; border-top: 1px solid #6E89AE;"><A HREF="www$uppweb$comparison$en-us.html" CLASS="l1">Comparisons</A>
</TD>
</TR>
<TR><TD WIDTH="100%" VALIGN="MIDDLE" STYLE="background-image: url('2i.png'); border: 0px solid black; padding-left:12px; padding-right:0px; padding-top:6px; padding-bottom:6px; border-top: 1px solid #6E89AE;"><A HREF="www$uppweb$apps$en-us.html" CLASS="l1">Applications</A>
</TD>
</TR>
<TR><TD WIDTH="100%" VALIGN="MIDDLE" STYLE="background-image: url('2i.png'); border: 0px solid black; padding-left:12px; padding-right:0px; padding-top:6px; padding-bottom:6px; border-top: 1px solid #6E89AE;"><A HREF="www$uppweb$download$en-us.html" CLASS="l1">Download</A>
</TD>
</TR>
<TR><TD WIDTH="100%" VALIGN="MIDDLE" STYLE="background-image: url('2i.png'); border: 0px solid black; padding-left:12px; padding-right:0px; padding-top:6px; padding-bottom:6px; border-top: 1px solid #6E89AE;"><A HREF="www$uppweb$documentation$en-us.html" CLASS="l1">Documentation</A>
</TD>
</TR>
<TR><TD WIDTH="100%" VALIGN="MIDDLE" STYLE="background-image: url('2i.png'); border: 0px solid black; padding-left:12px; padding-right:0px; padding-top:6px; padding-bottom:6px; border-top: 1px solid #6E89AE;"><A HREF="www$uppweb$Tutorials$en-us.html" CLASS="l1">Tutorials</A>
</TD>
</TR>
<TR><TD WIDTH="100%" VALIGN="MIDDLE" STYLE="background-image: url('2i.png'); border: 0px solid black; padding-left:12px; padding-right:0px; padding-top:6px; padding-bottom:6px; border-top: 1px solid #6E89AE;"><A HREF="app$ide$UppHub$en-us.html" CLASS="l1">UppHub</A>
</TD>
</TR>
<TR><TD WIDTH="100%" VALIGN="MIDDLE" STYLE="background-image: url('2i.png'); border: 0px solid black; padding-left:12px; padding-right:0px; padding-top:6px; padding-bottom:6px; border-top: 1px solid #6E89AE;"><A HREF="www$uppweb$Roadmap$en-us.html" CLASS="l1">Status & Roadmap</A>
</TD>
</TR>
<TR><TD WIDTH="100%" VALIGN="MIDDLE" STYLE="background-image: url('2i.png'); border: 0px solid black; padding-left:12px; padding-right:0px; padding-top:6px; padding-bottom:6px; border-top: 1px solid #6E89AE;"><A HREF="www$uppweb$FAQ$en-us.html" CLASS="l1">FAQ</A>
</TD>
</TR>
<TR><TD WIDTH="100%" VALIGN="MIDDLE" STYLE="background-image: url('2i.png'); border: 0px solid black; padding-left:12px; padding-right:0px; padding-top:6px; padding-bottom:6px; border-top: 1px solid #6E89AE;"><A HREF="app$ide$About$en-us.html" CLASS="l1">Authors & License</A>
</TD>
</TR>
<TR><TD WIDTH="100%" VALIGN="MIDDLE" STYLE="background-image: url('2i.png'); border: 0px solid black; padding-left:12px; padding-right:0px; padding-top:6px; padding-bottom:6px; border-top: 1px solid #6E89AE;"><A HREF="https://www.ultimatepp.org/forums" CLASS="l1">Forums</A>
</TD>
</TR>
<TR><TD WIDTH="100%" VALIGN="MIDDLE" STYLE="background-image: url('2i.png'); border: 0px solid black; padding-left:12px; padding-right:0px; padding-top:6px; padding-bottom:6px; border-top: 1px solid #6E89AE;"><A HREF="www$uppweb$Funding$en-us.html" CLASS="l1">Funding U++</A>
</TD>
</TR>
</TABLE>
<TABLE BORDER="0" WIDTH="100%"><TR><TD></TD>
</TR>
</TABLE>
<TABLE BORDER="0" CELLSPACING="0" CELLPADDING="0" WIDTH="100%" BGCOLOR="#FFFFFF" style="border-style: solid; border-width: 1px; border-color: #6E89AE;padding: 0px"><TR><TD WIDTH="100%" VALIGN="MIDDLE" STYLE="background-image: url('3i.png'); border: 0px solid black;padding-left:12px; padding-right:0px; padding-top:1px; padding-bottom:1px;color:#FFFFFF;"><B><span style="font-size: 8pt; font-family: sans-serif;">Search on this site</span>
</B>
</TD>
</TR>
<TR><TD WIDTH="100%" VALIGN="MIDDLE" STYLE="background-image: url('2i.png'); border: 0px solid black; padding-left:6px; padding-right:0px; padding-top:4px; padding-bottom:4px;border-top: 1px solid #6E89AE;"><TABLE BORDER="0" CELLSPACING="0" CELLPADDING="0" WIDTH="100%"><TR><TD><IMG SRC="4i.png" ALT="" BORDER="0"></TD>
<TD><FORM ACTION="https://www.google.com/search" METHOD="GET" STYLE="margin:0px;padding:0px;"><INPUT TYPE="HIDDEN" NAME="ie" VALUE="UTF-8"><INPUT TYPE="HIDDEN" NAME="oe" VALUE="UTF-8"><INPUT TYPE="TEXT" NAME="q" SIZE="15" MAXLENGTH="256" placeholder="Site search"><INPUT TYPE="HIDDEN" NAME="sitesearch" VALUE="ultimatepp.org"></FORM>
</TD>
</TR>
</TABLE>
</TD>
</TR>
</TABLE>
<TABLE BORDER="0" WIDTH="100%"><TR><TD></TD>
</TR>
</TABLE>
<br><div id="fb-root"></div>
<script type="text/javascript">(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) {return;}
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/en_US/all.js#xfbml=1";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>

<div class="fb-like" data-href="https://www.facebook.com/pages/Upp-Framework/262346610476027?sk=wall" data-send="false" data-layout="button_count" data-width="160" data-show-faces="false" data-font="arial"></div>
<br><br><script type="text/javascript"><!--
google_ad_client = "pub-1082147624384270";
google_ad_width = 160;
google_ad_height = 600;
google_ad_format = "160x600_as";
google_ad_type = "text_image";
google_ad_channel = "";
google_color_border = "336699";
google_color_bg = "FFFFFF";
google_color_link = "0000FF";
google_color_text = "000000";
google_color_url = "008000";
//--></script>
<script type="text/javascript"
  src="https://pagead2.googlesyndication.com/pagead/show_ads.js">
</script><br><br><script type="text/javascript"><!--
google_ad_client = "pub-1082147624384270";
google_ad_width = 160;
google_ad_height = 90;
google_ad_format = "160x90_0ads_al_s";
google_ad_channel = "";
google_color_border = "336699";
google_color_bg = "FFFFFF";
google_color_link = "0000FF";
google_color_text = "000000";
google_color_url = "008000";
//--></script>
<script type="text/javascript"
  src="https://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
<br><br><br><br><br><br><A HREF="https://sourceforge.net/projects/upp/"><IMG SRC="https://sourceforge.net/sflogo.php?group_id=93970&amp;type=2" ALT="SourceForge.net Logo" BORDER="0" WIDTH="125" HEIGHT="37"></A>
<br><br><A HREF="https://flathub.org/en/apps/org.ultimatepp.TheIDE"><IMG SRC="5i.png" ALT="SourceForge.net Logo" BORDER="0" WIDTH="125" HEIGHT="37"></A>
<br><br><div style="background-color:#ffffff;width:125;height:35"><A HREF="https://github.com/ultimatepp"><IMG SRC="6i.png" ALT="GitHub Logo" BORDER="0" WIDTH="125" HEIGHT="35"></A>
</div><br><div style="background-color:#ffffff;width:125;height:35"><div style="height:5"></div><A HREF="https://discord.gg/8XzqQzXZzb"><IMG SRC="https://assets-global.website-files.com/6257adef93867e50d84d30e2/636e0b5061df29d55a92d945_full_logo_blurple_RGB.svg" ALT="Discord Logo" BORDER="0" WIDTH="125" HEIGHT="25"></A>
</div><br></TD>
</TR>
</TABLE>
</TD>
<TD VALIGN="TOP" BGCOLOR="#D2D9D2"><TABLE BORDER="0" CELLSPACING="0" CELLPADDING="0" WIDTH="6"><TR><TD></TD>
</TR>
</TABLE>
</TD>
<TD VALIGN="TOP" WIDTH="100%" BGCOLOR="#D2D9D2"><TABLE BORDER="0" CELLSPACING="0" CELLPADDING="0" BGCOLOR="#FFFFFF" WIDTH="100%" style="border-style: solid; border-width: 1px; border-color: #6E89AE;padding: 10px;;"><TR><TD><TABLE BORDER="0" CELLSPACING="0" CELLPADDING="0" WIDTH="100%"><TR><TD><table width="100%" border="0" cellpadding="0" cellspacing="0"><tr><td width="100%"><table width="100%" class="C"><colgroup><col width="100%"></colgroup>
<tr><td class="D"><p class="E">AMap</p>
</td>
</tr>
</table></td>
</tr></table>
<p class="F">&nbsp;</p>
<p id="noref" class="G">template<span class="H">&nbsp;&lt;</span>class<span class="H">&nbsp;</span><span class="I">K</span><span class="H">, </span>class<span class="H">&nbsp;</span><span class="I">T</span><span class="H">, </span>class<span class="H">&nbsp;</span><span class="I">V</span><span class="H">, </span>class<span class="H">&nbsp;</span><span class="I">HashFn</span>&gt;</p>
<p id="AMap::class" class="J"><span class="K">class</span><span class="L">&nbsp;</span>AMap</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td valign="top" width="89" bgcolor="#F0F0F0">
<p class="A"><span class="I">K</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Type of keys. K must have deep copy constructor, be <a href="dpp://SourceDoc/Containers/Moveable"><span class="M">moveable</span></a> and must have operator== defined.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td valign="top" width="89" bgcolor="#F0F0F0">
<p class="A"><span class="I">T</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Type of values. T must satisfy requirements for container flavor identified by parameter V.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td valign="top" width="89" bgcolor="#F0F0F0">
<p class="A"><span class="I">V</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Type of basic random access container.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td valign="top" width="89" bgcolor="#F0F0F0">
<p class="A"><span class="I">HashFn</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Hashing class. Must have defined unsigned operator()(const K&amp; x) method returning hash value for elements.</p></td></tr></table>
<p class="A">&nbsp;</p>
<p class="A">AMap is a class that combines Index of keys with basic random access container of values, forming map flavors. It is used as base class for concrete map flavors, <span class="N">VectorMap</span>, <span class="N">ArrayMap</span> and <span class="N">SegtorMap</span>.</p>
<p class="A">Like any other NTL container, AMap is <a href="srcdoc$Core$Moveable$en-us.html"><span class="O">moveable</span></a><span class="O"> </span>type with <a href="srcdoc$Core$pick_$en-us.html"><span class="O">pick and optional deep copy</span></a> transfer semantics, although these features are more important in derived concrete index flavors.</p>
<p class="F">&nbsp;</p>
<p class="A">&nbsp;</p>
<table width="100%" border="0" cellpadding="0" cellspacing="0"><tr><td width="100%"><table width="100%" class="P"><colgroup><col width="100%"></colgroup>
<tr><td class="Q"><p class="R">Constructor Detail</p>
</td>
</tr>
</table></td>
</tr></table>
<p class="F">&nbsp;</p>
<p id="AMap::AMap()" class="S"><span class="N">AMap</span>()</p>
<p class="T">Constructor. Constructs an empty AMap.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="AMap::AMap(const AMap&,int)" class="S"><span class="N">AMap</span>(<span class="U">const</span>&nbsp;<span class="N">AMap</span><span class="U">&amp;</span>&nbsp;<span class="V">s</span>, <span class="U">int</span>)</p>
<p class="T">Optional deep copy constructor.</p>
<p class="W">Requires T to have deep copy constructor or optional deep copy constructor.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="X">s</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Source AMap.</p></td></tr></table>
<hr><p class="F">&nbsp;</p>
<p id="AMap::AMap(pick_ Index<K,HashFn>&,pick_ V&)" class="S"><span class="N">AMap</span>(<span class="Y">pick_</span>&nbsp;Index<span class="U">&lt;</span><span class="I">K</span>, <span class="I">HashFn</span><span class="U">&gt;&amp;</span>&nbsp;<span class="V">ndx</span>, <span class="Y">pick_</span>&nbsp;<span class="I">V</span><span class="U">&amp;</span>&nbsp;<span class="V">val</span>)</p>
<p class="T">This form of constructors creates AMap by picking Index of keys <span class="V">ndx</span> and basic random access container of values. Both containers must have same number of elements <span class="V">val</span>.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="AMap::AMap(pick_ Vector<K>&,pick_ V&)" class="S"><span class="N">AMap</span>(<span class="Y">pick_</span>&nbsp;Vector<span class="U">&lt;</span><span class="I">K</span><span class="U">&gt;&amp;</span>&nbsp;<span class="V">ndx</span>, <span class="Y">pick_</span>&nbsp;<span class="I">V</span><span class="U">&amp;</span>&nbsp;<span class="V">val</span>)</p>
<p class="T">This form of constructors creates AMap by picking Vector of keys and basic random access container of values. Both containers must have same number of elements.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Z">ndx</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Keys.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="V">val</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Values.</p></td></tr></table>
<p class="F">&nbsp;</p>
<p class="A">&nbsp;</p>
<table width="100%" border="0" cellpadding="0" cellspacing="0"><tr><td width="100%"><table width="100%" class="P"><colgroup><col width="100%"></colgroup>
<tr><td class="Q"><p class="R">Public Method List</p>
</td>
</tr>
</table></td>
</tr></table>
<p class="F">&nbsp;</p>
<p id="AMap::Add(const K&,const T&)" class="S"><span class="I">T</span><span class="U">&amp;</span>&nbsp;<span class="N">Add</span>(<span class="U">const</span>&nbsp;<span class="I">K</span><span class="U">&amp;</span>&nbsp;<span class="V">k</span>, <span class="U">const</span>&nbsp;<span class="I">T</span><span class="U">&amp;</span>&nbsp;<span class="V">x</span>)</p>
<p id="Upp::AMap::Add(const K&,T&&)" class="S"><span class="I">T</span><span class="U">&amp;</span>&nbsp;<span class="N">Add</span>(<span class="U">const</span>&nbsp;<span class="I">K</span><span class="U">&amp;</span>&nbsp;<span class="V">k</span>, <span class="I">T</span><span class="U">&amp;&amp;</span>&nbsp;<span class="V">x</span>)</p>
<p id="AMap::Add(const K&)" class="S"><span class="I">T</span><span class="U">&amp;</span>&nbsp;<span class="N">Add</span>(<span class="U">const</span>&nbsp;<span class="I">K</span><span class="U">&amp;</span>&nbsp;<span class="V">k</span>)</p>
<p id="Upp::AMap::Add(K&&,const T&)" class="S"><span class="I">T</span><span class="U">&amp;</span>&nbsp;<span class="N">Add</span>(<span class="I">K</span><span class="U">&amp;&amp;</span>&nbsp;<span class="V">k</span>, <span class="U">const</span>&nbsp;<span class="I">T</span><span class="U">&amp;</span>&nbsp;<span class="V">x</span>)</p>
<p id="Upp::AMap::Add(K&&,T&&)" class="S"><span class="I">T</span><span class="U">&amp;</span>&nbsp;<span class="N">Add</span>(<span class="I">K</span><span class="U">&amp;&amp;</span>&nbsp;<span class="V">k</span>, <span class="I">T</span><span class="U">&amp;&amp;</span>&nbsp;<span class="V">x</span>)</p>
<p id="Upp::AMap::Add(K&&)" class="S"><span class="I">T</span><span class="U">&amp;</span>&nbsp;<span class="N">Add</span>(<span class="I">K</span><span class="U">&amp;&amp;</span>&nbsp;<span class="V">k</span>)</p>
<p class="T">Adds a key and value pair to the AMap. Returns a reference to the element. If value is not specified, it is default constructed.</p>
<p class="W">Invalidates iterators to AIndex.</p>
<p class="W">Invalidates iterators to AMap.</p>
<p class="W">Invalidates references to keys.</p>
<p class="W">Invalidates references to AMap values.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="AMap::FindAdd(const K&)" class="S"><span class="U">int</span>&nbsp;<span class="N">FindAdd</span>(<span class="U">const</span>&nbsp;<span class="I">K</span><span class="U">&amp;</span>&nbsp;<span class="V">k</span>)</p>
<p class="T">Retrieves the position of first element with the specified key in AMap, using a precomputed hash value. The precomputed hash value must be the same as the hash value that would be the result of HashFn. If multi-key ordering is not broken and more than one element with the same value exists in AMap, the lowest position is retrieved. If the element does not exist in AMap, a negative number is returned. Unlinked elements are ignored.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Z">x</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Key to find.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Z">h</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Precomputed hash value.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="O">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Position of element or a negative value if element is not in AMap.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="AMap::Find(const K&)const" class="AA">int<span class="H">&nbsp;</span><span class="AB">Find</span><span class="H">(</span>const<span class="H">&nbsp;</span><span class="I">K</span>&amp;<span class="H">&nbsp;</span><span class="V">k</span><span class="H">)&nbsp;</span>const</p>
<p class="T">Retrieves the position of first element with the specified key in AMap. If multi-key ordering is not broken and more than one element with the same value exists in AMap, the lowest position is retrieved. If the element does not exist in AMap, a negative number is returned. Unlinked elements are ignored.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Z">x</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Key to find.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="O">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Position of element or a negative value if element is not in AMap.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="AMap::FindNext(int)const" class="AA">int<span class="H">&nbsp;</span><span class="AB">FindNext</span><span class="H">(</span>int<span class="H">&nbsp;</span><span class="V">i</span><span class="H">)&nbsp;</span>const</p>
<p class="T">Retrieves the position of next element with the same key as element at the specified position. If multi-key ordering is not broken and more than one element with that value exists in AMap, the lowest position greater than specified one is retrieved (so that positions got by subsequent calls to FindNext are in ascending order). When there are no more elements with required key, a negative number is returned. Unlinked elements are ignored.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="AMap::Find(const K&,unsigned)const" class="AA">int<span class="H">&nbsp;</span><span class="AB">Find</span><span class="H">(</span>const<span class="H">&nbsp;</span><span class="I">K</span>&amp;<span class="H">&nbsp;</span><span class="V">k</span><span class="H">, </span>unsigned<span class="H">&nbsp;</span><span class="V">h</span><span class="H">)&nbsp;</span>const</p>
<p class="T">Retrieves the position of next element with the same key as element at the specified position. If multi-key ordering is not broken and more than one element with that value exists in AMap, the lowest position greater than specified one is retrieved (so that positions got by subsequent calls to FindNext are in ascending order). When there are no more elements with required key, negative number is returned. Unlinked elements are ignored.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Z">i</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Position of element.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="O">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Position of next element with same value.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="AMap::FindLast(const K&,unsigned)const" class="AA">int<span class="H">&nbsp;</span><span class="AB">FindLast</span><span class="H">(</span>const<span class="H">&nbsp;</span><span class="I">K</span>&amp;<span class="H">&nbsp;</span><span class="V">k</span><span class="H">, </span>unsigned<span class="H">&nbsp;</span><span class="V">h</span><span class="H">)&nbsp;</span>const</p>
<p class="T">Retrieves position of last element with the specified key in AMap, using a precomputed hash value. The precomputed hash value must be the same as the hash value that would be the result of HashFn. If multi-key ordering is not broken and more than one element with the same value exists in AMap, the greatest position is retrieved. If element does not exist in AMap, a negative number is returned. Unlinked elements are ignored.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Z">x</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Key to find.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Z">h</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Precomputed hash value.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="O">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Position of element or a negative value if element is not in AMap.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="AMap::FindLast(const K&)const" class="AA">int<span class="H">&nbsp;</span><span class="AB">FindLast</span><span class="H">(</span>const<span class="H">&nbsp;</span><span class="I">K</span>&amp;<span class="H">&nbsp;</span><span class="V">k</span><span class="H">)&nbsp;</span>const</p>
<p class="T">Retrieves the position of last element with the specified key in AMap. If multi-key ordering is not broken and more than one element with the same value exists in AIndex, the greatest position is retrieved. If element does not exist in AMap, a negative number is returned. Unlinked elements are ignored.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Z">x</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Element to find.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="O">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Position of element or a negative value if element is not in AMap.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="AMap::FindPrev(int)const" class="AA">int<span class="H">&nbsp;</span><span class="AB">FindPrev</span><span class="H">(</span>int<span class="H">&nbsp;</span><span class="V">i</span><span class="H">)&nbsp;</span>const</p>
<p class="T">Retrieves the position of previous element with the same key as element at the specified position. If multi-key ordering is not broken and more than one element with that value exists in AMap, the greatest position lower than specified one is retrieved (so that positions got by subsequent calls to FindPrev are in descending order). When there are no more elements with required key, a negative number is returned. Unlinked elements are ignored.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Z">i</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Position of element.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="O">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Position of previous element with same value.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="AMap::FindAdd(const K&)" class="S"><span class="U">int</span>&nbsp;<span class="N">FindAdd</span>(<span class="U">const</span>&nbsp;<span class="I">K</span><span class="U">&amp;</span>&nbsp;<span class="V">k</span>)</p>
<p id="AMap::FindAdd(const K&,const T&)" class="S"><span class="U">int</span>&nbsp;<span class="N">FindAdd</span>(<span class="U">const</span>&nbsp;<span class="I">K</span><span class="U">&amp;</span>&nbsp;<span class="V">k</span>, <span class="U">const</span>&nbsp;<span class="I">T</span><span class="U">&amp;</span>&nbsp;<span class="V">init</span>)</p>
<p id="Upp::AMap::FindAdd(const K&,T&&)" class="S"><span class="U">int</span>&nbsp;<span class="N">FindAdd</span>(<span class="U">const</span>&nbsp;<span class="I">K</span><span class="U">&amp;</span>&nbsp;<span class="V">k</span>, <span class="I">T</span><span class="U">&amp;&amp;</span>&nbsp;<span class="V">x</span>)</p>
<p id="Upp::AMap::FindAdd(K&&)" class="S"><span class="U">int</span>&nbsp;<span class="N">FindAdd</span>(<span class="I">K</span><span class="U">&amp;&amp;</span>&nbsp;<span class="V">k</span>)</p>
<p id="Upp::AMap::FindAdd(K&&,const T&)" class="S"><span class="U">int</span>&nbsp;<span class="N">FindAdd</span>(<span class="I">K</span><span class="U">&amp;&amp;</span>&nbsp;<span class="V">k</span>, <span class="U">const</span>&nbsp;<span class="I">T</span><span class="U">&amp;</span>&nbsp;<span class="V">init</span>)</p>
<p id="Upp::AMap::FindAdd(K&&,T&&)" class="S"><span class="U">int</span>&nbsp;<span class="N">FindAdd</span>(<span class="I">K</span><span class="U">&amp;&amp;</span>&nbsp;<span class="V">k</span>, <span class="I">T</span><span class="U">&amp;&amp;</span>&nbsp;<span class="V">init</span>)</p>
<p class="T">Retrieves the position of first element with the specified key in AMap. If multi-key ordering is not broken and more than one element with the same value exists in AMap, lowest position is retrieved. If the element does not exist in AMap, adds new element (if <span class="V">init</span> is present, constructed form <span class="V">init</span> otherwise default constructed) at the end of AMap and returns its position. Unlinked elements are ignored.</p>
<p class="W">Invalidates iterators to AMap.</p>
<p class="W">Invalidates references to keys.</p>
<p class="W">Invalidates references to VectorMap values.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="AMap::Unlink(int)" class="S"><span class="U">void</span>&nbsp;<span class="N">Unlink</span>(<span class="U">int</span>&nbsp;<span class="V">i</span>)</p>
<p class="T">Unlinks element at the specified position. Unlinked item stays in AMap but is ignored by any Find operation.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Z">i</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Position of element to unlink.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="AMap::Put(const K&,const T&)" class="S"><span class="U">int</span>&nbsp;<span class="N">Put</span>(<span class="U">const</span>&nbsp;<span class="I">K</span><span class="U">&amp;</span>&nbsp;<span class="V">k</span>, <span class="U">const</span>&nbsp;<span class="I">T</span><span class="U">&amp;</span>&nbsp;<span class="V">x</span>)</p>
<p id="Upp::AMap::Put(const K&,T&&)" class="S"><span class="U">int</span>&nbsp;<span class="N">Put</span>(<span class="U">const</span>&nbsp;<span class="I">K</span><span class="U">&amp;</span>&nbsp;<span class="V">k</span>, <span class="I">T</span><span class="U">&amp;&amp;</span>&nbsp;<span class="V">x</span>)</p>
<p id="Upp::AMap::Put(K&&,const T&)" class="S"><span class="U">int</span>&nbsp;<span class="N">Put</span>(<span class="I">K</span><span class="U">&amp;&amp;</span>&nbsp;<span class="V">k</span>, <span class="U">const</span>&nbsp;<span class="I">T</span><span class="U">&amp;</span>&nbsp;<span class="V">x</span>)</p>
<p id="Upp::AMap::Put(K&&,T&&)" class="S"><span class="U">int</span>&nbsp;<span class="N">Put</span>(<span class="I">K</span><span class="U">&amp;&amp;</span>&nbsp;<span class="V">k</span>, <span class="I">T</span><span class="U">&amp;&amp;</span>&nbsp;<span class="V">x</span>)</p>
<p class="T">If there are any unlinked elements in AMap, one of them is replaced by the specified key/value pair. If there is no unlinked element, the key/value pair is added to the end of AIndex using Add. Value is transfered using deep copy constructor. The return values is the index of replaced / added pair.</p>
<p class="W">Invalidates multi-key ordering.</p>
<p class="W">Invalidates iterators to AMap.</p>
<p class="W">Invalidates references to keys.</p>
<p class="W">Invalidates references to VectorMap values.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="AMap::Put(const K&)" class="S"><span class="I">T</span><span class="U">&amp;</span>&nbsp;<span class="N">Put</span>(<span class="U">const</span>&nbsp;<span class="I">K</span><span class="U">&amp;</span>&nbsp;<span class="V">k</span>)</p>
<p id="Upp::AMap::Put(K&&)" class="S"><span class="I">T</span><span class="U">&amp;</span>&nbsp;<span class="N">Put</span>(<span class="I">K</span><span class="U">&amp;&amp;</span>&nbsp;<span class="V">k</span>)</p>
<p class="T">If there is any unlinked element in AMap, it is replaced by the specified key and reference to the value is returned. If there is none unlinked element, key is added at the end of AIndex using Add and a reference to corresponding default constructed Value is returned.</p>
<p class="W">Invalidates multi-key ordering.</p>
<p class="W">Invalidates iterators to AMap.</p>
<p class="W">Invalidates references to keys.</p>
<p class="W">Invalidates references to VectorMap values.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="AMap::PutDefault(const K&)" class="S"><span class="U">int</span>&nbsp;<span class="N">PutDefault</span>(<span class="U">const</span>&nbsp;<span class="I">K</span><span class="U">&amp;</span>&nbsp;<span class="V">k</span>)</p>
<p id="Upp::AMap::PutDefault(K&&)" class="S"><span class="U">int</span>&nbsp;<span class="N">PutDefault</span>(<span class="I">K</span><span class="U">&amp;&amp;</span>&nbsp;<span class="V">k</span>)</p>
<p class="T">Similar to Put, but value is default constructed.</p>
<p class="W">Invalidates multi-key ordering.</p>
<p class="W">Invalidates iterators to AMap.</p>
<p class="W">Invalidates references to keys.</p>
<p class="W">Invalidates references to VectorMap values.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="AMap::FindPut(const K&)" class="S"><span class="U">int</span>&nbsp;<span class="N">FindPut</span>(<span class="U">const</span>&nbsp;<span class="I">K</span><span class="U">&amp;</span>&nbsp;<span class="V">k</span>)</p>
<p id="AMap::FindPut(const K&,const T&)" class="S"><span class="U">int</span>&nbsp;<span class="N">FindPut</span>(<span class="U">const</span>&nbsp;<span class="I">K</span><span class="U">&amp;</span>&nbsp;<span class="V">k</span>, <span class="U">const</span>&nbsp;<span class="I">T</span><span class="U">&amp;</span>&nbsp;<span class="V">init</span>)</p>
<p id="Upp::AMap::FindPut(const K&,T&&)" class="S"><span class="U">int</span>&nbsp;<span class="N">FindPut</span>(<span class="U">const</span>&nbsp;<span class="I">K</span><span class="U">&amp;</span>&nbsp;<span class="V">k</span>, <span class="I">T</span><span class="U">&amp;&amp;</span>&nbsp;<span class="V">init</span>)</p>
<p id="Upp::AMap::FindPut(K&&)" class="S"><span class="U">int</span>&nbsp;<span class="N">FindPut</span>(<span class="I">K</span><span class="U">&amp;&amp;</span>&nbsp;<span class="V">k</span>)</p>
<p id="Upp::AMap::FindPut(K&&,const T&)" class="S"><span class="U">int</span>&nbsp;<span class="N">FindPut</span>(<span class="I">K</span><span class="U">&amp;&amp;</span>&nbsp;<span class="V">k</span>, <span class="U">const</span>&nbsp;<span class="I">T</span><span class="U">&amp;</span>&nbsp;<span class="V">init</span>)</p>
<p id="Upp::AMap::FindPut(K&&,T&&)" class="S"><span class="U">int</span>&nbsp;<span class="N">FindPut</span>(<span class="I">K</span><span class="U">&amp;&amp;</span>&nbsp;<span class="V">k</span>, <span class="I">T</span><span class="U">&amp;&amp;</span>&nbsp;<span class="V">init</span>)</p>
<p class="T">Retrieves the position of first element with the specified key in AMap. Unlinked elements are ignored. If the element does not exist in AMap, puts new element, deep copy constructed from init, using Put and returns its position. </p>
<p class="W">Invalidates iterators to AMap.</p>
<p class="W">Invalidates references to keys.</p>
<p class="W">Invalidates references to VectorMap values.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="AMap::Get(const K&)" class="S"><span class="I">T</span><span class="U">&amp;</span>&nbsp;<span class="N">Get</span>(<span class="U">const</span>&nbsp;<span class="I">K</span><span class="U">&amp;</span>&nbsp;<span class="V">k</span>)</p>
<p class="T">Retrieves a reference to the first element with the specified key. If multi-key ordering is not broken and more than one element with the same value exists in AMap, the lowest position element is retrieved. Unlinked elements are ignored. Required key must be in AMap, otherwise it is logic error (asserted in debug mode).</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Z">k</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Key to find.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="O">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Reference to corresponding value.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="AMap::Get(const K&)const" class="AA">const<span class="H">&nbsp;</span><span class="I">T</span>&amp;<span class="H">&nbsp;</span><span class="AB">Get</span><span class="H">(</span>const<span class="H">&nbsp;</span><span class="I">K</span>&amp;<span class="H">&nbsp;</span><span class="V">k</span><span class="H">)&nbsp;</span>const</p>
<p class="T">Retrieves a constant reference of the first element with the specified key. If multi-key ordering is not broken and more than one element with the same value exists in AMap, the lowest position element is retrieved. Unlinked elements are ignored. Required key must be in AMap, otherwise it is logic error (asserted in debug mode).</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Z">k</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Key to find.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="O">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Reference to corresponding value.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="AMap::Get(const K&,const T&)const" class="AA">const<span class="H">&nbsp;</span><span class="I">T</span>&amp;<span class="H">&nbsp;</span><span class="AB">Get</span><span class="H">(</span>const<span class="H">&nbsp;</span><span class="I">K</span>&amp;<span class="H">&nbsp;</span><span class="V">k</span><span class="H">, </span>const<span class="H">&nbsp;</span><span class="I">T</span>&amp;<span class="H">&nbsp;</span><span class="V">d</span><span class="H">)&nbsp;</span>const</p>
<p class="T">Retrieves a constant reference value of the first element with the specified key. If multi-key ordering is not broken and more than one element with the same value exists in AMap, the lowest position element is retrieved. Unlinked elements are ignored. If the required key is not in the AMap, constant reference to the specified value is returned instead.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Z">k</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Key to find.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Z">d</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Value to be returned if key is not found.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="O">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Reference to found element or supplied value.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="AMap::GetAdd(const K&)" class="S"><span class="I">T</span><span class="U">&amp;</span>&nbsp;<span class="N">GetAdd</span>(<span class="U">const</span>&nbsp;<span class="I">K</span><span class="U">&amp;</span>&nbsp;<span class="V">k</span>)</p>
<p id="AMap::GetAdd(const K&,const T&)" class="S"><span class="I">T</span><span class="U">&amp;</span>&nbsp;<span class="N">GetAdd</span>(<span class="U">const</span>&nbsp;<span class="I">K</span><span class="U">&amp;</span>&nbsp;<span class="V">k</span>, <span class="U">const</span>&nbsp;<span class="I">T</span><span class="U">&amp;</span>&nbsp;<span class="V">x</span>)</p>
<p id="Upp::AMap::GetAdd(const K&,T&&)" class="S"><span class="I">T</span><span class="U">&amp;</span>&nbsp;<span class="N">GetAdd</span>(<span class="U">const</span>&nbsp;<span class="I">K</span><span class="U">&amp;</span>&nbsp;<span class="V">k</span>, <span class="I">T</span><span class="U">&amp;&amp;</span>&nbsp;<span class="V">x</span>)</p>
<p id="Upp::AMap::GetAdd(K&&)" class="S"><span class="I">T</span><span class="U">&amp;</span>&nbsp;<span class="N">GetAdd</span>(<span class="I">K</span><span class="U">&amp;&amp;</span>&nbsp;<span class="V">k</span>)</p>
<p id="Upp::AMap::GetAdd(K&&,const T&)" class="S"><span class="I">T</span><span class="U">&amp;</span>&nbsp;<span class="N">GetAdd</span>(<span class="I">K</span><span class="U">&amp;&amp;</span>&nbsp;<span class="V">k</span>, <span class="U">const</span>&nbsp;<span class="I">T</span><span class="U">&amp;</span>&nbsp;<span class="V">x</span>)</p>
<p id="Upp::AMap::GetAdd(K&&,T&&)" class="S"><span class="I">T</span><span class="U">&amp;</span>&nbsp;<span class="N">GetAdd</span>(<span class="I">K</span><span class="U">&amp;&amp;</span>&nbsp;<span class="V">k</span>, <span class="I">T</span><span class="U">&amp;&amp;</span>&nbsp;<span class="V">x</span>)</p>
<p class="T">Retrieves a constant reference to the first element with the specified key. If multi-key ordering is not broken and more than one element with the same value exists in AMap, the lowest position element is retrieved. Unlinked elements are ignored. If required key is not in the AMap, adds new element (<span class="V">x </span>or default constructed) at the end of AMap and returns a reference to it.</p>
<p class="W">Invalidates iterators to AMap.</p>
<p class="W">Invalidates references to keys.</p>
<p class="W">Invalidates references to VectorMap values.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="AMap::GetPut(const K&)" class="S"><span class="I">T</span><span class="U">&amp;</span>&nbsp;<span class="N">GetPut</span>(<span class="U">const</span>&nbsp;<span class="I">K</span><span class="U">&amp;</span>&nbsp;<span class="V">k</span>)</p>
<p id="AMap::GetPut(const K&,const T&)" class="S"><span class="I">T</span><span class="U">&amp;</span>&nbsp;<span class="N">GetPut</span>(<span class="U">const</span>&nbsp;<span class="I">K</span><span class="U">&amp;</span>&nbsp;<span class="V">k</span>, <span class="U">const</span>&nbsp;<span class="I">T</span><span class="U">&amp;</span>&nbsp;<span class="V">x</span>)</p>
<p id="Upp::AMap::GetPut(const K&,T&&)" class="S"><span class="I">T</span><span class="U">&amp;</span>&nbsp;<span class="N">GetPut</span>(<span class="U">const</span>&nbsp;<span class="I">K</span><span class="U">&amp;</span>&nbsp;<span class="V">k</span>, <span class="I">T</span><span class="U">&amp;&amp;</span>&nbsp;<span class="V">x</span>)</p>
<p id="Upp::AMap::GetPut(K&&)" class="S"><span class="I">T</span><span class="U">&amp;</span>&nbsp;<span class="N">GetPut</span>(<span class="I">K</span><span class="U">&amp;&amp;</span>&nbsp;<span class="V">k</span>)</p>
<p id="Upp::AMap::GetPut(K&&,const T&)" class="S"><span class="I">T</span><span class="U">&amp;</span>&nbsp;<span class="N">GetPut</span>(<span class="I">K</span><span class="U">&amp;&amp;</span>&nbsp;<span class="V">k</span>, <span class="U">const</span>&nbsp;<span class="I">T</span><span class="U">&amp;</span>&nbsp;<span class="V">x</span>)</p>
<p id="Upp::AMap::GetPut(K&&,T&&)" class="S"><span class="I">T</span><span class="U">&amp;</span>&nbsp;<span class="N">GetPut</span>(<span class="I">K</span><span class="U">&amp;&amp;</span>&nbsp;<span class="V">k</span>, <span class="I">T</span><span class="U">&amp;&amp;</span>&nbsp;<span class="V">x</span>)</p>
<p class="T">Retrieves a constant reference value of the first element with the specified key. If multi-key ordering is not broken and more than one element with the same value exists in AMap, lowest position element is retrieved. Unlinked elements are ignored. If required key is not in the AMap, puts new element (<span class="AC">x </span>or default constructed) into the AMap using Put and returns a reference to it.</p>
<p class="W">Invalidates iterators to AMap.</p>
<p class="W">Invalidates references to keys.</p>
<p class="W">Invalidates references to VectorMap values.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="AMap::SetKey(int,const K&)" class="S"><span class="U">void</span>&nbsp;<span class="N">SetKey</span>(<span class="U">int</span>&nbsp;<span class="V">i</span>, <span class="U">const</span>&nbsp;<span class="I">K</span><span class="U">&amp;</span>&nbsp;<span class="V">k</span>)</p>
<p id="Upp::AMap::SetKey(int,K&&)" class="S"><span class="U">void</span>&nbsp;<span class="N">SetKey</span>(<span class="U">int</span>&nbsp;<span class="V">i</span>, <span class="I">K</span><span class="U">&amp;&amp;</span>&nbsp;<span class="V">k</span>)</p>
<p class="T">Replaces key of element at the specified position.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="AMap::FindPtr(const K&)" class="S"><span class="I">T</span>&nbsp;*<span class="N">FindPtr</span>(<span class="U">const</span>&nbsp;<span class="I">K</span><span class="U">&amp;</span>&nbsp;<span class="V">k</span>)</p>
<p class="T">Retrieves a pointer to value of first element with the specified key in AMap. If multi-key ordering is not broken and more than one element with the same value exists in AMap, the lowest position is retrieved. If the element does not exist in AMap, NULL pointer is returned. Unlinked elements are ignored.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Z">k</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Key to find.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="O">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Pointer to value or NULL pointer if element is not in AMap.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="AMap::FindPtr(const K&)const" class="AA">const<span class="H">&nbsp;</span><span class="I">T</span><span class="H">&nbsp;*</span><span class="AB">FindPtr</span><span class="H">(</span>const<span class="H">&nbsp;</span><span class="I">K</span>&amp;<span class="H">&nbsp;</span><span class="V">k</span><span class="H">)&nbsp;</span>const</p>
<p class="T">Retrieves a constant pointer to value of the first element with the specified key in AMap. If multi-key ordering is not broken and more than one element with the same value exists in AMap, the lowest position is retrieved. If the element does not exist in AMap, NULL pointer is returned. Unlinked elements are ignored.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Z">k</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Key to find.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="O">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Pointer to value or NULL pointer if element is not in AMap.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="AMap::FindLastPtr(const K&)" class="S"><span class="I">T</span>&nbsp;*<span class="N">FindLastPtr</span>(<span class="U">const</span>&nbsp;<span class="I">K</span><span class="U">&amp;</span>&nbsp;<span class="V">k</span>)</p>
<p id="AMap::FindLastPtr(const K&)const" class="AA">const<span class="H">&nbsp;</span><span class="I">T</span><span class="H">&nbsp;*</span><span class="AB">FindLastPtr</span><span class="H">(</span>const<span class="H">&nbsp;</span><span class="I">K</span>&amp;<span class="H">&nbsp;</span><span class="V">k</span><span class="H">)&nbsp;</span>const</p>
<p class="T">Retrieves a constant pointer to value of the last element with the specified key in AMap. If multi-key ordering is not broken and more than one element with the same value exists in AMap, the greatest position is retrieved. If the element does not exist in AMap, NULL pointer is returned. Unlinked elements are ignored..</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="AMap::UnlinkKey(const K&,unsigned)" class="S"><span class="U">int</span>&nbsp;<span class="N">UnlinkKey</span>(<span class="U">const</span>&nbsp;<span class="I">K</span><span class="U">&amp;</span>&nbsp;<span class="V">k</span>, <span class="U">unsigned</span>&nbsp;<span class="V">h</span>)</p>
<p class="T">Unlinks all elements with the specified key using precomputed hash-value. Unlinked elements stay in AIndex but are ignored by any Find operations. The precomputed hash value must be the same as the hash value that would be the result of HashFn. </p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Z">k</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Key to unlink.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Z">h</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Precomputed hash value.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="O">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Number of elements unlinked.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="AMap::UnlinkKey(const K&)" class="S"><span class="U">int</span>&nbsp;<span class="N">UnlinkKey</span>(<span class="U">const</span>&nbsp;<span class="I">K</span><span class="U">&amp;</span>&nbsp;<span class="V">k</span>)</p>
<p class="T">Unlinks all elements with the specified key. Unlinked elements stay in AIndex but are ignored by any Find operations.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Z">k</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Key to unlink.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="O">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Number of elements unlinked.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="AMap::IsUnlinked(int)const" class="AA">bool<span class="H">&nbsp;</span><span class="AB">IsUnlinked</span><span class="H">(</span>int<span class="H">&nbsp;</span><span class="V">i</span><span class="H">)&nbsp;</span>const</p>
<p class="T">Tests whether element at the specified position is unlinked.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Z">i</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Position.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="O">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">true if element is unlinked.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="AMap::Sweep()" class="S"><span class="U">void</span>&nbsp;<span class="N">Sweep</span>()</p>
<p class="T">Removes all unlinked elements from the container.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="AMap::HasUnlinked()const" class="AA">bool<span class="H">&nbsp;</span><span class="AB">HasUnlinked</span><span class="H">()&nbsp;</span>const</p>
<p class="T">Returns true if AMap has any unlinked elements.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="AMap::Insert(int,const K&)" class="S"><span class="I">T</span><span class="U">&amp;</span>&nbsp;<span class="N">Insert</span>(<span class="U">int</span>&nbsp;<span class="V">i</span>, <span class="U">const</span>&nbsp;<span class="I">K</span><span class="U">&amp;</span>&nbsp;<span class="V">k</span>)</p>
<p id="AMap::Insert(int,const K&,const T&)" class="S"><span class="I">T</span><span class="U">&amp;</span>&nbsp;<span class="N">Insert</span>(<span class="U">int</span>&nbsp;<span class="V">i</span>, <span class="U">const</span>&nbsp;<span class="I">K</span><span class="U">&amp;</span>&nbsp;<span class="V">k</span>, <span class="U">const</span>&nbsp;<span class="I">T</span><span class="U">&amp;</span>&nbsp;<span class="V">x</span>)</p>
<p id="Upp::AMap::Insert(int,const K&,T&&)" class="S"><span class="I">T</span><span class="U">&amp;</span>&nbsp;<span class="N">Insert</span>(<span class="U">int</span>&nbsp;<span class="V">i</span>, <span class="U">const</span>&nbsp;<span class="I">K</span><span class="U">&amp;</span>&nbsp;<span class="V">k</span>, <span class="I">T</span><span class="U">&amp;&amp;</span>&nbsp;<span class="V">x</span>)</p>
<p id="Upp::AMap::Insert(int,K&&)" class="S"><span class="I">T</span><span class="U">&amp;</span>&nbsp;<span class="N">Insert</span>(<span class="U">int</span>&nbsp;<span class="V">i</span>, <span class="I">K</span><span class="U">&amp;&amp;</span>&nbsp;<span class="V">k</span>)</p>
<p id="Upp::AMap::Insert(int,K&&,const T&)" class="S"><span class="I">T</span><span class="U">&amp;</span>&nbsp;<span class="N">Insert</span>(<span class="U">int</span>&nbsp;<span class="V">i</span>, <span class="I">K</span><span class="U">&amp;&amp;</span>&nbsp;<span class="V">k</span>, <span class="U">const</span>&nbsp;<span class="I">T</span><span class="U">&amp;</span>&nbsp;<span class="V">x</span>)</p>
<p id="Upp::AMap::Insert(int,K&&,T&&)" class="S"><span class="I">T</span><span class="U">&amp;</span>&nbsp;<span class="N">Insert</span>(<span class="U">int</span>&nbsp;<span class="V">i</span>, <span class="I">K</span><span class="U">&amp;&amp;</span>&nbsp;<span class="V">k</span>, <span class="I">T</span><span class="U">&amp;&amp;</span>&nbsp;<span class="V">x</span>)</p>
<p class="T">Inserts an element with the specified key at the specified position, with value <span class="V">x</span> or default constructed. Returns a reference to the new element.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="AMap::Remove(int)" class="S"><span class="U">void</span>&nbsp;<span class="N">Remove</span>(<span class="U">int</span>&nbsp;<span class="V">i</span>)</p>
<p class="T">Removes the element at the specified position. This is a slow operation, especially when combined with any search operations.</p>
<p class="W">Invalidates iterators to AMap.</p>
<p class="W">Invalidates references to keys.</p>
<p class="W">Invalidates references to VectorMap values.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Z">i</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Position of element to remove.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="AMap::Remove(int,int)" class="S"><span class="U">void</span>&nbsp;<span class="N">Remove</span>(<span class="U">int</span>&nbsp;<span class="V">i</span>, <span class="U">int</span>&nbsp;<span class="V">count</span>)</p>
<p class="T">Removes <span class="V">count</span> elements at <span class="V">i</span>.</p>
<p class="W">Invalidates iterators to AMap.</p>
<p class="W">Invalidates references to keys.</p>
<p class="W">Invalidates references to VectorMap values.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="AMap::Remove(const int*,int)" class="S"><span class="U">void</span>&nbsp;<span class="N">Remove</span>(<span class="U">const</span>&nbsp;<span class="U">int</span>&nbsp;*<span class="V">sl</span>, <span class="U">int</span>&nbsp;<span class="V">n</span>)</p>
<p class="T">Removes number of elements from AMap. Time of operation only slightly depends on the number of removed elements. This is a slow operation, especially when combined with any search operations.</p>
<p class="W">Invalidates iterators to AMap.</p>
<p class="W">Invalidates references to keys.</p>
<p class="W">Invalidates references to VectorMap values.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Z">i</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Position of element to remove.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Z">sl</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Pointer to array of the positions to remove, in ascending order.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Z">n</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Number of elements to remove. </p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="AMap::Remove(const Vector<int>&)" class="S"><span class="U">void</span>&nbsp;<span class="N">Remove</span>(<span class="U">const</span>&nbsp;Vector<span class="U">&lt;int&gt;&amp;</span>&nbsp;<span class="V">sl</span>)</p>
<p class="T">Removes number of elements from AMap. Same as Remove(sorted_list, sorted_list.GetCount()).</p>
<p class="W">Invalidates iterators to AMap.</p>
<p class="W">Invalidates references to keys.</p>
<p class="W">Invalidates references to VectorMap values.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Z">sl</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Sorted Vector of positions to remove.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Upp::AMap::RemoveIf(P)" class="S"><span class="U">template</span> &lt;<span class="U">typename</span> P&gt; <span class="U">void</span> <span class="N">RemoveIf</span>(P <span class="V">p</span>)</p>
<p class="T">Removes all elements whose index satisfies predicate <span class="V">p</span>.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="AMap::RemoveKey(const K&)" class="S"><span class="U">int</span>&nbsp;<span class="N">RemoveKey</span>(<span class="U">const</span>&nbsp;<span class="I">K</span><span class="U">&amp;</span>&nbsp;<span class="V">k</span>)</p>
<p class="T">Removes all elements with the specified value. This is a slow operation, especially when combined with any search operations.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Z">k</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Key to remove.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="AMap::operator[](int)const" class="AA">const<span class="H">&nbsp;</span><span class="I">T</span>&amp;<span class="H">&nbsp;</span><span class="AB">operator[]</span><span class="H">(</span>int<span class="H">&nbsp;</span><span class="V">i</span><span class="H">)&nbsp;</span>const</p>
<p class="T">Returns a constant reference to the element at the specified position.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Z">i</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Position.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="O">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Constant reference to the element at the specified position.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="AMap::operator[](int)" class="S"><span class="I">T</span><span class="U">&amp;</span>&nbsp;<span class="N">operator[]</span>(<span class="U">int</span>&nbsp;<span class="V">i</span>)</p>
<p class="T">Returns a reference to the element at the specified position.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Z">i</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Position.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="O">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Constant reference to the element at the specified position.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="AMap::GetCount()const" class="AA">int<span class="H">&nbsp;</span><span class="AB">GetCount</span><span class="H">()&nbsp;</span>const</p>
<p class="T">Returns the number of elements in AMap.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="O">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Actual number of elements.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="AMap::IsEmpty()const" class="AA">bool<span class="H">&nbsp;</span><span class="AB">IsEmpty</span><span class="H">()&nbsp;</span>const</p>
<p class="T">Tests whether AMap is empty. Same as GetCount() == 0.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="O">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">true if AMap is empty, false otherwise.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="AMap::Clear()" class="S"><span class="U">void</span>&nbsp;<span class="N">Clear</span>()</p>
<p class="T">Removes all elements from AMap.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="AMap::Shrink()" class="S"><span class="U">void</span>&nbsp;<span class="N">Shrink</span>()</p>
<p class="T">Minimizes memory consumption of AMap by decreasing the capacity to the number of elements.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="AMap::Reserve(int)" class="S"><span class="U">void</span>&nbsp;<span class="N">Reserve</span>(<span class="U">int</span>&nbsp;<span class="V">xtra</span>)</p>
<p class="T">Reserves capacity. If the required capacity is greater than current capacity, capacity is increased to the required value.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Z">n</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Required capacity.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="AMap::GetAlloc()const" class="AA">int<span class="H">&nbsp;</span><span class="AB">GetAlloc</span><span class="H">()&nbsp;</span>const</p>
<p class="T">Returns the current capacity of Array.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="O">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Capacity of Array.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="AMap::GetHash(int)const" class="AA">unsigned<span class="H">&nbsp;</span><span class="AB">GetHash</span><span class="H">(</span>int<span class="H">&nbsp;</span><span class="V">i</span><span class="H">)&nbsp;</span>const</p>
<p class="T">Returns a hash of element <span class="V">i</span>. This is perhaps only useful when making the exact copy of AMap, e.g. in the persistent storage.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="AMap::Drop(int)" class="S"><span class="U">void</span>&nbsp;<span class="N">Drop</span>(<span class="U">int</span>&nbsp;<span class="V">n</span>&nbsp;=&nbsp;<span class="AC">1</span>)</p>
<p class="T">Drops the specified number of elements at the end of the AMap.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Z">n</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Number of elements.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="AMap::Top()" class="S"><span class="I">T</span><span class="U">&amp;</span>&nbsp;<span class="N">Top</span>()</p>
<p id="AMap::Top()const" class="AA">const<span class="H">&nbsp;</span><span class="I">T</span>&amp;<span class="H">&nbsp;</span><span class="AB">Top</span><span class="H">()&nbsp;</span>const</p>
<p class="T">Returns a reference to the value of the last element of AMap.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="O">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Reference to the value of the last element.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="AMap::TopKey()const" class="AA">const<span class="H">&nbsp;</span><span class="I">K</span>&amp;<span class="H">&nbsp;</span><span class="AB">TopKey</span><span class="H">()&nbsp;</span>const</p>
<p class="T">Returns a constant reference to the key of the last element of AMap.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="O">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Reference to the key of the last element.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="AMap::PopKey()" class="S"><span class="I">K</span>&nbsp;<span class="N">PopKey</span>()</p>
<p class="T">Drops the last element of AMap and returns the key of the dropped element.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="O">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Key of the element dropped at the end of AMap.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="AMap::Trim(int)" class="S"><span class="U">void</span>&nbsp;<span class="N">Trim</span>(<span class="U">int</span>&nbsp;<span class="V">n</span>)</p>
<p class="T">Reduces the number of items in map to <span class="V">n</span>. <span class="V">n</span> must be lover than or equal to GetCount().</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="AMap::GetKey(int)const" class="AA">const<span class="H">&nbsp;</span><span class="I">K</span>&amp;<span class="H">&nbsp;</span><span class="AB">GetKey</span><span class="H">(</span>int<span class="H">&nbsp;</span><span class="V">i</span><span class="H">)&nbsp;</span>const</p>
<p class="T">Returns a constant reference to the key of element at the specified position.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Z">i</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Position.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="O">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Constant reference to the key.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="AMap::Serialize(Stream&)" class="S"><span class="U">void</span>&nbsp;<span class="N">Serialize</span>(Stream<span class="U">&amp;</span>&nbsp;<span class="V">s</span>)</p>
<p class="T">Serializes the content of AMap to/from Stream. Works only if NTL is used as part of UPP.</p>
<p class="W">Requires T to have serialization operator defined.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Z">s</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Target/source stream.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="AMap::Swap(AMap&)" class="S"><span class="U">void</span>&nbsp;<span class="N">Swap</span>(<a href="AMap"><u>AMap</u></a><span class="U">&amp;</span>&nbsp;<span class="V">x</span>)</p>
<p class="T">Swap AMap content with another AMap (of the same type).</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="AMap::GetIndex()const" class="AA">const<span class="H">&nbsp;Index</span>&lt;<span class="I">K</span><span class="H">, </span><span class="I">HashFn</span>&gt;&amp;<span class="H">&nbsp;</span><span class="AB">GetIndex</span><span class="H">()&nbsp;</span>const</p>
<p class="T">Returns a constant reference to the internal Index of keys.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="O">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Constant reference to the Index of keys.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Upp::AMap::PickIndex()" class="S"><a href="Upp::Index"><u>Index</u></a>&lt;<span class="I">K</span>, <span class="I">HashFn</span>&gt;&nbsp;<span class="N">PickIndex</span>()</p>
<p class="T">Returns Index of keys. Destroys AMap by picking.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="O">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Index of keys.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="AMap::GetKeys()const" class="AA">const<span class="H">&nbsp;Vector</span>&lt;<span class="I">K</span>&gt;&amp;<span class="H">&nbsp;</span><span class="AB">GetKeys</span><span class="H">()&nbsp;</span>const</p>
<p class="T">Returns a constant reference to the Vector of keys.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="O">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Constant reference to the Vector of keys.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Upp::AMap::PickKeys()" class="S"><a href="Upp::Vector"><u>Vector</u></a>&lt;<span class="I">K</span>&gt;&nbsp;<span class="N">PickKeys</span>()</p>
<p class="T">Returns Vector of keys. Destroys AMap by picking.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="O">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Vector of keys.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="AMap::GetValues()const" class="AA">const<span class="H">&nbsp;</span><span class="I">V</span>&amp;<span class="H">&nbsp;</span><span class="AB">GetValues</span><span class="H">()&nbsp;</span>const</p>
<p class="AD">Returns a constant reference to the basic random access container of values.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="AMap::GetValues()" class="S"><span class="I">V</span><span class="U">&amp;</span>&nbsp;<span class="N">GetValues</span>()</p>
<p class="T">Returns a (writable) reference to the basic random access container of values. Destroys AIndex by picking.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Upp::AMap::PickValues()" class="S"><span class="I">V</span>&nbsp;<span class="N">PickValues</span>()</p>
<p class="T">Returns basic random access container of values. Destroys AIndex by picking.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="O">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Basic random access container of values.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Upp::AMap::operator~()" class="S"><a href="Upp::MapKVRange"><u>MapKVRange</u></a>&lt;<a href="Upp::AMap"><u>AMap</u></a>&lt;<span class="I">K</span>, <span class="I">T</span>, <span class="I">V</span>&gt;, <span class="I">K</span>, <span class="I">T</span>&gt;&nbsp;<span class="N">operator~</span>()</p>
<p id="Upp::AMap::operator~()const" class="AA"><a href="Upp::MapKVRange"><span class="H"><u>MapKVRange</u></span></a><span class="H">&lt;</span><a href="Upp::AMap"><span class="H"><u>AMap</u></span></a><span class="H">&lt;</span>const<span class="H">&nbsp;</span><span class="I">K</span><span class="H">, </span><span class="I">T</span><span class="H">, </span><span class="I">V</span><span class="H">&gt;, </span><span class="I">K</span><span class="H">, </span>const<span class="H">&nbsp;</span><span class="I">T</span><span class="H">&gt;&nbsp;</span><span class="AB">operator~</span><span class="H">()&nbsp;</span>const</p>
<p class="T">Returns a special range object that can be used in C++11 range for to iterate over key/value pairs. Unlinked objects are automatically skipped.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="AMap::operator()(const K&,const T&)" class="S"><a href="AMap"><u>AMap</u></a><span class="U">&amp;</span>&nbsp;<span class="N">operator()</span>(<span class="U">const</span>&nbsp;<span class="I">K</span><span class="U">&amp;</span>&nbsp;<span class="V">k</span>, <span class="U">const</span>&nbsp;<span class="I">T</span><span class="U">&amp;</span>&nbsp;<span class="V">v</span>)</p>
<p class="T">Same as Add(<span class="V">k</span>, <span class="V">v</span>), returns *this. Syntax sugar for creating map.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="AMap::KeyType::typedef" class="J"><span class="K">typedef</span><span class="L">&nbsp;K&nbsp;</span>KeyType</p>
<p class="T">Typedef of K for use in templated algorithms.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="AMap::KeyConstIterator::typedef" class="J"><span class="K">typedef</span><span class="L">&nbsp;</span><span class="K">typename</span><span class="L">&nbsp;Index</span><span class="K">&lt;</span><span class="L">K, HashFn</span><span class="K">&gt;::</span><span class="L">ConstIterator&nbsp;</span>KeyConstIterator</p>
<p class="T">Key iterator type.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="AMap::KeyBegin()const" class="AA"><span class="H">KeyConstIterator&nbsp;</span><span class="AB">KeyBegin</span><span class="H">()&nbsp;</span>const</p>
<p class="T">Returns a constant iterator to the first key in AMap.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="O">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Constant key iterator.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="AMap::KeyEnd()const" class="AA"><span class="H">KeyConstIterator&nbsp;</span><span class="AB">KeyEnd</span><span class="H">()&nbsp;</span>const</p>
<p class="T">Returns a constant iterator to the key just beyond the last key in AMap.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="O">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Constant key iterator.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="AMap::KeyGetIter(int)const" class="AA"><span class="H">KeyConstIterator&nbsp;</span><span class="AB">KeyGetIter</span><span class="H">(</span>int<span class="H">&nbsp;</span><span class="V">pos</span><span class="H">)&nbsp;</span>const</p>
<p class="T">Returns a constant iterator to the key at the specified position. Same as <span class="N">KeyBegin() + i</span>. The benefit of this method is that <span class="N">pos</span> is range checked in debug mode. </p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Z">i</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Required position.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="O">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Constant key iterator.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="AMap::Begin()" class="S">Iterator&nbsp;<span class="N">Begin</span>()</p>
<p class="T">Returns an iterator to the first value in AMap.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="O">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Value iterator.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="AMap::End()" class="S">Iterator&nbsp;<span class="N">End</span>()</p>
<p class="T">Returns a constant iterator to the value just beyond the last key in AMap.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="O">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Value iterator.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="AMap::GetIter(int)" class="S">Iterator&nbsp;<span class="N">GetIter</span>(<span class="U">int</span>&nbsp;<span class="V">pos</span>)</p>
<p class="T">Returns an iterator to the value at the specified position. Same as <span class="N">Begin() + i</span>. The benefit of this method is that <span class="N">pos</span> is range checked in debug mode.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Z">i</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Required position.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="O">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Value iterator.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="AMap::Begin()const" class="AA"><span class="H">ConstIterator&nbsp;</span><span class="AB">Begin</span><span class="H">()&nbsp;</span>const</p>
<p class="T">Returns a constant iterator to the first value in AMap.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="O">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Constant value iterator.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="AMap::End()const" class="AA"><span class="H">ConstIterator&nbsp;</span><span class="AB">End</span><span class="H">()&nbsp;</span>const</p>
<p class="T">Returns a constant iterator to the value just beyond the last value in AMap.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="O">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Constant value iterator.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="AMap::GetIter(int)const" class="AA"><span class="H">ConstIterator&nbsp;</span><span class="AB">GetIter</span><span class="H">(</span>int<span class="H">&nbsp;</span><span class="V">pos</span><span class="H">)&nbsp;</span>const</p>
<p class="T">Returns a constant iterator to the value at the specified position. Same as <span class="N">Begin() + i</span>. Benefit of this methods is that in debug mode <span class="N">pos</span> is range checked.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Z">i</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Required position.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="O">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Constant value iterator.</p></td></tr></table>
<p class="F">&nbsp;</p>
<p class="A">&nbsp;</p>
</TD>
</TR>
</TABLE>
</TD>
</TR>
</TABLE>
<TABLE BORDER="0" WIDTH="100%"><TR><TD></TD>
</TR>
</TABLE>
<TABLE BORDER="0" CELLSPACING="0" CELLPADDING="0" BGCOLOR="#FFFFFF" WIDTH="100%" style="border-style: solid; border-width: 1px; border-color: #6E89AE;padding: 10px;;"><TR><TD><TABLE BORDER="0" CELLSPACING="0" CELLPADDING="0" WIDTH="100%"><TR><TD><p class="A"><span class="B"> </span><a href="www$uppweb$contribweb$en-us.html">Do you want to contribute?</a></p>
</TD>
</TR>
</TABLE>
</TD>
</TR>
</TABLE>
</TD>
</TR>
</TABLE>
<script type="text/javascript">var a={};var p=window.location.pathname.split("/");p=p[p.length-1];var s='<select id="lang" onchange="window.location=document.getElementById(\'lang\').value;">';for(l in a){if(p==l){d=" selected=1"}else{d=""}s+='<option value="'+l+'"'+d+'>'+a[l]+'</option>'}s+='</select>';var d=document.createElement('div');d.innerHTML=s;var c=document.getElementById('langs');c.replaceChild(d,c.firstChild);document.getElementById('langbox').style.display='block';</script></BODY>
