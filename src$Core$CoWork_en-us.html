<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML lang="en-us">
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="Generator" CONTENT="U++ HTML Package">
<TITLE>CoWork :: U++</TITLE>
<STYLE TYPE="text/css"><!--
.A{margin:0px 0px 0px 0px;text-indent:0px;text-align:left;color:#000000;font-family:sans-serif;font-size:10pt;font-weight:normal;font-style:normal;}
.B{font-size:12pt;}
.C{border-collapse:collapse;table-layout:auto;border: 2px solid #000000;}
.D{padding: 3px 5px 3px 5px;border-left: 1px solid #000000;border-top: 1px solid #000000;border-right: 1px solid #000000;border-bottom: 1px solid #000000;background-color:#712A00;vertical-align:middle;}
.E{margin:0px 0px 0px 0px;text-indent:0px;text-align:left;color:#e0e0e0;font-family:sans-serif;font-size:16pt;font-weight:bold;font-style:normal;}
.F{margin:0px 0px 0px 0px;text-indent:0px;text-align:left;color:#000000;font-family:sans-serif;font-size:6pt;font-weight:normal;font-style:normal;}
.G{margin:0px 0px 5px 0px;text-indent:0px;text-align:left;color:#000000;font-family:sans-serif;font-size:12pt;font-weight:bold;font-style:normal;}
.H{color:#0000ff;font-weight:normal;}
.I{font-weight:normal;}
.J{margin:8px 0px 0px 0px;text-indent:0px;text-align:left;color:#000000;font-family:sans-serif;font-size:10pt;font-weight:normal;font-style:normal;}
.K{font-weight:bold;}
.L{font-weight:bold;font-style:italic;}
.M{border-collapse:collapse;table-layout:auto;border: 2px solid #808080;}
.N{padding: 3px 5px 3px 5px;border-left: 1px solid #808080;border-top: 1px solid #808080;border-right: 1px solid #808080;border-bottom: 1px solid #808080;background-color:#C0C0C0;vertical-align:middle;}
.O{margin:0px 0px 0px 0px;text-indent:0px;text-align:left;color:#000000;font-family:sans-serif;font-size:10pt;font-weight:bold;font-style:normal;}
.P{margin:0px 0px 5px 0px;text-indent:0px;text-align:left;color:#000000;font-family:sans-serif;font-size:10pt;font-weight:normal;font-style:normal;}
.Q{color:#0000ff;}
.R{color:#800000;font-weight:bold;}
.S{margin:0px 0px 0px 57px;text-indent:0px;text-align:left;color:#000000;font-family:sans-serif;font-size:10pt;font-weight:normal;font-style:normal;}
.T{margin:0px 0px 5px 0px;text-indent:0px;text-align:left;color:#0000ff;font-family:sans-serif;font-size:10pt;font-weight:normal;font-style:normal;}
.U{color:#000000;}
.V{color:#000000;font-weight:bold;}
.W{margin:0px 0px 0px 57px;text-indent:0px;text-align:left;color:#000000;font-family:sans-serif;font-size:10pt;font-weight:normal;font-style:italic;}
.X{font-style:normal;}
.Y{color:#800000;font-weight:bold;font-style:normal;}
.Z{margin:0px 0px 5px 0px;text-indent:0px;text-align:left;color:#800000;font-family:sans-serif;font-size:12pt;font-weight:bold;font-style:normal;}
.AA{color:#000000;font-weight:normal;}
.AB{color:#008000;font-weight:bold;}
.AC{margin:0px 0px 5px 0px;text-indent:0px;text-align:left;color:#000000;font-family:sans-serif;font-size:12pt;font-weight:normal;font-style:normal;}
.AD{margin:0px 0px 5px 0px;text-indent:0px;text-align:left;color:#000000;font-family:sans-serif;font-size:10pt;font-weight:bold;font-style:normal;}
a.l1         { text-decoration:none; font-size: 8pt; font-family: sans-serif; font-weight: normal; }
a.l1:link    { color:#000000; }
a.l1:visited { color:#000080; }
a.l1:hover   { color:#9933CC; }
a.l1:active  { color:#000000; }
a.l2         { text-decoration:none; font-size: 12pt; font-family: sans-serif; font-variant: small-caps; }
a.l2:link    { color:#0066FF; }
a.l2:visited { color:#FF6600; }
a.l2:hover   { color:#BC0624; }
a.l2:active  { color:#BC0024; }

-->
</STYLE>
<META NAME="keywords" CONTENT="framework, toolkit, widget, c++, visual, studio, dev-cpp, builder, ide, class, component,wxwidgets, qt, rapid, application, development, rad, mfc, linux, macos, gui, sdl, directx, desktop"><META name="robots" content="index,follow">
<LINK rel="alternate" type="application/rss+xml" title="SVN changes" href="svnchanges.xml">
<LINK rel="shortcut icon" type="image/png" href="favicon.png">
</HEAD><BODY BGCOLOR="#D2D9D2" ALINK="#800000" LINK="#000000" VLINK="#000080"><TABLE BORDER="0" CELLSPACING="0" CELLPADDING="0" WIDTH="100%"><TR><TD COLSPAN="3"><TABLE BORDER="0" CELLSPACING="0" CELLPADDING="0" WIDTH="100%" BGCOLOR="#FFFFFF" style="border: 1px solid #6E89AE;padding-left: 10px;padding-right: 0px;padding-top: 0px;padding-bottom: 0px;"><TR><TD><A HREF="index.html"><IMG SRC="0i.png" ALT="" BORDER="0"></A>
</TD>
<TD ALIGN="RIGHT" VALIGN="BOTTOM" STYLE="padding-bottom: 5px; background-image: url('1i.png')"><span style="font-size: 14pt; font-family: sans-serif;"><script type="text/javascript"><!--
google_ad_client = "pub-1082147624384270";
google_ad_width = 468;
google_ad_height = 60;
google_ad_format = "468x60_as";
google_ad_type = "text_image";
google_ad_channel = "";
google_color_border = "336699";
google_color_bg = "FFFFFF";
google_color_link = "0000FF";
google_color_text = "000000";
google_color_url = "008000";
//--></script>
<script type="text/javascript"
  src="https://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
&nbsp;&nbsp;</span>
</TD>
</TR>
</TABLE>
</TD>
</TR>
</TABLE>
<TABLE BORDER="0" CELLSPACING="0" CELLPADDING="0" WIDTH="100%"><TR><TD COLSPAN="3" BGCOLOR="#D2D9D2" HEIGHT="6"></TD>
</TR>
<TR><TD VALIGN="TOP" ALIGN="CENTER"><TABLE BORDER="0" CELLSPACING="0" CELLPADDING="0" WIDTH="160"><TR><TD ALIGN="CENTER"><TABLE BORDER="0" CELLSPACING="0" CELLPADDING="0" WIDTH="100%" BGCOLOR="#FFFFFF" style="border-style: solid; border-width: 1px; border-color: #6E89AE;padding: 0px"><TR><TD WIDTH="100%" VALIGN="MIDDLE" STYLE="background-image: url('2i.png'); border: 0px solid black; padding-left:12px; padding-right:0px; padding-top:6px; padding-bottom:6px;"><A HREF="www$uppweb$overview$en-us.html" CLASS="l1">Overview</A>
</TD>
</TR>
<TR><TD WIDTH="100%" VALIGN="MIDDLE" STYLE="background-image: url('2i.png'); border: 0px solid black; padding-left:12px; padding-right:0px; padding-top:6px; padding-bottom:6px; border-top: 1px solid #6E89AE;"><A HREF="www$uppweb$examples$en-us.html" CLASS="l1">Examples</A>
</TD>
</TR>
<TR><TD WIDTH="100%" VALIGN="MIDDLE" STYLE="background-image: url('2i.png'); border: 0px solid black; padding-left:12px; padding-right:0px; padding-top:6px; padding-bottom:6px; border-top: 1px solid #6E89AE;"><A HREF="www$uppweb$ss$en-us.html" CLASS="l1">Screenshots</A>
</TD>
</TR>
<TR><TD WIDTH="100%" VALIGN="MIDDLE" STYLE="background-image: url('2i.png'); border: 0px solid black; padding-left:12px; padding-right:0px; padding-top:6px; padding-bottom:6px; border-top: 1px solid #6E89AE;"><A HREF="www$uppweb$comparison$en-us.html" CLASS="l1">Comparisons</A>
</TD>
</TR>
<TR><TD WIDTH="100%" VALIGN="MIDDLE" STYLE="background-image: url('2i.png'); border: 0px solid black; padding-left:12px; padding-right:0px; padding-top:6px; padding-bottom:6px; border-top: 1px solid #6E89AE;"><A HREF="www$uppweb$apps$en-us.html" CLASS="l1">Applications</A>
</TD>
</TR>
<TR><TD WIDTH="100%" VALIGN="MIDDLE" STYLE="background-image: url('2i.png'); border: 0px solid black; padding-left:12px; padding-right:0px; padding-top:6px; padding-bottom:6px; border-top: 1px solid #6E89AE;"><A HREF="www$uppweb$download$en-us.html" CLASS="l1">Download</A>
</TD>
</TR>
<TR><TD WIDTH="100%" VALIGN="MIDDLE" STYLE="background-image: url('2i.png'); border: 0px solid black; padding-left:12px; padding-right:0px; padding-top:6px; padding-bottom:6px; border-top: 1px solid #6E89AE;"><A HREF="www$uppweb$documentation$en-us.html" CLASS="l1">Documentation</A>
</TD>
</TR>
<TR><TD WIDTH="100%" VALIGN="MIDDLE" STYLE="background-image: url('2i.png'); border: 0px solid black; padding-left:12px; padding-right:0px; padding-top:6px; padding-bottom:6px; border-top: 1px solid #6E89AE;"><A HREF="www$uppweb$Tutorials$en-us.html" CLASS="l1">Tutorials</A>
</TD>
</TR>
<TR><TD WIDTH="100%" VALIGN="MIDDLE" STYLE="background-image: url('2i.png'); border: 0px solid black; padding-left:12px; padding-right:0px; padding-top:6px; padding-bottom:6px; border-top: 1px solid #6E89AE;"><A HREF="app$ide$UppHub$en-us.html" CLASS="l1">UppHub</A>
</TD>
</TR>
<TR><TD WIDTH="100%" VALIGN="MIDDLE" STYLE="background-image: url('2i.png'); border: 0px solid black; padding-left:12px; padding-right:0px; padding-top:6px; padding-bottom:6px; border-top: 1px solid #6E89AE;"><A HREF="www$uppweb$Roadmap$en-us.html" CLASS="l1">Status & Roadmap</A>
</TD>
</TR>
<TR><TD WIDTH="100%" VALIGN="MIDDLE" STYLE="background-image: url('2i.png'); border: 0px solid black; padding-left:12px; padding-right:0px; padding-top:6px; padding-bottom:6px; border-top: 1px solid #6E89AE;"><A HREF="www$uppweb$FAQ$en-us.html" CLASS="l1">FAQ</A>
</TD>
</TR>
<TR><TD WIDTH="100%" VALIGN="MIDDLE" STYLE="background-image: url('2i.png'); border: 0px solid black; padding-left:12px; padding-right:0px; padding-top:6px; padding-bottom:6px; border-top: 1px solid #6E89AE;"><A HREF="app$ide$About$en-us.html" CLASS="l1">Authors & License</A>
</TD>
</TR>
<TR><TD WIDTH="100%" VALIGN="MIDDLE" STYLE="background-image: url('2i.png'); border: 0px solid black; padding-left:12px; padding-right:0px; padding-top:6px; padding-bottom:6px; border-top: 1px solid #6E89AE;"><A HREF="https://www.ultimatepp.org/forums" CLASS="l1">Forums</A>
</TD>
</TR>
<TR><TD WIDTH="100%" VALIGN="MIDDLE" STYLE="background-image: url('2i.png'); border: 0px solid black; padding-left:12px; padding-right:0px; padding-top:6px; padding-bottom:6px; border-top: 1px solid #6E89AE;"><A HREF="www$uppweb$Funding$en-us.html" CLASS="l1">Funding U++</A>
</TD>
</TR>
</TABLE>
<TABLE BORDER="0" WIDTH="100%"><TR><TD></TD>
</TR>
</TABLE>
<TABLE BORDER="0" CELLSPACING="0" CELLPADDING="0" WIDTH="100%" BGCOLOR="#FFFFFF" style="border-style: solid; border-width: 1px; border-color: #6E89AE;padding: 0px"><TR><TD WIDTH="100%" VALIGN="MIDDLE" STYLE="background-image: url('3i.png'); border: 0px solid black;padding-left:12px; padding-right:0px; padding-top:1px; padding-bottom:1px;color:#FFFFFF;"><B><span style="font-size: 8pt; font-family: sans-serif;">Search on this site</span>
</B>
</TD>
</TR>
<TR><TD WIDTH="100%" VALIGN="MIDDLE" STYLE="background-image: url('2i.png'); border: 0px solid black; padding-left:6px; padding-right:0px; padding-top:4px; padding-bottom:4px;border-top: 1px solid #6E89AE;"><TABLE BORDER="0" CELLSPACING="0" CELLPADDING="0" WIDTH="100%"><TR><TD><IMG SRC="4i.png" ALT="" BORDER="0"></TD>
<TD><FORM ACTION="https://www.google.com/search" METHOD="GET" STYLE="margin:0px;padding:0px;"><INPUT TYPE="HIDDEN" NAME="ie" VALUE="UTF-8"><INPUT TYPE="HIDDEN" NAME="oe" VALUE="UTF-8"><INPUT TYPE="TEXT" NAME="q" SIZE="15" MAXLENGTH="256" placeholder="Site search"><INPUT TYPE="HIDDEN" NAME="sitesearch" VALUE="ultimatepp.org"></FORM>
</TD>
</TR>
</TABLE>
</TD>
</TR>
</TABLE>
<TABLE BORDER="0" WIDTH="100%"><TR><TD></TD>
</TR>
</TABLE>
<br><div id="fb-root"></div>
<script type="text/javascript">(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) {return;}
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/en_US/all.js#xfbml=1";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>

<div class="fb-like" data-href="https://www.facebook.com/pages/Upp-Framework/262346610476027?sk=wall" data-send="false" data-layout="button_count" data-width="160" data-show-faces="false" data-font="arial"></div>
<br><br><script type="text/javascript"><!--
google_ad_client = "pub-1082147624384270";
google_ad_width = 160;
google_ad_height = 600;
google_ad_format = "160x600_as";
google_ad_type = "text_image";
google_ad_channel = "";
google_color_border = "336699";
google_color_bg = "FFFFFF";
google_color_link = "0000FF";
google_color_text = "000000";
google_color_url = "008000";
//--></script>
<script type="text/javascript"
  src="https://pagead2.googlesyndication.com/pagead/show_ads.js">
</script><br><br><script type="text/javascript"><!--
google_ad_client = "pub-1082147624384270";
google_ad_width = 160;
google_ad_height = 90;
google_ad_format = "160x90_0ads_al_s";
google_ad_channel = "";
google_color_border = "336699";
google_color_bg = "FFFFFF";
google_color_link = "0000FF";
google_color_text = "000000";
google_color_url = "008000";
//--></script>
<script type="text/javascript"
  src="https://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
<br><br><br><br><br><br><A HREF="https://sourceforge.net/projects/upp/"><IMG SRC="https://sourceforge.net/sflogo.php?group_id=93970&amp;type=2" ALT="SourceForge.net Logo" BORDER="0" WIDTH="125" HEIGHT="37"></A>
<br><br><A HREF="https://flathub.org/en/apps/org.ultimatepp.TheIDE"><IMG SRC="5i.png" ALT="SourceForge.net Logo" BORDER="0" WIDTH="125" HEIGHT="37"></A>
<br><br><div style="background-color:#ffffff;width:125;height:35"><A HREF="https://github.com/ultimatepp"><IMG SRC="6i.png" ALT="GitHub Logo" BORDER="0" WIDTH="125" HEIGHT="35"></A>
</div><br><div style="background-color:#ffffff;width:125;height:35"><div style="height:5"></div><A HREF="https://discord.gg/8XzqQzXZzb"><IMG SRC="https://assets-global.website-files.com/6257adef93867e50d84d30e2/636e0b5061df29d55a92d945_full_logo_blurple_RGB.svg" ALT="Discord Logo" BORDER="0" WIDTH="125" HEIGHT="25"></A>
</div><br></TD>
</TR>
</TABLE>
</TD>
<TD VALIGN="TOP" BGCOLOR="#D2D9D2"><TABLE BORDER="0" CELLSPACING="0" CELLPADDING="0" WIDTH="6"><TR><TD></TD>
</TR>
</TABLE>
</TD>
<TD VALIGN="TOP" WIDTH="100%" BGCOLOR="#D2D9D2"><TABLE BORDER="0" CELLSPACING="0" CELLPADDING="0" BGCOLOR="#FFFFFF" WIDTH="100%" style="border-style: solid; border-width: 1px; border-color: #6E89AE;padding: 10px;;"><TR><TD><TABLE BORDER="0" CELLSPACING="0" CELLPADDING="0" WIDTH="100%"><TR><TD><p class="A">&nbsp;</p>
<table width="100%" border="0" cellpadding="0" cellspacing="0"><tr><td width="100%"><table width="100%" class="C"><colgroup><col width="100%"></colgroup>
<tr><td class="D"><p class="E">CoWork</p>
</td>
</tr>
</table></td>
</tr></table>
<p class="F">&nbsp;</p>
<p id="CoWork::class" class="G"><span class="H">class</span><span class="I">&nbsp;</span>CoWork</p>
<p class="J">This class is indented as general parallelization tool. Whenever jobs (e.g. loop iterations) are independent (they do not share any data between iterations), CoWork can be used to relatively easily spawn loop iterations over threads and thus over CPU cores. Note that previous statement does <span class="K">not</span> preclude CoWork iterations to share data at all - sharing data using Mutex or similar serialization mechanisms still works. CoWork works with fixed-size thread pool, which is created during initialization phase (which first CoWork constructor is called). No more thread are created or destroyed during normal work. Nesting of CoWork instances is also possible. Thread pool is normally terminated when the main thread finishes.</p>
<p class="J">No synchronization is required to access CoWork instances from various threads (CoWork is internally synchronized).</p>
<p class="J">If an exception is thrown in worker thread, which is not handled by worker thread, it is caught and rethrown in CoWork thread in Finish routine. Any such exception also causes the Cancel of the CoWork. For this reason, CoWork destructor <span class="L">CAN</span> throw exceptions and CoWork should be usually used as automatick (stack) variable. If you need CoWork that does not throw exceptions in destructor, use CoWorkNX.</p>
<p class="J"><span class="L">Implementation notes: </span>Current implementation has single global FIFO stack for 2048 scheduled jobs. When there is no slot available when scheduling the job, it is performed immediately by Do. Finish method has to wait until all jobs scheduled by CoWork instance are finished, while waiting it attempts to perform scheduled jobs from the same instance. That way work always progresses even if there is shortage of worker threads.</p>
<p class="A">&nbsp;</p>
<table width="100%" border="0" cellpadding="0" cellspacing="0"><tr><td width="100%"><table width="100%" class="M"><colgroup><col width="100%"></colgroup>
<tr><td class="N"><p class="O">Public Method List</p>
</td>
</tr>
</table></td>
</tr></table>
<p class="F">&nbsp;</p>
<p id="Upp::CoWork::TrySchedule(Function&&)" class="P"><span class="Q">static bool</span>&nbsp;<span class="K">TrySchedule</span>(<a href="Upp::Function"><u>Function</u></a>&lt;<span class="Q">void</span>&nbsp;()&gt;&amp;&amp;&nbsp;<span class="R">fn</span>)</p>
<p id="Upp::CoWork::TrySchedule(const Function&)" class="P"><span class="Q">static</span> <span class="Q">bool</span>&nbsp;<span class="K">TrySchedule</span>(<span class="Q">const</span>&nbsp;<a href="Upp::Function"><u>Function</u></a>&lt;<span class="Q">void</span>&nbsp;()&gt;&amp;&nbsp;<span class="R">fn</span>)</p>
<p class="S">This is a low-level function that attempts to schedule <span class="R">fn</span> to be executed by worker thread. Returns true if <span class="R">fn</span> was scheduled, false if not (in case there is no slot left in scheduling stacks). Note that this function only schedules the function, the exact time of execution is unknown.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Upp::CoWork::Schedule(Function&&)" class="P"><span class="Q">static void</span>&nbsp;<span class="K">Schedule</span>(<a href="Upp::Function"><u>Function</u></a>&lt;<span class="Q">void</span>&nbsp;()&gt;&amp;&amp;&nbsp;<span class="R">fn</span>)</p>
<p id="Upp::CoWork::Schedule(const Function&)" class="P"><span class="Q">static</span> <span class="Q">void</span>&nbsp;<span class="K">Schedule</span>(<span class="Q">const</span>&nbsp;<a href="Upp::Function"><u>Function</u></a>&lt;<span class="Q">void</span>&nbsp;()&gt;&amp;&nbsp;<span class="R">fn</span>)</p>
<p class="S">Similar to TrySchedule, but always schedules <span class="R">fn</span> - even if it has to wait for slot to become available.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Upp::CoWork::Do(Function&&)" class="P"><span class="Q">void</span>&nbsp;<span class="K">Do</span>(<a href="Upp::Function"><u>Function</u></a>&lt;<span class="Q">void</span>&nbsp;()&gt;&amp;&amp;&nbsp;<span class="R">fn</span>)</p>
<p id="Upp::CoWork::Do(const Function&)" class="P"><span class="Q">void</span>&nbsp;<span class="K">Do</span>(<span class="Q">const</span>&nbsp;<a href="Upp::Function"><u>Function</u></a>&lt;<span class="Q">void</span>&nbsp;()&gt;&amp;&nbsp;<span class="R">fn</span>)</p>
<p id="Upp::CoWork::operator&(const Function&)" class="P"><a href="Upp::CoWork"><u>CoWork</u></a><span class="Q">&amp;</span>&nbsp;<span class="K">operator&amp;</span>(<span class="Q">const</span>&nbsp;<a href="Upp::Function"><u>Function</u></a>&lt;<span class="Q">void</span>&nbsp;()&gt;&amp;&nbsp;<span class="R">fn</span>)</p>
<p id="Upp::CoWork::operator&(Function&&)" class="P"><a href="Upp::CoWork"><u>CoWork</u></a><span class="Q">&amp;</span>&nbsp;<span class="K">operator&amp;</span>(<a href="Upp::Function"><u>Function</u></a>&lt;<span class="Q">void</span>&nbsp;()&gt;&amp;&amp;&nbsp;<span class="R">fn</span>)</p>
<p class="S">Schedules <span class="R">fn</span> to be executed. All changes to data done before Do are visible in the scheduled code. The order of execution or whether the code is execute in another or calling thread is not specified. In certain situations (no scheduling slot available), Do can perform scheduled job immediately in calling thread.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Upp::CoWork::GetScheduledCount()const" class="T">int<span class="U"> </span><span class="V">GetScheduledCount</span><span class="U">() </span>const</p>
<p class="S">Returns a number of remaining unfinished jobs scheduled by Do in this CoWork.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Upp::CoWork::FinLock()" class="P"><span class="Q">static</span> <span class="Q">void</span>&nbsp;<span class="K">FinLock</span>()</p>
<p class="S">This functions is to be called in scheduled routine. Its purpose is to serialize access to shared data at the end of the routine. The rationale is that CoWork has to lock some mutex anyway after scheduled code finishes, so FinLock can lock this mutex a bit earlier, joining two mutex locks into single one. Of course, as with all locks, execution of locked code should be short as not to cause congestion of CoWork scheduling.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Upp::CoWork::Cancel()" class="P"><span class="Q">void</span>&nbsp;<span class="K">Cancel</span>()</p>
<p class="S">Removes all jobs scheduled by this thread that has not started yet from the queue and then waits for any jobs already started to finish. Rethrows the exception thrown in worker threads. If more than single worker thread throws the exception, the first exception thrown in absolute time is rethrown.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Upp::CoWork::IsCanceled()" class="P"><span class="Q">static</span> <span class="Q">bool</span>&nbsp;<span class="K">IsCanceled</span>()</p>
<p class="S">This methods returns true in worker thread when the worker thread is a part of some CoWork instance and that instance was canceled.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="CoWork::Finish()" class="P"><span class="Q">void</span>&nbsp;<span class="K">Finish</span>()</p>
<p class="S">Waits until all jobs scheduled using Do (or operator&amp;) are finished. All changes to data performed by scheduled threads are visible after Finish. While waiting, Finish can perform scheduled jobs. Can </p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Upp::CoWork::IsFinished()" class="P"><span class="Q">bool</span>&nbsp;<span class="K">IsFinished</span>()</p>
<p class="S">Checkes whether all jobs scheduled using Do (or operator&amp;) are finished. All changes to data performed by scheduled threads are visible after IsFinished returns true (so this is basically non-blocking variant of Finish).</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Upp::CoWork::Reset()" class="P"><span class="Q">void</span>&nbsp;<span class="K">Reset</span>()</p>
<p class="S">Calls Cancel, catches and ignores all exceptions eventually thrown by worker threads. Then resets CoWork to the initial state as if it was just constructed. Useful when using CoWork as nonlocal variable.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="CoWork::~CoWork()" class="P"><span class="Q">~</span><span class="K">CoWork</span>()</p>
<p class="S">Calls Finish(). Can eventually rethrow worker thread exception. If there is a chance of destructor being involved in stack unwinding, Finish should be called separately before destructor.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Upp::CoWork::IsWorker()" class="P"><span class="Q">static</span> <span class="Q">bool</span>&nbsp;<span class="K">IsWorker</span>()</p>
<p class="S">Returns true if current thread is CoWork worker thread.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Upp::CoWork::GetWorkerIndex()" class="P"><span class="Q">static</span> <span class="Q">int</span>&nbsp;<span class="K">GetWorkerIndex</span>()</p>
<p class="S">Returns the index of current worker thread - index is &gt;= 0 and &lt; GetPoolSize(). This is useful if there is a need for per-thread resources. -1 means that thread is not worker.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Upp::CoWork::GetPoolSize()" class="P"><span class="Q">static</span> <span class="Q">int</span>&nbsp;<span class="K">GetPoolSize</span>()</p>
<p class="S">Returns the current count of worker threads.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Upp::CoWork::SetPoolSize(int)" class="P"><span class="Q">static void</span>&nbsp;<span class="K">SetPoolSize</span>(<span class="Q">int</span>&nbsp;<span class="R">n</span>)</p>
<p class="S">Adjusts the thread pool size (default pool size is CPU_Cores() + 2).</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Upp::CoWork::Loop(Function&&)" class="P"><span class="Q">void</span>&nbsp;<span class="K">Loop</span>(<a href="Upp::Function"><u>Function</u></a>&lt;<span class="Q">void</span>&nbsp;()&gt;&amp;&amp;&nbsp;<span class="R">fn</span>)</p>
<p id="Upp::CoWork::Loop(const Function&)" class="P"><span class="Q">void</span>&nbsp;<span class="K">Loop</span>(<span class="Q">const</span>&nbsp;<a href="Upp::Function"><u>Function</u></a>&lt;<span class="Q">void</span>&nbsp;()&gt;&amp;&nbsp;<span class="R">fn</span>)</p>
<p id="Upp::CoWork::operator*(const Function&)" class="P"><a href="Upp::CoWork"><u>CoWork</u></a><span class="Q">&amp;</span>&nbsp;<span class="K">operator*</span>(<span class="Q">const</span>&nbsp;<a href="Upp::Function"><u>Function</u></a>&lt;<span class="Q">void</span>&nbsp;()&gt;&amp;&nbsp;<span class="R">fn</span>)</p>
<p id="Upp::CoWork::operator*(Function&&)" class="P"><a href="Upp::CoWork"><u>CoWork</u></a><span class="Q">&amp;</span>&nbsp;<span class="K">operator*</span>(<a href="Upp::Function"><u>Function</u></a>&lt;<span class="Q">void</span>&nbsp;()&gt;&amp;&amp;&nbsp;<span class="R">fn</span>)</p>
<p class="W"><span class="X">Schedules </span><span class="Y">fn</span><span class="X"> to be run on all worker threads and on calling thread. After the first thread returns from </span><span class="Y">fn</span><span class="X">, all other scheduled </span><span class="Y">fn</span><span class="X"> jobs that has not started yet are unscheduled. Waits for all started jobs to finish. The function also sets internal index counter to zero in CoWork before starting any worker thread. Worker thread should acquire job quantum in internal loop - internal CoWork index can be used for this purpose. </span>Deprecated - use CoDo instead.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Upp::CoWork::Next()" class="P"><span class="Q">int</span>&nbsp;<span class="K">Next</span>()</p>
<p class="W"><span class="X">Atomically increments internal index counter and returns its previous value (thus the first value returned is 0). Supposed to be used with Loop. </span>Deprecated - use std::atomic&lt;int&gt; variable with CoDo instead.</p>
<p class="A">&nbsp;</p>
<table width="100%" border="0" cellpadding="0" cellspacing="0"><tr><td width="100%"><table width="100%" class="C"><colgroup><col width="100%"></colgroup>
<tr><td class="D"><p class="E">CoWorkNX</p>
</td>
</tr>
</table></td>
</tr></table>
<p class="A">&nbsp;</p>
<p id="Upp::CoWorkNX::struct" class="Z"><span class="H">struct</span><span class="AA">&nbsp;</span><span class="U">CoWorkNX</span><span class="AA">&nbsp;:&nbsp;</span><span class="H">public</span><span class="AA">&nbsp;</span>CoWork</p>
<p class="S">This simple helper class just removes &quot;noexcept(false)&quot; from CoWork destructor, removing exception throws from the destructor and allowing it to be used as member variable. Obviously, if exception handling is required, you need to use Finish (not to depend on destructor to call it).</p>
<p class="F">&nbsp;</p>
<table width="100%" border="0" cellpadding="0" cellspacing="0"><tr><td width="100%"><table width="100%" class="C"><colgroup><col width="100%"></colgroup>
<tr><td class="D"><p class="E">Loop parallelisation functions</p>
</td>
</tr>
</table></td>
</tr></table>
<p class="F">&nbsp;</p>
<p id="Upp::CoDo(Function&&)" class="P"><span class="Q">void</span>&nbsp;<span class="K">CoDo</span>(<a href="Upp::Function"><u>Function</u></a>&lt;<span class="Q">void</span>&nbsp;()&gt;&amp;&amp;&nbsp;<span class="R">fn</span>)</p>
<p class="S">Schedules <span class="R">fn</span> to be run on all worker threads and on calling thread. After the first thread returns from <span class="R">fn</span>, all other scheduled <span class="R">fn</span> jobs that has not started yet are unscheduled. Waits for all started jobs to finish. Worker thread should acquire job quantum in internal loop - usually std::atomic is used for this purpose. This is the most effective and flexible way to parallelise iteration.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Upp::CoDo_ST(Function&&)" class="P"><span class="Q">void</span>&nbsp;<span class="K">CoDo_ST</span>(<a href="Upp::Function"><u>Function</u></a>&lt;<span class="Q">void</span>&nbsp;()&gt;&amp;&amp;&nbsp;<span class="R">fn</span>)</p>
<p class="S">This function simply calls <span class="R">fn</span>. It is diagnostics tool - it allows to change CoDo parallel iteration into serial one by adding &quot;_ST&quot; text.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Upp::CoDo(bool,Function&&)" class="P"><span class="Q">void</span>&nbsp;<span class="K">CoDo</span>(<span class="Q">bool</span>&nbsp;<span class="R">co</span>, <a href="Upp::Function"><u>Function</u></a>&lt;<span class="Q">void</span>&nbsp;()&gt;&amp;&amp;&nbsp;<span class="R">fn</span>)</p>
<p class="S">If <span class="R">co</span> is true, calls CoDo(<span class="R">fn</span>), otherwise CoDo_ST(<span class="R">fn</span>). This allows to parametrize algorithms with respect to parallelization.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Upp::CoFor(int,Fn)" class="P"><span class="Q">template</span>&nbsp;&lt;<span class="Q">typename</span>&nbsp;<span class="AB">Fn</span>&gt;&nbsp;<span class="Q">void</span>&nbsp;<span class="K">CoFor</span>(<span class="Q">int</span>&nbsp;<span class="R">n</span>, <span class="AB">Fn</span>&nbsp;<span class="R">iterator</span>)</p>
<p class="S">Based on CoDo, runs in parallel <span class="R">iterator</span> for values 0..<span class="R">n</span> passing the value as argument.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Upp::CoFor_ST(int,Fn)" class="P"><span class="Q">template</span>&nbsp;&lt;<span class="Q">typename</span>&nbsp;<span class="AB">Fn</span>&gt;&nbsp;<span class="Q">void</span>&nbsp;<span class="K">CoFor_ST</span>(<span class="Q">int</span>&nbsp;<span class="R">n</span>, <span class="AB">Fn</span>&nbsp;<span class="R">iterator</span>)</p>
<p class="S">Single threaded variant of CoFor, for diagnostics purposes.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Upp::CoFor(bool,int,Fn)" class="P"><span class="Q">template</span>&nbsp;&lt;<span class="Q">typename</span>&nbsp;<span class="AB">Fn</span>&gt;&nbsp;<span class="Q">void</span>&nbsp;<span class="K">CoFor</span>(<span class="Q">bool</span>&nbsp;<span class="R">co</span>, <span class="Q">int</span>&nbsp;<span class="R">n</span>, <span class="AB">Fn</span>&nbsp;<span class="R">iterator</span>)</p>
<p class="S">Calls CoFor(<span class="R">n</span>, <span class="R">iterator</span>) if <span class="R">co</span> is true, CoFor_ST(<span class="R">n</span>, <span class="R">iterator</span>) otherwise. This allows to parametrize algorithms with respect to parallelization.</p>
<p class="F">&nbsp;</p>
<table width="100%" border="0" cellpadding="0" cellspacing="0"><tr><td width="100%"><table width="100%" class="C"><colgroup><col width="100%"></colgroup>
<tr><td class="D"><p class="E">CoWorkerResources</p>
</td>
</tr>
</table></td>
</tr></table>
<p class="F">&nbsp;</p>
<p id="noref" class="AC"><span class="Q">template</span>&nbsp;&lt;<span class="Q">class</span>&nbsp;<span class="AB">T</span>&gt;</p>
<p id="Upp::CoWorkerResources::class" class="AD"><span class="H">class</span><span class="I">&nbsp;</span>CoWorkerResources</p>
<p class="S">This is a simple helper class that provides per-worker resources. For example, certain calculation requires the instance of computation model that is not immutable, but can be reused over iterations. In single-threaded code, a single instance of such model would be used over the whole loop, however in multi-threaded code, each worker thread, plus thread that created CoWork need its own instance. CoWorkerResources helps to manage such situation.</p>
<p class="A">&nbsp;</p>
<p class="S">NOTE: The problem that this helper class solves is in majority cases better solved by using CoDo function.</p>
<p class="A">&nbsp;</p>
<p class="F">&nbsp;</p>
<table width="100%" border="0" cellpadding="0" cellspacing="0"><tr><td width="100%"><table width="100%" class="M"><colgroup><col width="100%"></colgroup>
<tr><td class="N"><p class="O">Public Method List</p>
</td>
</tr>
</table></td>
</tr></table>
<p class="F">&nbsp;</p>
<p id="Upp::CoWorkerResources::CoWorkerResources()" class="P"><span class="K">CoWorkerResources</span>()</p>
<p class="S">Creates a required number of instances so that each sub-job of CoWork has its unique instance.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Upp::CoWorkerResources::CoWorkerResources(Upp::Event<T&>)" class="P"><span class="K">CoWorkerResources</span>(<a href="Upp::Event"><u>Event</u></a>&lt;<span class="AB">T</span><span class="Q">&amp;</span>&gt;&nbsp;<span class="R">initializer</span>)</p>
<p class="S">Creates a required number of instances so that each sub-job of CoWork has its unique instance.and initializes them using <span class="R">initializer</span>.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Upp::CoWorkerResources::GetCount()const" class="T">int<span class="U">&nbsp;</span><span class="V">GetCount</span><span class="U">()&nbsp;</span>const</p>
<p class="S">Returns the number of instances. Note that this is equal to CoWork::GetPoolSize() if thread that created CoWorkerResources is itself CoWork worker, or CoWork::GetPoolSize() + 1 if it is any other thread. The reason for this is that CoWork owner can execute CoWork jobs too (while waiting in Finish).</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Upp::CoWorkerResources::operator[](int)" class="P"><span class="AB">T</span><span class="Q">&amp;</span>&nbsp;<span class="K">operator[]</span>(<span class="Q">int</span>&nbsp;<span class="R">i</span>)</p>
<p class="S">Returns instance <span class="R">i</span>. Together with GetCount can be used to initialize resources (alternative method to using constructor with <span class="R">initializer</span>.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Upp::CoWorkerResources::Get()" class="P"><span class="AB">T</span><span class="Q">&amp;</span>&nbsp;<span class="K">Get</span>()</p>
<p id="Upp::CoWorkerResources::operator~()" class="P"><span class="AB">T</span><span class="Q">&amp;</span>&nbsp;<span class="K">operator~</span>()</p>
<p class="S">Supposed to be called in CoWork job, returns a reference to resources unique for the thread.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Upp::CoWorkerResources::begin()" class="P"><span class="AB">T</span>&nbsp;*<span class="K">begin</span>()</p>
<p id="Upp::CoWorkerResources::end()" class="P"><span class="AB">T</span>&nbsp;*<span class="K">end</span>()</p>
<p class="S">Standard iterator access.</p>
<p class="F">&nbsp;</p>
<p class="A">&nbsp;</p>
</TD>
</TR>
</TABLE>
</TD>
</TR>
</TABLE>
<TABLE BORDER="0" WIDTH="100%"><TR><TD></TD>
</TR>
</TABLE>
<TABLE BORDER="0" CELLSPACING="0" CELLPADDING="0" BGCOLOR="#FFFFFF" WIDTH="100%" style="border-style: solid; border-width: 1px; border-color: #6E89AE;padding: 10px;;"><TR><TD><TABLE BORDER="0" CELLSPACING="0" CELLPADDING="0" WIDTH="100%"><TR><TD><p class="A"><span class="B"> </span><a href="www$uppweb$contribweb$en-us.html">Do you want to contribute?</a></p>
</TD>
</TR>
</TABLE>
</TD>
</TR>
</TABLE>
</TD>
</TR>
</TABLE>
<script type="text/javascript">var a={};var p=window.location.pathname.split("/");p=p[p.length-1];var s='<select id="lang" onchange="window.location=document.getElementById(\'lang\').value;">';for(l in a){if(p==l){d=" selected=1"}else{d=""}s+='<option value="'+l+'"'+d+'>'+a[l]+'</option>'}s+='</select>';var d=document.createElement('div');d.innerHTML=s;var c=document.getElementById('langs');c.replaceChild(d,c.firstChild);document.getElementById('langbox').style.display='block';</script></BODY>
