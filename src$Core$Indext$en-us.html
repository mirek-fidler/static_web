<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML lang="en-us">
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="Generator" CONTENT="U++ HTML Package">
<TITLE>Index :: U++</TITLE>
<STYLE TYPE="text/css"><!--
.A{margin:0px 0px 0px 0px;text-indent:0px;text-align:left;color:#000000;font-family:sans-serif;font-size:10pt;font-weight:normal;font-style:normal;}
.B{font-size:12pt;}
.C{border-collapse:collapse;table-layout:auto;border: 2px solid #000000;}
.D{padding: 3px 5px 3px 5px;border-left: 1px solid #000000;border-top: 1px solid #000000;border-right: 1px solid #000000;border-bottom: 1px solid #000000;background-color:#712A00;vertical-align:middle;}
.E{margin:0px 0px 0px 0px;text-indent:0px;text-align:left;color:#e0e0e0;font-family:sans-serif;font-size:16pt;font-weight:bold;font-style:normal;}
.F{margin:0px 0px 0px 0px;text-indent:0px;text-align:left;color:#000000;font-family:sans-serif;font-size:6pt;font-weight:normal;font-style:normal;}
.G{margin:0px 0px 5px 0px;text-indent:0px;text-align:left;color:#000000;font-family:sans-serif;font-size:12pt;font-weight:normal;font-style:normal;}
.H{color:#0000ff;}
.I{color:#008000;font-weight:bold;}
.J{margin:0px 0px 5px 0px;text-indent:0px;text-align:left;color:#000000;font-family:sans-serif;font-size:10pt;font-weight:bold;font-style:normal;}
.K{color:#0000ff;font-weight:normal;}
.L{font-weight:normal;}
.M{font-style:italic;}
.N{font-weight:bold;font-style:italic;}
.O{margin:8px 0px 0px 0px;text-indent:0px;text-align:left;color:#000000;font-family:sans-serif;font-size:10pt;font-weight:normal;font-style:normal;}
.P{font-weight:bold;}
.Q{border-collapse:collapse;table-layout:auto;border: 2px solid #808080;}
.R{padding: 3px 5px 3px 5px;border-left: 1px solid #808080;border-top: 1px solid #808080;border-right: 1px solid #808080;border-bottom: 1px solid #808080;background-color:#C0C0C0;vertical-align:middle;}
.S{margin:0px 0px 0px 0px;text-indent:0px;text-align:left;color:#000000;font-family:sans-serif;font-size:10pt;font-weight:bold;font-style:normal;}
.T{margin:0px 0px 5px 0px;text-indent:0px;text-align:left;color:#000000;font-family:sans-serif;font-size:10pt;font-weight:normal;font-style:normal;}
.U{margin:0px 0px 0px 57px;text-indent:0px;text-align:left;color:#000000;font-family:sans-serif;font-size:10pt;font-weight:normal;font-style:normal;}
.V{color:#800000;font-weight:bold;}
.W{color:#008080;}
.X{color:#800000;font-family:monospace;font-weight:bold;}
.Y{margin:0px 0px 0px 57px;text-indent:0px;text-align:left;color:#000080;font-family:sans-serif;font-size:8pt;font-weight:bold;font-style:normal;}
.Z{color:#800000;}
.AA{margin:0px 0px 5px 0px;text-indent:0px;text-align:left;color:#0000ff;font-family:sans-serif;font-size:10pt;font-weight:normal;font-style:normal;}
.AB{color:#000000;}
.AC{color:#000000;font-weight:bold;}
a.l1         { text-decoration:none; font-size: 8pt; font-family: sans-serif; font-weight: normal; }
a.l1:link    { color:#000000; }
a.l1:visited { color:#000080; }
a.l1:hover   { color:#9933CC; }
a.l1:active  { color:#000000; }
a.l2         { text-decoration:none; font-size: 12pt; font-family: sans-serif; font-variant: small-caps; }
a.l2:link    { color:#0066FF; }
a.l2:visited { color:#FF6600; }
a.l2:hover   { color:#BC0624; }
a.l2:active  { color:#BC0024; }

-->
</STYLE>
<META NAME="keywords" CONTENT="framework, toolkit, widget, c++, visual, studio, dev-cpp, builder, ide, class, component,wxwidgets, qt, rapid, application, development, rad, mfc, linux, macos, gui, sdl, directx, desktop"><META name="robots" content="index,follow">
<LINK rel="alternate" type="application/rss+xml" title="SVN changes" href="svnchanges.xml">
<LINK rel="shortcut icon" type="image/png" href="favicon.png">
</HEAD><BODY BGCOLOR="#D2D9D2" ALINK="#800000" LINK="#000000" VLINK="#000080"><TABLE BORDER="0" CELLSPACING="0" CELLPADDING="0" WIDTH="100%"><TR><TD COLSPAN="3"><TABLE BORDER="0" CELLSPACING="0" CELLPADDING="0" WIDTH="100%" BGCOLOR="#FFFFFF" style="border: 1px solid #6E89AE;padding-left: 10px;padding-right: 0px;padding-top: 0px;padding-bottom: 0px;"><TR><TD><A HREF="index.html"><IMG SRC="0i.png" ALT="" BORDER="0"></A>
</TD>
<TD ALIGN="RIGHT" VALIGN="BOTTOM" STYLE="padding-bottom: 5px; background-image: url('1i.png')"><span style="font-size: 14pt; font-family: sans-serif;"><script type="text/javascript"><!--
google_ad_client = "pub-1082147624384270";
google_ad_width = 468;
google_ad_height = 60;
google_ad_format = "468x60_as";
google_ad_type = "text_image";
google_ad_channel = "";
google_color_border = "336699";
google_color_bg = "FFFFFF";
google_color_link = "0000FF";
google_color_text = "000000";
google_color_url = "008000";
//--></script>
<script type="text/javascript"
  src="https://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
&nbsp;&nbsp;</span>
</TD>
</TR>
</TABLE>
</TD>
</TR>
</TABLE>
<TABLE BORDER="0" CELLSPACING="0" CELLPADDING="0" WIDTH="100%"><TR><TD COLSPAN="3" BGCOLOR="#D2D9D2" HEIGHT="6"></TD>
</TR>
<TR><TD VALIGN="TOP" ALIGN="CENTER"><TABLE BORDER="0" CELLSPACING="0" CELLPADDING="0" WIDTH="160"><TR><TD ALIGN="CENTER"><TABLE BORDER="0" CELLSPACING="0" CELLPADDING="0" WIDTH="100%" BGCOLOR="#FFFFFF" style="border-style: solid; border-width: 1px; border-color: #6E89AE;padding: 0px"><TR><TD WIDTH="100%" VALIGN="MIDDLE" STYLE="background-image: url('2i.png'); border: 0px solid black; padding-left:12px; padding-right:0px; padding-top:6px; padding-bottom:6px;"><A HREF="www$uppweb$overview$en-us.html" CLASS="l1">Overview</A>
</TD>
</TR>
<TR><TD WIDTH="100%" VALIGN="MIDDLE" STYLE="background-image: url('2i.png'); border: 0px solid black; padding-left:12px; padding-right:0px; padding-top:6px; padding-bottom:6px; border-top: 1px solid #6E89AE;"><A HREF="www$uppweb$examples$en-us.html" CLASS="l1">Examples</A>
</TD>
</TR>
<TR><TD WIDTH="100%" VALIGN="MIDDLE" STYLE="background-image: url('2i.png'); border: 0px solid black; padding-left:12px; padding-right:0px; padding-top:6px; padding-bottom:6px; border-top: 1px solid #6E89AE;"><A HREF="www$uppweb$ss$en-us.html" CLASS="l1">Screenshots</A>
</TD>
</TR>
<TR><TD WIDTH="100%" VALIGN="MIDDLE" STYLE="background-image: url('2i.png'); border: 0px solid black; padding-left:12px; padding-right:0px; padding-top:6px; padding-bottom:6px; border-top: 1px solid #6E89AE;"><A HREF="www$uppweb$comparison$en-us.html" CLASS="l1">Comparisons</A>
</TD>
</TR>
<TR><TD WIDTH="100%" VALIGN="MIDDLE" STYLE="background-image: url('2i.png'); border: 0px solid black; padding-left:12px; padding-right:0px; padding-top:6px; padding-bottom:6px; border-top: 1px solid #6E89AE;"><A HREF="www$uppweb$apps$en-us.html" CLASS="l1">Applications</A>
</TD>
</TR>
<TR><TD WIDTH="100%" VALIGN="MIDDLE" STYLE="background-image: url('2i.png'); border: 0px solid black; padding-left:12px; padding-right:0px; padding-top:6px; padding-bottom:6px; border-top: 1px solid #6E89AE;"><A HREF="www$uppweb$download$en-us.html" CLASS="l1">Download</A>
</TD>
</TR>
<TR><TD WIDTH="100%" VALIGN="MIDDLE" STYLE="background-image: url('2i.png'); border: 0px solid black; padding-left:12px; padding-right:0px; padding-top:6px; padding-bottom:6px; border-top: 1px solid #6E89AE;"><A HREF="www$uppweb$documentation$en-us.html" CLASS="l1">Documentation</A>
</TD>
</TR>
<TR><TD WIDTH="100%" VALIGN="MIDDLE" STYLE="background-image: url('2i.png'); border: 0px solid black; padding-left:12px; padding-right:0px; padding-top:6px; padding-bottom:6px; border-top: 1px solid #6E89AE;"><A HREF="www$uppweb$Tutorials$en-us.html" CLASS="l1">Tutorials</A>
</TD>
</TR>
<TR><TD WIDTH="100%" VALIGN="MIDDLE" STYLE="background-image: url('2i.png'); border: 0px solid black; padding-left:12px; padding-right:0px; padding-top:6px; padding-bottom:6px; border-top: 1px solid #6E89AE;"><A HREF="app$ide$UppHub$en-us.html" CLASS="l1">UppHub</A>
</TD>
</TR>
<TR><TD WIDTH="100%" VALIGN="MIDDLE" STYLE="background-image: url('2i.png'); border: 0px solid black; padding-left:12px; padding-right:0px; padding-top:6px; padding-bottom:6px; border-top: 1px solid #6E89AE;"><A HREF="www$uppweb$Roadmap$en-us.html" CLASS="l1">Status & Roadmap</A>
</TD>
</TR>
<TR><TD WIDTH="100%" VALIGN="MIDDLE" STYLE="background-image: url('2i.png'); border: 0px solid black; padding-left:12px; padding-right:0px; padding-top:6px; padding-bottom:6px; border-top: 1px solid #6E89AE;"><A HREF="www$uppweb$FAQ$en-us.html" CLASS="l1">FAQ</A>
</TD>
</TR>
<TR><TD WIDTH="100%" VALIGN="MIDDLE" STYLE="background-image: url('2i.png'); border: 0px solid black; padding-left:12px; padding-right:0px; padding-top:6px; padding-bottom:6px; border-top: 1px solid #6E89AE;"><A HREF="app$ide$About$en-us.html" CLASS="l1">Authors & License</A>
</TD>
</TR>
<TR><TD WIDTH="100%" VALIGN="MIDDLE" STYLE="background-image: url('2i.png'); border: 0px solid black; padding-left:12px; padding-right:0px; padding-top:6px; padding-bottom:6px; border-top: 1px solid #6E89AE;"><A HREF="https://www.ultimatepp.org/forums" CLASS="l1">Forums</A>
</TD>
</TR>
<TR><TD WIDTH="100%" VALIGN="MIDDLE" STYLE="background-image: url('2i.png'); border: 0px solid black; padding-left:12px; padding-right:0px; padding-top:6px; padding-bottom:6px; border-top: 1px solid #6E89AE;"><A HREF="www$uppweb$Funding$en-us.html" CLASS="l1">Funding U++</A>
</TD>
</TR>
</TABLE>
<TABLE BORDER="0" WIDTH="100%"><TR><TD></TD>
</TR>
</TABLE>
<TABLE BORDER="0" CELLSPACING="0" CELLPADDING="0" WIDTH="100%" BGCOLOR="#FFFFFF" style="border-style: solid; border-width: 1px; border-color: #6E89AE;padding: 0px"><TR><TD WIDTH="100%" VALIGN="MIDDLE" STYLE="background-image: url('3i.png'); border: 0px solid black;padding-left:12px; padding-right:0px; padding-top:1px; padding-bottom:1px;color:#FFFFFF;"><B><span style="font-size: 8pt; font-family: sans-serif;">Search on this site</span>
</B>
</TD>
</TR>
<TR><TD WIDTH="100%" VALIGN="MIDDLE" STYLE="background-image: url('2i.png'); border: 0px solid black; padding-left:6px; padding-right:0px; padding-top:4px; padding-bottom:4px;border-top: 1px solid #6E89AE;"><TABLE BORDER="0" CELLSPACING="0" CELLPADDING="0" WIDTH="100%"><TR><TD><IMG SRC="4i.png" ALT="" BORDER="0"></TD>
<TD><FORM ACTION="https://www.google.com/search" METHOD="GET" STYLE="margin:0px;padding:0px;"><INPUT TYPE="HIDDEN" NAME="ie" VALUE="UTF-8"><INPUT TYPE="HIDDEN" NAME="oe" VALUE="UTF-8"><INPUT TYPE="TEXT" NAME="q" SIZE="15" MAXLENGTH="256" placeholder="Site search"><INPUT TYPE="HIDDEN" NAME="sitesearch" VALUE="ultimatepp.org"></FORM>
</TD>
</TR>
</TABLE>
</TD>
</TR>
</TABLE>
<TABLE BORDER="0" WIDTH="100%"><TR><TD></TD>
</TR>
</TABLE>
<br><div id="fb-root"></div>
<script type="text/javascript">(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) {return;}
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/en_US/all.js#xfbml=1";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>

<div class="fb-like" data-href="https://www.facebook.com/pages/Upp-Framework/262346610476027?sk=wall" data-send="false" data-layout="button_count" data-width="160" data-show-faces="false" data-font="arial"></div>
<br><br><script type="text/javascript"><!--
google_ad_client = "pub-1082147624384270";
google_ad_width = 160;
google_ad_height = 600;
google_ad_format = "160x600_as";
google_ad_type = "text_image";
google_ad_channel = "";
google_color_border = "336699";
google_color_bg = "FFFFFF";
google_color_link = "0000FF";
google_color_text = "000000";
google_color_url = "008000";
//--></script>
<script type="text/javascript"
  src="https://pagead2.googlesyndication.com/pagead/show_ads.js">
</script><br><br><script type="text/javascript"><!--
google_ad_client = "pub-1082147624384270";
google_ad_width = 160;
google_ad_height = 90;
google_ad_format = "160x90_0ads_al_s";
google_ad_channel = "";
google_color_border = "336699";
google_color_bg = "FFFFFF";
google_color_link = "0000FF";
google_color_text = "000000";
google_color_url = "008000";
//--></script>
<script type="text/javascript"
  src="https://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
<br><br><br><br><br><br><A HREF="https://sourceforge.net/projects/upp/"><IMG SRC="https://sourceforge.net/sflogo.php?group_id=93970&amp;type=2" ALT="SourceForge.net Logo" BORDER="0" WIDTH="125" HEIGHT="37"></A>
<br><br><A HREF="https://flathub.org/en/apps/org.ultimatepp.TheIDE"><IMG SRC="5i.png" ALT="SourceForge.net Logo" BORDER="0" WIDTH="125" HEIGHT="37"></A>
<br><br><div style="background-color:#ffffff;width:125;height:35"><A HREF="https://github.com/ultimatepp"><IMG SRC="6i.png" ALT="GitHub Logo" BORDER="0" WIDTH="125" HEIGHT="35"></A>
</div><br><div style="background-color:#ffffff;width:125;height:35"><div style="height:5"></div><A HREF="https://discord.gg/8XzqQzXZzb"><IMG SRC="https://assets-global.website-files.com/6257adef93867e50d84d30e2/636e0b5061df29d55a92d945_full_logo_blurple_RGB.svg" ALT="Discord Logo" BORDER="0" WIDTH="125" HEIGHT="25"></A>
</div><br></TD>
</TR>
</TABLE>
</TD>
<TD VALIGN="TOP" BGCOLOR="#D2D9D2"><TABLE BORDER="0" CELLSPACING="0" CELLPADDING="0" WIDTH="6"><TR><TD></TD>
</TR>
</TABLE>
</TD>
<TD VALIGN="TOP" WIDTH="100%" BGCOLOR="#D2D9D2"><TABLE BORDER="0" CELLSPACING="0" CELLPADDING="0" BGCOLOR="#FFFFFF" WIDTH="100%" style="border-style: solid; border-width: 1px; border-color: #6E89AE;padding: 10px;;"><TR><TD><TABLE BORDER="0" CELLSPACING="0" CELLPADDING="0" WIDTH="100%"><TR><TD><table width="100%" border="0" cellpadding="0" cellspacing="0"><tr><td width="100%"><table width="100%" class="C"><colgroup><col width="100%"></colgroup>
<tr><td class="D"><p class="E">Index</p>
</td>
</tr>
</table></td>
</tr></table>
<p class="F">&nbsp;</p>
<p id="noref" class="G"><span class="H">template</span>&nbsp;&lt;<span class="H">class</span>&nbsp;<span class="I">T</span>&gt;</p>
<p id="Index::class" class="J"><span class="K">class</span><span class="L">&nbsp;</span>Index</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td valign="top" width="89" bgcolor="#F0F0F0">
<p class="A"><span class="I">T</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Type of elements stored in Index. T is required to be <a href="srcdoc$Core$Moveable$en-us.html"><span class="M">moveable</span></a><span class="M"> </span>and must have <a href="srcdoc$Core$pick_$en-us.html"><span class="M">deep copy constructor</span></a> and deep copy assignment.</p></td></tr></table>
<p class="A">&nbsp;</p>
<p class="A">Like any other NTL container, Index is a <a href="srcdoc$Core$Moveable$en-us.html"><span class="N">moveable</span></a><span class="N"> </span>type with <a href="srcdoc$Core$pick_$en-us.html"><span class="N">pick and optional deep copy</span></a> transfer semantics.</p>
<p class="O">Index adds associative capabilities to Vector.</p>
<p class="O">It allows adding elements at the end of sequence in constant amortized time like basic random container. Additionally, it also allows fast retrieval of a position of the element with specified value. Implementation is based on hash tables. Index stores hash-values of elements, so it has no advantage to cache them externally.</p>
<p class="O">Removing elements from an Index poses an interesting problem. While it is possible to simply remove (or insert) an element at a specified position, such operation has to move a lot of elements and also invalidates internal hash maps. Thus removing elements this way is slow, especially when combined with searching.</p>
<p class="O">The solution for this problem is <span class="N">unlinking</span> of elements. Unlinked elements are not removed from the Index, instead they are <span class="N">ignored</span><span class="M"> </span>by search operations. Unlinking is a simple, constant time, fast operation. Further, it is possible to place an element at the first available unlinked position (rather than to the end of sequence) using the <span class="P">Put</span> method, reusing unlinked position in short constant time.</p>
<p class="O">The only problem of unlinking is that it breaks so-called <span class="P">multi-key ordering</span>. This term means that if there are more elements with the same value in the index and they are iterated through using the FindNext method, their positions (got as the result of Find and subsequent FindNext methods) are in ascending order. The problem is that it is impossible to implement placing elements at unlinked positions in short time while preserving this ordering. On the other hand, usage scenarios for indexes show that need for unlinking elements and multi-key ordering is almost always disjunct. For the rest of the cases, it is always possible to restore ordering using <span class="P">Sweep</span> method.</p>
<p class="F">&nbsp;</p>
<p class="A">&nbsp;</p>
<table width="100%" border="0" cellpadding="0" cellspacing="0"><tr><td width="100%"><table width="100%" class="Q"><colgroup><col width="100%"></colgroup>
<tr><td class="R"><p class="S">Public Member List</p>
</td>
</tr>
</table></td>
</tr></table>
<p class="F">&nbsp;</p>
<p id="Index::Index()" class="T"><span class="P">Index</span>()</p>
<p class="U">Constructs empty Index.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Upp::Index::Index(Upp::Index&&)" class="T"><span class="P">Index</span>(<span class="P">Index</span><span class="H">&amp;&amp;</span>&nbsp;<span class="V">s</span>)</p>
<p class="U">Pick constructor.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Index::Index(pick_ Vector<T>&)" class="T"><span class="P">Index</span>(<span class="W">pick_</span>&nbsp;<a href="Vector"><u>Vector</u></a><span class="H">&lt;</span><span class="I">T</span><span class="H">&gt;&amp;</span>&nbsp;<span class="V">s</span>)</p>
<p class="U">Pick operator. Transfers source Vector to Index in low constant time, but destroys it by picking.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="X">x</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Source Vector.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Index::Index(const Index&,int)" class="T"><span class="P">Index</span>(<span class="H">const</span>&nbsp;<span class="P">Index</span><span class="H">&amp;</span>&nbsp;<span class="V">s</span>, <span class="H">int</span>)</p>
<p class="U">Optional deep copy constructor.</p>
<p class="Y">Requires T to have deep copy constructor or optional deep copy constructor.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="X">s</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Source Index.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Upp::Index::Index(Upp::Vector<T>&&)" class="T"><span class="H">explicit</span>&nbsp;<span class="P">Index</span>(<a href="Upp::Vector"><u>Vector</u></a>&lt;<span class="I">T</span>&gt;&amp;&amp;&nbsp;<span class="V">s</span>)</p>
<p class="U">Pick constructs Index from Vector.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Index::Index(const Vector<T>&,int)" class="T"><span class="P">Index</span>(<span class="H">const</span>&nbsp;<a href="Vector"><u>Vector</u></a><span class="H">&lt;</span><span class="I">T</span><span class="H">&gt;&amp;</span>&nbsp;<span class="V">s</span>, <span class="H">int</span>)</p>
<p class="U">Deep-copy constructs Index from Vector.</p>
<p class="Y">Requires T to have deep copy constructor or optional deep copy constructor.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="V">s</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Source Vector.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Upp::Index::operator=(Upp::Vector<T>&&)" class="T"><a href="Upp::Index"><u>Index</u></a><span class="H">&amp;</span>&nbsp;<span class="P">operator=</span>(<a href="Upp::Vector"><u>Vector</u></a>&lt;<span class="I">T</span>&gt;&amp;&amp;&nbsp;<span class="V">x</span>)</p>
<p class="U">Pick assignment from Vector.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Upp::Index::operator=(Upp::Index<T>&&)" class="T"><a href="Upp::Index"><u>Index</u></a><span class="H">&amp;</span>&nbsp;<span class="P">operator=</span>(<a href="Upp::Index"><u>Index</u></a>&lt;<span class="I">T</span>&gt;&amp;&amp;&nbsp;<span class="V">x</span>)</p>
<p class="U">Pick assignment.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Upp::Index::Index(std::initializer_list<T>)" class="T"><span class="P">Index</span>(<a href="http://en.cppreference.com/w/cpp/utility/initializer_list"><u>std::initializer_list</u></a>&lt;<span class="I">T</span>&gt;&nbsp;<span class="V">init</span>)</p>
<p class="Y">C++ 11 initialization.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Index::Add(const T&,unsigned)" class="T"><span class="I">T</span><span class="H">&amp;</span>&nbsp;<span class="P">Add</span>(<span class="H">const</span>&nbsp;<span class="I">T</span><span class="H">&amp;</span>&nbsp;<span class="V">x</span>, <span class="H">unsigned</span>&nbsp;<span class="V">_hash</span>)</p>
<p id="Upp::Index::Add(T&&,unsigned)" class="T"><span class="I">T</span><span class="H">&amp;</span>&nbsp;<span class="P">Add</span>(<span class="I">T</span><span class="H">&amp;&amp;</span>&nbsp;<span class="V">x</span>, <span class="H">unsigned</span>&nbsp;<span class="V">_hash</span>)</p>
<p class="U">Adds a new element <span class="Z">x</span> with a precomputed hash value <span class="Z">_hash</span>. The performance benefit of this variant is that sometimes you can compute hash-value as the part of other process, like fetching strings from an input stream. Returns a reference to the element.</p>
<p class="Y">Invalidates iterators to Index.</p>
<p class="Y">Invalidates references to Index.</p>
<p class="Y">The precomputed <span class="Z">_hash</span> must be the same as the hash specified by HashFn.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Index::Add(const T&)" class="T"><span class="I">T</span><span class="H">&amp;</span>&nbsp;<span class="P">Add</span>(<span class="H">const</span>&nbsp;<span class="I">T</span><span class="H">&amp;</span>&nbsp;<span class="V">x</span>)</p>
<p id="Upp::Index::Add(T&&)" class="T"><span class="I">T</span><span class="H">&amp;</span>&nbsp;<span class="P">Add</span>(<span class="I">T</span><span class="H">&amp;&amp;</span>&nbsp;<span class="V">x</span>)</p>
<p class="U">Adds a new element <span class="Z">x </span>to Index. Returns a reference to the element.</p>
<p class="Y">Invalidates iterators to Index.</p>
<p class="Y">Invalidates references to Index.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Upp::Index::operator<<(const T&)" class="T"><a href="Upp::Index"><u>Index</u></a><span class="H">&amp;</span>&nbsp;<span class="P">operator&lt;&lt;</span>(<span class="H">const</span>&nbsp;<span class="I">T</span><span class="H">&amp;</span>&nbsp;<span class="V">x</span>)</p>
<p id="Upp::Index::operator<<(T&&)" class="T"><a href="Upp::Index"><u>Index</u></a><span class="H">&amp;</span>&nbsp;<span class="P">operator&lt;&lt;</span>(<span class="I">T</span><span class="H">&amp;&amp;</span>&nbsp;<span class="V">x</span>)</p>
<p class="U">Same as Add(<span class="V">x</span>).</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Index::Find(const T&,unsigned)const" class="AA">int<span class="AB">&nbsp;</span><span class="AC">Find</span><span class="AB">(</span>const<span class="AB">&nbsp;</span><span class="I">T</span>&amp;<span class="AB">&nbsp;</span><span class="V">x</span><span class="AB">, </span>unsigned<span class="AB">&nbsp;</span><span class="V">_hash</span><span class="AB">)&nbsp;</span>const</p>
<p class="U">Returns the position of the first element with value <span class="V">x</span> in Index, using a precomputed <span class="V">_hash</span>. If multi-key ordering is not broken and more than one element with the same value exists in AIndex, the lowest position is returned. If the specified value does not exist in AIndex, a negative number is returned. Unlinked elements are ignored.</p>
<p class="Y">The precomputed <span class="Z">_hash</span> must be the same as the hash specified by HashFn.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Index::Find(const T&)const" class="AA">int<span class="AB">&nbsp;</span><span class="AC">Find</span><span class="AB">(</span>const<span class="AB">&nbsp;</span><span class="I">T</span>&amp;<span class="AB">&nbsp;</span><span class="V">x</span><span class="AB">)&nbsp;</span>const</p>
<p class="U">Returns the position of the first element with value <span class="V">x</span> in AIndex. If multi-key ordering is not broken and more than one element with the same value exists in AIndex, lowest position is retrieved. If the specified value does not exist in AIndex, a negative number is returned. Unlinked elements are ignored.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Index::FindNext(int)const" class="AA">int<span class="AB">&nbsp;</span><span class="AC">FindNext</span><span class="AB">(</span>int<span class="AB">&nbsp;</span><span class="V">i</span><span class="AB">)&nbsp;</span>const</p>
<p class="U">Returns the position of the next element with the same value as the element at <span class="V">i</span>. If multi-key ordering is not broken and more than one element with that value exists in AIndex, the lowest position greater than specified one is retrieved, so positions returned by subsequent calls to FindNext are in ascending order. When there are no more elements with the required value, a negative number is returned. Unlinked elements are ignored.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Index::FindLast(const T&,unsigned)const" class="AA">int<span class="AB">&nbsp;</span><span class="AC">FindLast</span><span class="AB">(</span>const<span class="AB">&nbsp;</span><span class="I">T</span>&amp;<span class="AB">&nbsp;</span><span class="V">x</span><span class="AB">, </span>unsigned<span class="AB">&nbsp;</span><span class="V">_hash</span><span class="AB">)&nbsp;</span>const</p>
<p class="U">Returns the position of the last element with value <span class="V">x</span> in AIndex, using a precomputed <span class="V">_hash</span>. If multi-key ordering is not broken and more than one element with the same value exists in AIndex, the greatest position is retrieved. If the specified value does not exist in AIndex, a negative number is returned. Unlinked elements are ignored.</p>
<p class="Y">The precomputed <span class="Z">_hash</span> must be the same as the hash specified by HashFn.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Index::FindLast(const T&)const" class="AA">int<span class="AB">&nbsp;</span><span class="AC">FindLast</span><span class="AB">(</span>const<span class="AB">&nbsp;</span><span class="I">T</span>&amp;<span class="AB">&nbsp;</span><span class="V">x</span><span class="AB">)&nbsp;</span>const</p>
<p class="U">Returns the position of the last element with value <span class="V">x</span> in AIndex. If multi-key ordering is not broken and more than one element with the same value exists in AIndex, the greatest position is retrieved. If element does not exist in AIndex, a negative number is returned. Unlinked elements are ignored.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Index::FindPrev(int)const" class="AA">int<span class="AB">&nbsp;</span><span class="AC">FindPrev</span><span class="AB">(</span>int<span class="AB">&nbsp;</span><span class="V">i</span><span class="AB">)&nbsp;</span>const</p>
<p class="U">Returns the position of the previous element with the same value as the element at &nbsp;<span class="V">i</span>. If multi-key ordering is not broken and more than one element with that value exists in AIndex, the greatest position lower than specified one is retrieved (so that positions got by subsequent calls to FindNext are in descending order). When there are no more elements with required value, negative number is returned. Unlinked elements are ignored.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Index::FindAdd(const T&,unsigned)" class="T"><span class="H">int</span>&nbsp;<span class="P">FindAdd</span>(<span class="H">const</span>&nbsp;<span class="I">T</span><span class="H">&amp;</span>&nbsp;<span class="V">key</span>, <span class="H">unsigned</span>&nbsp;<span class="V">_hash</span>)</p>
<p id="Upp::Index::FindAdd(T&&,unsigned)" class="T"><span class="H">int</span>&nbsp;<span class="P">FindAdd</span>(<span class="I">T</span><span class="H">&amp;&amp;</span>&nbsp;<span class="V">_key</span>, <span class="H">unsigned</span>&nbsp;<span class="V">_hash</span>)</p>
<p class="U">Retrieves position of first element with value <span class="V">key</span> in AIndex, using a precomputed <span class="V">_hash</span>. If multi-key ordering is not broken and more than one element with the same value exists in AIndex, the greatest position is retrieved. If element does not exist in AIndex, it is added to AIndex and position of this newly added element is returned. Unlinked elements are ignored.</p>
<p class="Y">Invalidates iterators to AIndex.</p>
<p class="Y">Invalidates references to Index.</p>
<p class="Y">The precomputed <span class="Z">_hash</span> must be the same as the hash specified by HashFn.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Index::FindAdd(const T&)" class="T"><span class="H">int</span>&nbsp;<span class="P">FindAdd</span>(<span class="H">const</span>&nbsp;<span class="I">T</span><span class="H">&amp;</span>&nbsp;<span class="V">key</span>)</p>
<p id="Upp::Index::FindAdd(T&&)" class="T"><span class="H">int</span>&nbsp;<span class="P">FindAdd</span>(<span class="I">T</span>&amp;&amp;&nbsp;<span class="V">key</span>)</p>
<p class="U">Retrieves position of first element with value <span class="V">key</span> in AIndex. If multi-key ordering is not broken and more than one element with the same value exists in AIndex, lowest position is retrieved. If element does not exist in AIndex, it is added to AIndex and position of this newly added element is returned. Unlinked elements are ignored.</p>
<p class="Y">Invalidates iterators to AIndex.</p>
<p class="Y">Invalidates references to Index.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Index::Unlink(int)" class="T"><span class="H">void</span>&nbsp;<span class="P">Unlink</span>(<span class="H">int</span>&nbsp;<span class="V">i</span>)</p>
<p class="U">Unlinks the element at <span class="V">i</span>. The unlinked item stays in AIndex but is ignored by any Find operation.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Index::Put(const T&,unsigned)" class="T"><span class="H">int</span>&nbsp;<span class="P">Put</span>(<span class="H">const</span>&nbsp;<span class="I">T</span><span class="H">&amp;</span>&nbsp;<span class="V">x</span>, <span class="H">unsigned</span>&nbsp;<span class="V">_hash</span>)</p>
<p id="Upp::Index::Put(T&&,unsigned)" class="T"><span class="H">template</span>&nbsp;&lt;<span class="H">class</span>&nbsp;<span class="I">T</span>&gt;&nbsp;<span class="H">int</span>&nbsp;<span class="P">Put</span>(<span class="I">T</span><span class="H">&amp;&amp;</span>&nbsp;<span class="V">x</span>, <span class="H">unsigned</span>&nbsp;<span class="V">_hash</span>)</p>
<p class="U">If there are any unlinked elements in Index, one of them is replaced by <span class="V">x</span>. If there are no unlinked elements, the element with the specified value is appended to the end of AIndex using <span class="P">Add</span>. The position of newly placed element is returned.</p>
<p class="Y">Invalidates multi-key ordering.</p>
<p class="Y">Invalidates iterators to AIndex.</p>
<p class="Y">Invalidates references to Index.</p>
<p class="Y">The precomputed <span class="Z">_hash</span> must be the same as the hash specified by HashFn.</p>
<p class="U"> <span class="V">x</span> .</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Index::Put(const T&)" class="T"><span class="H">int</span>&nbsp;<span class="P">Put</span>(<span class="H">const</span>&nbsp;<span class="I">T</span><span class="H">&amp;</span>&nbsp;<span class="V">x</span>)</p>
<p id="Upp::Index::Put(T&&)" class="T"><span class="H">int</span>&nbsp;<span class="P">Put</span>(<span class="I">T</span><span class="H">&amp;&amp;</span>&nbsp;<span class="V">x</span>)</p>
<p class="U">If there are any unlinked elements in AIndex, one of them is replaced by <span class="V">x</span>. If there are no unlinked elements, the element with the specified value is appended to the end of AIndex using <span class="P">Add</span>. The position of the newly placed element is returned.</p>
<p class="Y">Invalidates multi-key ordering.</p>
<p class="Y">Invalidates iterators to AIndex.</p>
<p class="Y">Invalidates references to Index.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Upp::Index::FindPut(const T&,bool&)" class="T"><span class="H">int</span> <span class="P">FindPut</span>(<span class="H">const</span> T<span class="H">&amp;</span> <span class="V">key</span>, <span class="H">bool&amp;</span> <span class="V">put</span>)</p>
<p id="Upp::Index::FindPut(T&&,bool&)" class="T"><span class="H">int</span> <span class="P">FindPut</span>(T<span class="H">&amp;&amp;</span> <span class="V">key</span>, <span class="H">bool&amp;</span> <span class="V">put</span>)</p>
<p id="Index::FindPut(const T&)" class="T"><span class="H">int</span>&nbsp;<span class="P">FindPut</span>(<span class="H">const</span>&nbsp;<span class="I">T</span><span class="H">&amp;</span>&nbsp;<span class="V">key</span>)</p>
<p id="Upp::Index::FindPut(T&&)" class="T"><span class="H">int</span>&nbsp;<span class="P">FindPut</span>(<span class="I">T</span><span class="H">&amp;&amp;</span>&nbsp;<span class="V">key</span>)</p>
<p class="U">Retrieves the position of the first element with value <span class="V">key</span> in AIndex. If the element does not exist in the AIndex, it is placed to it using <span class="P">Put(const T&amp; x).</span> The position of the found or placed element is returned. If element is placed, variants with <span class="V">put</span> set it to true.</p>
<p class="Y">Invalidates multi-key ordering.</p>
<p class="Y">Invalidates iterators to AIndex.</p>
<p class="Y">Invalidates references to Index.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Index::Set(int,const T&,unsigned)" class="T"><span class="I">T</span><span class="H">&amp;</span>&nbsp;<span class="P">Set</span>(<span class="H">int</span>&nbsp;<span class="V">i</span>, <span class="H">const</span>&nbsp;<span class="I">T</span><span class="H">&amp;</span>&nbsp;<span class="V">x</span>, <span class="H">unsigned</span>&nbsp;<span class="V">_hash</span>)</p>
<p id="Upp::Index::Set(int,T&&,unsigned)" class="T"><span class="I">T</span><span class="H">&amp;</span>&nbsp;<span class="P">Set</span>(<span class="H">int</span>&nbsp;<span class="V">i</span>, <span class="I">T</span><span class="H">&amp;&amp;</span>&nbsp;<span class="V">x</span>, <span class="H">unsigned</span>&nbsp;<span class="V">_hash</span>)</p>
<p class="U">Replaces the element at the specified position with a new element with value <span class="V">x</span>, using a precomputed <span class="V">_hash</span>. Speed of this operation depends on the total number of elements with the same value as the specified one. Returns a reference to the element.</p>
<p class="Y">Invalidates iterators to AIndex.</p>
<p class="Y">Invalidates references to Index.</p>
<p class="Y">The precomputed <span class="Z">_hash</span> must be the same as the hash specified by HashFn.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Index::Set(int,const T&)" class="T"><span class="I">T</span><span class="H">&amp;</span>&nbsp;<span class="P">Set</span>(<span class="H">int</span>&nbsp;<span class="V">i</span>, <span class="H">const</span>&nbsp;<span class="I">T</span><span class="H">&amp;</span>&nbsp;<span class="V">x</span>)</p>
<p id="Upp::Index::Set(int,T&&)" class="T"><span class="I">T</span><span class="H">&amp;</span>&nbsp;<span class="P">Set</span>(<span class="H">int</span>&nbsp;<span class="V">i</span>, <span class="I">T</span><span class="H">&amp;&amp;</span>&nbsp;<span class="V">x</span>)</p>
<p class="U">Replaces the element at the specified position with a new element with value <span class="V">x</span>. Speed of this operation depends on the total number of elements with the same value as the specified one. Returns a reference to the element.</p>
<p class="Y">Invalidates iterators to AIndex.</p>
<p class="Y">Invalidates references to Index.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Index::operator[](int)const" class="AA">const<span class="AB">&nbsp;</span><span class="I">T</span>&amp;<span class="AB">&nbsp;</span><span class="AC">operator[]</span><span class="AB">(</span>int<span class="AB">&nbsp;</span><span class="V">i</span><span class="AB">)&nbsp;</span>const</p>
<p class="U">Returns the element at the specified position.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Index::GetCount()const" class="AA">int<span class="AB">&nbsp;</span><span class="AC">GetCount</span><span class="AB">()&nbsp;</span>const</p>
<p class="U">Returns number of elements in AIndex.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Upp::Index::begin()const" class="AA"><a href="Upp::Index::ConstIterator"><span class="AB"><u>ConstIterator</u></span></a><span class="AB">&nbsp;</span><span class="AC">begin</span><span class="AB">()&nbsp;</span>const</p>
<p id="Upp::Index::end()const" class="AA"><a href="Upp::Index::ConstIterator"><span class="AB"><u>ConstIterator</u></span></a><span class="AB">&nbsp;</span><span class="AC">end</span><span class="AB">()&nbsp;</span>const</p>
<p class="U">Standard begin/end methods.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Index::IsEmpty()const" class="AA">bool<span class="AB">&nbsp;</span><span class="AC">IsEmpty</span><span class="AB">()&nbsp;</span>const</p>
<p class="U">Tests whether AIndex is empty. Same as GetCount() == 0.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Index::GetHash(int)const" class="AA">unsigned<span class="AB">&nbsp;</span><span class="AC">GetHash</span><span class="AB">(</span>int<span class="AB">&nbsp;</span><span class="V">i</span><span class="AB">)&nbsp;</span>const</p>
<p class="U">Returns a hash of element <span class="V">i</span>. This is perhaps only useful when making the exact copy of Index, e.g. in the persistent storage.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Index::Clear()" class="T"><span class="H">void</span>&nbsp;<span class="P">Clear</span>()</p>
<p class="U">Removes all elements from AIndex.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Index::UnlinkKey(const T&,unsigned)" class="T"><span class="H">int</span>&nbsp;<span class="P">UnlinkKey</span>(<span class="H">const</span>&nbsp;<span class="I">T</span><span class="H">&amp;</span>&nbsp;<span class="V">k</span>, <span class="H">unsigned</span>&nbsp;<span class="V">_hash</span>)</p>
<p class="U">Unlinks all elements with value <span class="V">k</span> using precomputed <span class="V">_hash</span>. Unlinked elements stay in AIndex but are ignored by any Find operations. Precomputed hash value must be same as hash value that would be result of HashFn.</p>
<p class="Y">The precomputed <span class="Z">_hash</span> must be the same as the hash specified by HashFn.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Index::UnlinkKey(const T&)" class="T"><span class="H">int</span>&nbsp;<span class="P">UnlinkKey</span>(<span class="H">const</span>&nbsp;<span class="I">T</span><span class="H">&amp;</span>&nbsp;<span class="V">k</span>)</p>
<p class="U">Unlinks all elements with value <span class="V">k</span>. Unlinked elements remain in the AIndex but are ignored by any Find operations.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Index::IsUnlinked(int)const" class="AA">bool<span class="AB">&nbsp;</span><span class="AC">IsUnlinked</span><span class="AB">(</span>int<span class="AB">&nbsp;</span><span class="V">i</span><span class="AB">)&nbsp;</span>const</p>
<p class="U">Tests whether the element at <span class="V">i</span> is unlinked.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Index::GetUnlinked()const" class="AA"><a href="Vector"><span class="AB"><u>Vector</u></span></a><span class="AB">&lt;</span>int<span class="AB">&gt;&nbsp;</span><span class="AC">GetUnlinked</span><span class="AB">()&nbsp;</span>const</p>
<p class="U">Returns indices of all unlinked elements.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Index::Sweep()" class="T"><span class="H">void</span>&nbsp;<span class="P">Sweep</span>()</p>
<p class="U">Removes all unlinked elements from AIndex. Complexity of the operation depends on the number of elements in AIndex, not on the number of unlinked elements. Also restores multi-key ordering.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Index::HasUnlinked()const" class="AA">bool<span class="AB">&nbsp;</span><span class="AC">HasUnlinked</span><span class="AB">()&nbsp;</span>const</p>
<p class="U">Returns true of AIndex has any unlinked elements.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Index::Insert(int,const T&,unsigned)" class="T"><span class="I">T</span><span class="H">&amp;</span>&nbsp;<span class="P">Insert</span>(<span class="H">int</span>&nbsp;<span class="V">i</span>, <span class="H">const</span>&nbsp;<span class="I">T</span><span class="H">&amp;</span>&nbsp;<span class="V">k</span>, <span class="H">unsigned</span>&nbsp;<span class="V">h</span>)</p>
<p class="U">Inserts an element with value <span class="V">k</span> at the specified position <span class="V">i</span>, using a precomputed hash <span class="V">h</span>. This is a slow O(n) operation. Returns a reference to the element.</p>
<p class="Y">Requires T to have deep copy constructor.</p>
<p class="Y">Invalidates iterators to AIndex.</p>
<p class="Y">Invalidates references to Index.</p>
<p class="Y">The precomputed <span class="Z">_hash</span> must be the same as the hash specified by HashFn.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Index::Insert(int,const T&)" class="T"><span class="I">T</span><span class="H">&amp;</span>&nbsp;<span class="P">Insert</span>(<span class="H">int</span>&nbsp;<span class="V">i</span>, <span class="H">const</span>&nbsp;<span class="I">T</span><span class="H">&amp;</span>&nbsp;<span class="V">k</span>)</p>
<p class="U">Inserts an element with value <span class="V">k</span> at the specified position <span class="V">i</span>. This is a slow O(n) operation. Returns a reference to the element.</p>
<p class="Y">Requires T to have deep copy constructor.</p>
<p class="Y">Invalidates iterators to AIndex.</p>
<p class="Y">Invalidates references to Index.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Index::Remove(int)" class="T"><span class="H">void</span>&nbsp;<span class="P">Remove</span>(<span class="H">int</span>&nbsp;<span class="V">i</span>)</p>
<p class="U">Removes an element at the specified position <span class="V">i</span>. This is a slow O(n) operation.</p>
<p class="Y">Invalidates iterators to AIndex.</p>
<p class="Y">Invalidates references to Index.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Index::Remove(int,int)" class="T"><span class="H">void</span>&nbsp;<span class="P">Remove</span>(<span class="H">int</span>&nbsp;<span class="V">i</span>, <span class="H">int</span>&nbsp;<span class="V">count</span>)</p>
<p class="U">Removes <span class="V">count</span> elements starting at <span class="V">i</span>. This is a slow O(n) operation.</p>
<p class="Y">Invalidates iterators to AIndex.</p>
<p class="Y">Invalidates references to Index.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Index::Remove(const int*,int)" class="T"><span class="H">void</span>&nbsp;<span class="P">Remove</span>(<span class="H">const</span>&nbsp;<span class="H">int</span>&nbsp;*<span class="V">sorted_list</span>, <span class="H">int</span>&nbsp;<span class="V">count</span>)</p>
<p class="U">Removes multiple elements from AIndex. Time of operation only slightly depends on the number of removed elements. This is a slow O(n) operation. <span class="V">sorted_list</span> must point to <span class="V">count</span> positions, sorted in ascending order.</p>
<p class="Y">Invalidates iterators to AIndex.</p>
<p class="Y">Invalidates references to Index.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Index::Remove(const Vector<int>&)" class="T"><span class="H">void</span>&nbsp;<span class="P">Remove</span>(<span class="H">const</span>&nbsp;Vector<span class="H">&lt;int&gt;&amp;</span>&nbsp;<span class="V">sorted_list</span>)</p>
<p class="U">Removes multiple elements from AIndex. Same as Remove(sorted_list, sorted_list.GetCount()).</p>
<p class="Y">Invalidates iterators to AIndex.</p>
<p class="Y">Invalidates references to Index.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Index::RemoveKey(const T&,unsigned)" class="T"><span class="H">int</span>&nbsp;<span class="P">RemoveKey</span>(<span class="H">const</span>&nbsp;<span class="I">T</span><span class="H">&amp;</span>&nbsp;<span class="V">k</span>, <span class="H">unsigned</span>&nbsp;<span class="V">h</span>)</p>
<p class="U">Removes all elements with value <span class="V">k</span> using a precomputed hash <span class="V">h</span>. Slow O(n).</p>
<p class="Y">Invalidates iterators to AIndex.</p>
<p class="Y">Invalidates references to Index.</p>
<p class="Y">The precomputed <span class="Z">_hash</span> must be the same as the hash specified by HashFn.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Index::RemoveKey(const T&)" class="T"><span class="H">int</span>&nbsp;<span class="P">RemoveKey</span>(<span class="H">const</span>&nbsp;<span class="I">T</span><span class="H">&amp;</span>&nbsp;<span class="V">k</span>)</p>
<p class="U">Removes all elements with value <span class="V">k</span>. Slow O(n).</p>
<p class="Y">Invalidates iterators to AIndex.</p>
<p class="Y">Invalidates references to Index.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Index::Trim(int)" class="T"><span class="H">void</span>&nbsp;<span class="P">Trim</span>(<span class="H">int</span>&nbsp;<span class="V">n</span>)</p>
<p class="U">Reduces the number of elements in AIndex to <span class="V">n</span>. Requested number must be less than or equal to actual number of elements in AIndex.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Index::Drop(int)" class="T"><span class="H">void</span>&nbsp;<span class="P">Drop</span>(<span class="H">int</span>&nbsp;<span class="V">n</span>&nbsp;=&nbsp;<span class="Z">1</span>)</p>
<p class="U">Drops <span class="V">n</span> elements from the end of the AIndex (same as Trim(GetCount() - n)).</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Index::Top()const" class="AA">const<span class="AB">&nbsp;</span><span class="I">T</span>&amp;<span class="AB">&nbsp;</span><span class="AC">Top</span><span class="AB">()&nbsp;</span>const</p>
<p class="U">Returns a reference to the last element in the AIndex.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Index::Pop()" class="T"><span class="I">T</span>&nbsp;<span class="P">Pop</span>()</p>
<p class="U">Drops last element of the Index and returns its value.</p>
<p class="Y">Requires T to have deep copy constructor.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Index::Reserve(int)" class="T"><span class="H">void</span>&nbsp;<span class="P">Reserve</span>(<span class="H">int</span>&nbsp;<span class="V">n</span>)</p>
<p class="U">Reserves capacity. If <span class="V">n</span> is greater than current capacity, capacity is increased to the requested value.</p>
<p class="A">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Index::Shrink()" class="T"><span class="H">void</span>&nbsp;<span class="P">Shrink</span>()</p>
<p class="U">Minimizes the memory consumption of AIndex by decreasing the capacity to the number of elements.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Index::GetAlloc()const" class="AA">int<span class="AB">&nbsp;</span><span class="AC">GetAlloc</span><span class="AB">()&nbsp;</span>const</p>
<p class="U">Returns the current capacity of AIndex.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Index::Serialize(Stream&)" class="T"><span class="H">void</span>&nbsp;<span class="P">Serialize</span>(Stream<span class="H">&amp;</span>&nbsp;<span class="V">s</span>)</p>
<p class="U">Serializes content of AIndex to/from Stream.</p>
<p class="Y">Requires T to have serialization operator defined.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Index::PickKeys()" class="T"><span class="I">V</span>&nbsp;<span class="P">PickKeys</span>()</p>
<p class="U">Returns a basic random access container of elements. Destroys AIndex by picking.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Index::GetKeys()const" class="AA">const<span class="AB">&nbsp;</span><span class="I">V</span>&amp;<span class="AB">&nbsp;</span><span class="AC">GetKeys</span><span class="AB">()&nbsp;</span>const</p>
<p class="U">Returns a constant reference to basic random access container of elements.</p>
<p class="A">&nbsp;</p>
</TD>
</TR>
</TABLE>
</TD>
</TR>
</TABLE>
<TABLE BORDER="0" WIDTH="100%"><TR><TD></TD>
</TR>
</TABLE>
<TABLE BORDER="0" CELLSPACING="0" CELLPADDING="0" BGCOLOR="#FFFFFF" WIDTH="100%" style="border-style: solid; border-width: 1px; border-color: #6E89AE;padding: 10px;;"><TR><TD><TABLE BORDER="0" CELLSPACING="0" CELLPADDING="0" WIDTH="100%"><TR><TD><p class="A"><span class="B"> </span><a href="www$uppweb$contribweb$en-us.html">Do you want to contribute?</a></p>
</TD>
</TR>
</TABLE>
</TD>
</TR>
</TABLE>
</TD>
</TR>
</TABLE>
<script type="text/javascript">var a={'src$Core$Indext$en-us.html':'English'};var p=window.location.pathname.split("/");p=p[p.length-1];var s='<select id="lang" onchange="window.location=document.getElementById(\'lang\').value;">';for(l in a){if(p==l){d=" selected=1"}else{d=""}s+='<option value="'+l+'"'+d+'>'+a[l]+'</option>'}s+='</select>';var d=document.createElement('div');d.innerHTML=s;var c=document.getElementById('langs');c.replaceChild(d,c.firstChild);document.getElementById('langbox').style.display='block';</script></BODY>
