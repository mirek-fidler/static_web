<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML lang="en-us">
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="Generator" CONTENT="U++ HTML Package">
<TITLE>String and WString :: U++</TITLE>
<STYLE TYPE="text/css"><!--
.A{margin:0px 0px 0px 0px;text-indent:0px;text-align:left;color:#000000;font-family:sans-serif;font-size:10pt;font-weight:normal;font-style:normal;}
.B{font-size:12pt;}
.C{border-collapse:collapse;table-layout:auto;border: 2px solid #000000;}
.D{padding: 3px 5px 3px 5px;border-left: 1px solid #000000;border-top: 1px solid #000000;border-right: 1px solid #000000;border-bottom: 1px solid #000000;background-color:#712A00;vertical-align:middle;}
.E{margin:0px 0px 0px 0px;text-indent:0px;text-align:left;color:#e0e0e0;font-family:sans-serif;font-size:16pt;font-weight:bold;font-style:normal;}
.F{margin:0px 0px 0px 0px;text-indent:0px;text-align:left;color:#000000;font-family:sans-serif;font-size:6pt;font-weight:normal;font-style:normal;}
.G{margin:0px 0px 5px 0px;text-indent:0px;text-align:left;color:#000000;font-family:sans-serif;font-size:12pt;font-weight:normal;font-style:normal;}
.H{color:#0000ff;}
.I{font-weight:bold;}
.J{color:#800000;font-weight:bold;}
.K{margin:8px 0px 0px 0px;text-indent:0px;text-align:left;color:#000000;font-family:sans-serif;font-size:10pt;font-weight:normal;font-style:normal;}
.L{border-collapse:collapse;table-layout:auto;border: 2px solid #808080;}
.M{padding: 3px 5px 3px 5px;border-left: 1px solid #808080;border-top: 1px solid #808080;border-right: 1px solid #808080;border-bottom: 1px solid #808080;background-color:#C0C0C0;vertical-align:middle;}
.N{margin:0px 0px 0px 0px;text-indent:0px;text-align:left;color:#000000;font-family:sans-serif;font-size:10pt;font-weight:bold;font-style:normal;}
.O{margin:0px 0px 5px 0px;text-indent:0px;text-align:left;color:#000000;font-family:sans-serif;font-size:10pt;font-weight:normal;font-style:normal;}
.P{margin:0px 0px 0px 57px;text-indent:0px;text-align:left;color:#000000;font-family:sans-serif;font-size:10pt;font-weight:normal;font-style:normal;}
.Q{margin:0px 0px 5px 0px;text-indent:0px;text-align:left;color:#0000ff;font-family:sans-serif;font-size:10pt;font-weight:normal;font-style:normal;}
.R{color:#000000;}
.S{color:#000000;font-weight:bold;}
.T{color:#800000;}
.U{margin:0px 0px 0px 57px;text-indent:0px;text-align:left;color:#800000;font-family:sans-serif;font-size:10pt;font-weight:bold;font-style:normal;}
.V{color:#000000;font-weight:normal;}
.W{color:#008000;font-weight:bold;}
.X{margin:0px 0px 5px 0px;text-indent:0px;text-align:left;color:#0000ff;font-family:sans-serif;font-size:12pt;font-weight:normal;font-style:normal;}
.Y{margin:0px 0px 5px 0px;text-indent:0px;text-align:left;color:#800000;font-family:sans-serif;font-size:10pt;font-weight:bold;font-style:normal;}
.Z{color:#0000ff;font-weight:normal;}
.AA{font-weight:bold;font-style:italic;}
a.l1         { text-decoration:none; font-size: 8pt; font-family: sans-serif; font-weight: normal; }
a.l1:link    { color:#000000; }
a.l1:visited { color:#000080; }
a.l1:hover   { color:#9933CC; }
a.l1:active  { color:#000000; }
a.l2         { text-decoration:none; font-size: 12pt; font-family: sans-serif; font-variant: small-caps; }
a.l2:link    { color:#0066FF; }
a.l2:visited { color:#FF6600; }
a.l2:hover   { color:#BC0624; }
a.l2:active  { color:#BC0024; }

-->
</STYLE>
<META NAME="keywords" CONTENT="framework, toolkit, widget, c++, visual, studio, dev-cpp, builder, ide, class, component,wxwidgets, qt, rapid, application, development, rad, mfc, linux, macos, gui, sdl, directx, desktop"><META name="robots" content="index,follow">
<LINK rel="alternate" type="application/rss+xml" title="SVN changes" href="svnchanges.xml">
<LINK rel="shortcut icon" type="image/png" href="favicon.png">
</HEAD><BODY BGCOLOR="#D2D9D2" ALINK="#800000" LINK="#000000" VLINK="#000080"><TABLE BORDER="0" CELLSPACING="0" CELLPADDING="0" WIDTH="100%"><TR><TD COLSPAN="3"><TABLE BORDER="0" CELLSPACING="0" CELLPADDING="0" WIDTH="100%" BGCOLOR="#FFFFFF" style="border: 1px solid #6E89AE;padding-left: 10px;padding-right: 0px;padding-top: 0px;padding-bottom: 0px;"><TR><TD><A HREF="index.html"><IMG SRC="0i.png" ALT="" BORDER="0"></A>
</TD>
<TD ALIGN="RIGHT" VALIGN="BOTTOM" STYLE="padding-bottom: 5px; background-image: url('1i.png')"><span style="font-size: 14pt; font-family: sans-serif;"><script type="text/javascript"><!--
google_ad_client = "pub-1082147624384270";
google_ad_width = 468;
google_ad_height = 60;
google_ad_format = "468x60_as";
google_ad_type = "text_image";
google_ad_channel = "";
google_color_border = "336699";
google_color_bg = "FFFFFF";
google_color_link = "0000FF";
google_color_text = "000000";
google_color_url = "008000";
//--></script>
<script type="text/javascript"
  src="https://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
&nbsp;&nbsp;</span>
</TD>
</TR>
</TABLE>
</TD>
</TR>
</TABLE>
<TABLE BORDER="0" CELLSPACING="0" CELLPADDING="0" WIDTH="100%"><TR><TD COLSPAN="3" BGCOLOR="#D2D9D2" HEIGHT="6"></TD>
</TR>
<TR><TD VALIGN="TOP" ALIGN="CENTER"><TABLE BORDER="0" CELLSPACING="0" CELLPADDING="0" WIDTH="160"><TR><TD ALIGN="CENTER"><TABLE BORDER="0" CELLSPACING="0" CELLPADDING="0" WIDTH="100%" BGCOLOR="#FFFFFF" style="border-style: solid; border-width: 1px; border-color: #6E89AE;padding: 0px"><TR><TD WIDTH="100%" VALIGN="MIDDLE" STYLE="background-image: url('2i.png'); border: 0px solid black; padding-left:12px; padding-right:0px; padding-top:6px; padding-bottom:6px;"><A HREF="www$uppweb$overview$en-us.html" CLASS="l1">Overview</A>
</TD>
</TR>
<TR><TD WIDTH="100%" VALIGN="MIDDLE" STYLE="background-image: url('2i.png'); border: 0px solid black; padding-left:12px; padding-right:0px; padding-top:6px; padding-bottom:6px; border-top: 1px solid #6E89AE;"><A HREF="www$uppweb$examples$en-us.html" CLASS="l1">Examples</A>
</TD>
</TR>
<TR><TD WIDTH="100%" VALIGN="MIDDLE" STYLE="background-image: url('2i.png'); border: 0px solid black; padding-left:12px; padding-right:0px; padding-top:6px; padding-bottom:6px; border-top: 1px solid #6E89AE;"><A HREF="www$uppweb$ss$en-us.html" CLASS="l1">Screenshots</A>
</TD>
</TR>
<TR><TD WIDTH="100%" VALIGN="MIDDLE" STYLE="background-image: url('2i.png'); border: 0px solid black; padding-left:12px; padding-right:0px; padding-top:6px; padding-bottom:6px; border-top: 1px solid #6E89AE;"><A HREF="www$uppweb$comparison$en-us.html" CLASS="l1">Comparisons</A>
</TD>
</TR>
<TR><TD WIDTH="100%" VALIGN="MIDDLE" STYLE="background-image: url('2i.png'); border: 0px solid black; padding-left:12px; padding-right:0px; padding-top:6px; padding-bottom:6px; border-top: 1px solid #6E89AE;"><A HREF="www$uppweb$apps$en-us.html" CLASS="l1">Applications</A>
</TD>
</TR>
<TR><TD WIDTH="100%" VALIGN="MIDDLE" STYLE="background-image: url('2i.png'); border: 0px solid black; padding-left:12px; padding-right:0px; padding-top:6px; padding-bottom:6px; border-top: 1px solid #6E89AE;"><A HREF="www$uppweb$download$en-us.html" CLASS="l1">Download</A>
</TD>
</TR>
<TR><TD WIDTH="100%" VALIGN="MIDDLE" STYLE="background-image: url('2i.png'); border: 0px solid black; padding-left:12px; padding-right:0px; padding-top:6px; padding-bottom:6px; border-top: 1px solid #6E89AE;"><A HREF="www$uppweb$documentation$en-us.html" CLASS="l1">Documentation</A>
</TD>
</TR>
<TR><TD WIDTH="100%" VALIGN="MIDDLE" STYLE="background-image: url('2i.png'); border: 0px solid black; padding-left:12px; padding-right:0px; padding-top:6px; padding-bottom:6px; border-top: 1px solid #6E89AE;"><A HREF="www$uppweb$Tutorials$en-us.html" CLASS="l1">Tutorials</A>
</TD>
</TR>
<TR><TD WIDTH="100%" VALIGN="MIDDLE" STYLE="background-image: url('2i.png'); border: 0px solid black; padding-left:12px; padding-right:0px; padding-top:6px; padding-bottom:6px; border-top: 1px solid #6E89AE;"><A HREF="app$ide$UppHub$en-us.html" CLASS="l1">UppHub</A>
</TD>
</TR>
<TR><TD WIDTH="100%" VALIGN="MIDDLE" STYLE="background-image: url('2i.png'); border: 0px solid black; padding-left:12px; padding-right:0px; padding-top:6px; padding-bottom:6px; border-top: 1px solid #6E89AE;"><A HREF="www$uppweb$Roadmap$en-us.html" CLASS="l1">Status & Roadmap</A>
</TD>
</TR>
<TR><TD WIDTH="100%" VALIGN="MIDDLE" STYLE="background-image: url('2i.png'); border: 0px solid black; padding-left:12px; padding-right:0px; padding-top:6px; padding-bottom:6px; border-top: 1px solid #6E89AE;"><A HREF="www$uppweb$FAQ$en-us.html" CLASS="l1">FAQ</A>
</TD>
</TR>
<TR><TD WIDTH="100%" VALIGN="MIDDLE" STYLE="background-image: url('2i.png'); border: 0px solid black; padding-left:12px; padding-right:0px; padding-top:6px; padding-bottom:6px; border-top: 1px solid #6E89AE;"><A HREF="app$ide$About$en-us.html" CLASS="l1">Authors & License</A>
</TD>
</TR>
<TR><TD WIDTH="100%" VALIGN="MIDDLE" STYLE="background-image: url('2i.png'); border: 0px solid black; padding-left:12px; padding-right:0px; padding-top:6px; padding-bottom:6px; border-top: 1px solid #6E89AE;"><A HREF="https://www.ultimatepp.org/forums" CLASS="l1">Forums</A>
</TD>
</TR>
<TR><TD WIDTH="100%" VALIGN="MIDDLE" STYLE="background-image: url('2i.png'); border: 0px solid black; padding-left:12px; padding-right:0px; padding-top:6px; padding-bottom:6px; border-top: 1px solid #6E89AE;"><A HREF="www$uppweb$Funding$en-us.html" CLASS="l1">Funding U++</A>
</TD>
</TR>
</TABLE>
<TABLE BORDER="0" WIDTH="100%"><TR><TD></TD>
</TR>
</TABLE>
<TABLE BORDER="0" CELLSPACING="0" CELLPADDING="0" WIDTH="100%" BGCOLOR="#FFFFFF" style="border-style: solid; border-width: 1px; border-color: #6E89AE;padding: 0px"><TR><TD WIDTH="100%" VALIGN="MIDDLE" STYLE="background-image: url('3i.png'); border: 0px solid black;padding-left:12px; padding-right:0px; padding-top:1px; padding-bottom:1px;color:#FFFFFF;"><B><span style="font-size: 8pt; font-family: sans-serif;">Search on this site</span>
</B>
</TD>
</TR>
<TR><TD WIDTH="100%" VALIGN="MIDDLE" STYLE="background-image: url('2i.png'); border: 0px solid black; padding-left:6px; padding-right:0px; padding-top:4px; padding-bottom:4px;border-top: 1px solid #6E89AE;"><TABLE BORDER="0" CELLSPACING="0" CELLPADDING="0" WIDTH="100%"><TR><TD><IMG SRC="4i.png" ALT="" BORDER="0"></TD>
<TD><FORM ACTION="https://www.google.com/search" METHOD="GET" STYLE="margin:0px;padding:0px;"><INPUT TYPE="HIDDEN" NAME="ie" VALUE="UTF-8"><INPUT TYPE="HIDDEN" NAME="oe" VALUE="UTF-8"><INPUT TYPE="TEXT" NAME="q" SIZE="15" MAXLENGTH="256" placeholder="Site search"><INPUT TYPE="HIDDEN" NAME="sitesearch" VALUE="ultimatepp.org"></FORM>
</TD>
</TR>
</TABLE>
</TD>
</TR>
</TABLE>
<TABLE BORDER="0" WIDTH="100%"><TR><TD></TD>
</TR>
</TABLE>
<br><div id="fb-root"></div>
<script type="text/javascript">(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) {return;}
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/en_US/all.js#xfbml=1";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>

<div class="fb-like" data-href="https://www.facebook.com/pages/Upp-Framework/262346610476027?sk=wall" data-send="false" data-layout="button_count" data-width="160" data-show-faces="false" data-font="arial"></div>
<br><br><script type="text/javascript"><!--
google_ad_client = "pub-1082147624384270";
google_ad_width = 160;
google_ad_height = 600;
google_ad_format = "160x600_as";
google_ad_type = "text_image";
google_ad_channel = "";
google_color_border = "336699";
google_color_bg = "FFFFFF";
google_color_link = "0000FF";
google_color_text = "000000";
google_color_url = "008000";
//--></script>
<script type="text/javascript"
  src="https://pagead2.googlesyndication.com/pagead/show_ads.js">
</script><br><br><script type="text/javascript"><!--
google_ad_client = "pub-1082147624384270";
google_ad_width = 160;
google_ad_height = 90;
google_ad_format = "160x90_0ads_al_s";
google_ad_channel = "";
google_color_border = "336699";
google_color_bg = "FFFFFF";
google_color_link = "0000FF";
google_color_text = "000000";
google_color_url = "008000";
//--></script>
<script type="text/javascript"
  src="https://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
<br><br><br><br><br><br><A HREF="https://sourceforge.net/projects/upp/"><IMG SRC="https://sourceforge.net/sflogo.php?group_id=93970&amp;type=2" ALT="SourceForge.net Logo" BORDER="0" WIDTH="125" HEIGHT="37"></A>
<br><br><A HREF="https://flathub.org/en/apps/org.ultimatepp.TheIDE"><IMG SRC="5i.png" ALT="SourceForge.net Logo" BORDER="0" WIDTH="125" HEIGHT="37"></A>
<br><br><div style="background-color:#ffffff;width:125;height:35"><A HREF="https://github.com/ultimatepp"><IMG SRC="6i.png" ALT="GitHub Logo" BORDER="0" WIDTH="125" HEIGHT="35"></A>
</div><br><div style="background-color:#ffffff;width:125;height:35"><div style="height:5"></div><A HREF="https://discord.gg/8XzqQzXZzb"><IMG SRC="https://assets-global.website-files.com/6257adef93867e50d84d30e2/636e0b5061df29d55a92d945_full_logo_blurple_RGB.svg" ALT="Discord Logo" BORDER="0" WIDTH="125" HEIGHT="25"></A>
</div><br></TD>
</TR>
</TABLE>
</TD>
<TD VALIGN="TOP" BGCOLOR="#D2D9D2"><TABLE BORDER="0" CELLSPACING="0" CELLPADDING="0" WIDTH="6"><TR><TD></TD>
</TR>
</TABLE>
</TD>
<TD VALIGN="TOP" WIDTH="100%" BGCOLOR="#D2D9D2"><TABLE BORDER="0" CELLSPACING="0" CELLPADDING="0" BGCOLOR="#FFFFFF" WIDTH="100%" style="border-style: solid; border-width: 1px; border-color: #6E89AE;padding: 10px;;"><TR><TD><TABLE BORDER="0" CELLSPACING="0" CELLPADDING="0" WIDTH="100%"><TR><TD><table width="100%" border="0" cellpadding="0" cellspacing="0"><tr><td width="100%"><table width="100%" class="C"><colgroup><col width="100%"></colgroup>
<tr><td class="D"><p class="E">String</p>
</td>
</tr>
</table></td>
</tr></table>
<p class="F">&nbsp;</p>
<p id="String::class" class="G"><span class="H">class</span>&nbsp;<span class="I">String</span>&nbsp;:&nbsp;<span class="H">public</span>&nbsp;<span class="J">Moveable</span><span class="H">&lt;</span><span class="I">String</span>, <a href="AString"><u>AString</u></a><span class="H">&lt;</span><a href="String0"><u>String0</u></a><span class="H">&gt;</span>&nbsp;&gt;&nbsp;</p>
<p class="K">String is a value class that contains an array of characters (or bytes). It is designed to have fast copy operations. The array of characters is zero terminated. String provides non-mutable access to the array of characters. String can store 8 bit encoded string or an UTF-8 encoded string. For UTF-8 strings, however, String works with raw 8 bit values - there are not automatic conversions performed e.g. in operator[]. If you need to access individual UTF-8 characters, the best practice in most cases is to convert it to WString (and eventually back after processing).</p>
<p class="K">String is also often used to store raw binary data.</p>
<p class="K">WString is similar to String, but it uses 32 bit encoding. String and WString share a number of common functions through the AString interface.</p>
<p class="F">&nbsp;</p>
<p class="A">&nbsp;</p>
<table width="100%" border="0" cellpadding="0" cellspacing="0"><tr><td width="100%"><table width="100%" class="L"><colgroup><col width="100%"></colgroup>
<tr><td class="M"><p class="N">Constructor Detail</p>
</td>
</tr>
</table></td>
</tr></table>
<p class="F">&nbsp;</p>
<p id="String::String()" class="O"><span class="I">String</span>()</p>
<p class="P">Default constructor. Constructs empty <span class="I">String</span>.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="String::String(const String&)" class="O"><span class="I">String</span>(<span class="H">const</span>&nbsp;<span class="I">String</span><span class="H">&amp;</span>&nbsp;<span class="J">s</span>)</p>
<p class="P">Default copy constructor.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Upp::String::String(Upp::String&&)" class="O"><span class="I">String</span>(<span class="I">String</span><span class="H">&amp;&amp;</span>&nbsp;<span class="J">s</span>)</p>
<p class="P">Pick constructor.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="String::String(const char*)" class="O"><span class="I">String</span>(<span class="H">const</span>&nbsp;<span class="H">char</span>&nbsp;*<span class="J">s</span>)</p>
<p class="P">Creates a copy of zero terminated string <span class="J">s</span>.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="String::String(const char*,int)" class="O"><span class="I">String</span>(<span class="H">const</span>&nbsp;<span class="H">char</span>&nbsp;*<span class="J">s</span>, <span class="H">int</span>&nbsp;<span class="J">n</span>)</p>
<p class="P">Constructs a string equal to first <span class="J">n</span> characters of string <span class="J">s</span>. Zero characters are included.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="String::String(const String&,int)" class="O"><span class="I">String</span>(<span class="H">const</span>&nbsp;<span class="I">String</span><span class="H">&amp;</span>&nbsp;<span class="J">s</span>, <span class="H">int</span>&nbsp;<span class="J">n</span>)</p>
<p class="P">Constructs a string equal to first <span class="J">n</span> characters of String <span class="J">s</span>. &nbsp;Zero characters are included.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="String::String(const byte*,int)" class="O"><span class="I">String</span>(<span class="H">const</span>&nbsp;<a href="byte"><u>byte</u></a>&nbsp;*<span class="J">s</span>, <span class="H">int</span>&nbsp;<span class="J">n</span>)</p>
<p class="P">Constructs a string equal to first <span class="J">n</span> bytes of <span class="J">s</span>. Zero characters are included.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="String::String(const char*,const char*)" class="O"><span class="I">String</span>(<span class="H">const</span>&nbsp;<span class="H">char</span>&nbsp;*<span class="J">s</span>, <span class="H">const</span>&nbsp;<span class="H">char</span>&nbsp;*<span class="J">lim</span>)</p>
<p class="P">Constructs a string equal to first <span class="J">lim</span> - <span class="J">s</span> characters of <span class="J">s</span>. Zero characters are included.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="String::String(int,int)" class="O"><span class="I">String</span>(<span class="H">int</span>&nbsp;<span class="J">chr</span>, <span class="H">int</span>&nbsp;<span class="J">count</span>)</p>
<p class="P">Constructs a string consisting of <span class="J">count</span> characters equal to <span class="J">chr</span>. <span class="J">chr</span> can be zero.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="String::String(StringBuffer&)" class="O"><span class="I">String</span>(<a href="StringBuffer"><u>StringBuffer</u></a><span class="H">&amp;</span>&nbsp;<span class="J">b</span>)</p>
<p class="P">Constructs a string from <span class="J">b</span>. <span class="J">b</span> is emptied by this operation.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="String::String(const Nuller&)" class="O"><span class="I">String</span>(<span class="H">const</span>&nbsp;<a href="Nuller"><u>Nuller</u></a><span class="H">&amp;</span>)</p>
<p class="P">Constructs empty <span class="I">String</span>. This variant is important to allow assigning <span class="I">Null </span>to <span class="I">String </span>(which is same as assigning the empty <span class="I">String</span>).</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="String::String(const string&)" class="O"><span class="I">String</span>(<span class="H">const</span>&nbsp;<a href="http://en.cppreference.com/w/cpp/string/basic_string"><u>std::string</u></a><span class="H">&amp;</span>&nbsp;<span class="J">s</span>)</p>
<p class="P">Constructor to achieve minimal STL compatibility.</p>
<p class="F">&nbsp;</p>
<p class="A">&nbsp;</p>
<table width="100%" border="0" cellpadding="0" cellspacing="0"><tr><td width="100%"><table width="100%" class="L"><colgroup><col width="100%"></colgroup>
<tr><td class="M"><p class="N">Public Member List</p>
</td>
</tr>
</table></td>
</tr></table>
<p class="F">&nbsp;</p>
<p id="String::Shrink()" class="O"><span class="H">void</span>&nbsp;<span class="I">Shrink</span>()</p>
<p class="P">Reduces memory used by string to minimum (size optimization).</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="String::GetCharCount()const" class="Q">int<span class="R">&nbsp;</span><span class="S">GetCharCount</span><span class="R">()&nbsp;</span>const</p>
<p class="P">Returns a number of characters contained in String. This is equal GetCount() if default charset is not UTF-8, but different for UTF-8 where it returns a number of unicode codepoints. It is faster equivalent of ToWString().GetCount().</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="String::ToWString()const" class="Q"><a href="WString"><span class="R"><u>WString</u></span></a><span class="R">&nbsp;</span><span class="S">ToWString</span><span class="R">()&nbsp;</span>const</p>
<p class="P">Convert String to WString using current default character set.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="String::ToString()const" class="Q">const<span class="R">&nbsp;</span><a href="String"><span class="R"><u>String</u></span></a>&amp;<span class="R">&nbsp;</span><span class="S">ToString</span><span class="R">()&nbsp;</span>const</p>
<p class="P">Returns *this. Useful because ToString is standard method to convert concrete type to text, used by AsString template (and therefore by operator &lt;&lt; as well).</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="String::GetVoid()" class="O"><span class="H">static</span> <a href="String"><u>String</u></a>&nbsp;<span class="I">GetVoid</span>()</p>
<p class="P">Returns special Void value. This value is same as empty string, but IsVoid method returns true for it. It can be used in special scenarios where client code needs to distinguish between two empty values (let us say Void is &quot;more empty&quot;...). For example, LoadFile returns Void string if file failed to load, but normal empty string if it is empty.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="String::IsVoid()const" class="Q">bool<span class="R">&nbsp;</span><span class="S">IsVoid</span><span class="R">()&nbsp;</span>const</p>
<p class="P">Returns true if String is special value returned by <span class="I">GetVoid</span>.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="String0::IsEqual(const String0&)const" class="Q">bool<span class="R">&nbsp;</span><span class="S">IsEqual</span><span class="R">(</span>const<span class="R">&nbsp;</span><a href="String0"><span class="R"><u>String</u></span></a>&amp;<span class="R">&nbsp;</span><span class="J">s</span><span class="R">)&nbsp;</span>const</p>
<p class="P">Return true if string is equal to <span class="J">s</span>.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="String0::Compare(const String0&)const" class="Q">int<span class="R">&nbsp;</span><span class="S">Compare</span><span class="R">(</span>const<span class="R">&nbsp;</span><a href="String0"><span class="R"><u>String0</u></span></a>&amp;<span class="R">&nbsp;</span><span class="J">s</span><span class="R">)&nbsp;</span>const</p>
<p class="P">Lexicographic comparison, return -1 if this string is lower, 0 for equality, 1 if this string is greater. Individual characters are compared as unsigned integer values.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="String0::GetHashValue()const" class="Q">unsigned<span class="R">&nbsp;</span><span class="S">GetHashValue</span><span class="R">()&nbsp;</span>const</p>
<p class="P">Returns the hash value of the string.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="String0::Cat(int)" class="O"><span class="H">void</span>&nbsp;<span class="I">Cat</span>(<span class="H">int</span>&nbsp;<span class="J">c</span>)</p>
<p id="String::operator+=(char)" class="O"><span class="H">const</span>&nbsp;<a href="String"><u>String</u></a><span class="H">&amp;</span>&nbsp;<span class="I">operator+=</span>(<span class="H">char</span>&nbsp;<span class="J">c</span>)</p>
<p class="P">Appends single character <span class="J">c</span>. This operations has constant amortized time (in other words, internal space used by implementation grows exponentially, like with Vector or std::vector). <span class="J">c</span> can be zero.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="String0::Cat(const char*,int)" class="O"><span class="H">void</span>&nbsp;<span class="I">Cat</span>(<span class="H">const</span>&nbsp;<span class="H">char</span>&nbsp;*<span class="J">s</span>, <span class="H">int</span>&nbsp;<span class="J">len</span>)</p>
<p class="P">Appends <span class="J">len</span> characters from string <span class="J">s</span> (<span class="J">s </span>can contain zero characters).</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="String0::Set(int,int)" class="O"><span class="H">void</span>&nbsp;<span class="I">Set</span>(<span class="H">int</span>&nbsp;<span class="J">i</span>, <span class="H">int</span>&nbsp;<span class="J">chr</span>)</p>
<p class="P">Replace character at position <span class="J">i</span> with <span class="J">chr</span>.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="String0::Trim(int)" class="O"><span class="H">void</span>&nbsp;<span class="I">Trim</span>(<span class="H">int</span>&nbsp;<span class="J">pos</span>)</p>
<p class="P">Sets the number of characters (length) to <span class="J">pos</span>.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="String0::Begin()const" class="Q">const<span class="R">&nbsp;</span>char<span class="R">&nbsp;*</span><span class="S">Begin</span><span class="R">()&nbsp;</span>const</p>
<p class="P">Returns a pointer to the first character.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="String0::End()const" class="Q">const<span class="R">&nbsp;</span>char<span class="R">&nbsp;*</span><span class="S">End</span><span class="R">()&nbsp;</span>const</p>
<p class="P">Returns a pointer to ending zero.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="String0::Remove(int,int)" class="O"><span class="H">void</span>&nbsp;<span class="I">Remove</span>(<span class="H">int</span>&nbsp;<span class="J">pos</span>, <span class="H">int</span>&nbsp;<span class="J">count</span>&nbsp;=&nbsp;<span class="T">1</span>)</p>
<p class="P">Removes <span class="J">count</span> element starting at position <span class="J">pos</span>.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="String0::Clear()" class="O"><span class="H">void</span>&nbsp;<span class="I">Clear</span>()</p>
<p class="P">Empties the string.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="String0::GetCount()const" class="Q">int<span class="R">&nbsp;</span><span class="S">GetCount</span><span class="R">()&nbsp;</span>const</p>
<p id="String0::GetLength()const" class="Q">int<span class="R">&nbsp;</span><span class="S">GetLength</span><span class="R">()&nbsp;</span>const</p>
<p class="P">Returns the number of characters.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="String0::GetAlloc()const" class="Q">int<span class="R">&nbsp;</span><span class="S">GetAlloc</span><span class="R">()&nbsp;</span>const</p>
<p class="P">Returns the number of allocated characters (maximum string length before it has to grow) </p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="String0::Reserve(int)" class="O"><span class="H">void</span>&nbsp;<span class="I">Reserve</span>(<span class="H">int</span>&nbsp;<span class="J">r</span>)</p>
<p class="P">Reserves <span class="J">r</span> characters of internal storage for future concatenation operations.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="String::operator+=(const char*)" class="O"><span class="H">const</span>&nbsp;<a href="String"><u>String</u></a><span class="H">&amp;</span>&nbsp;<span class="I">operator+=</span>(<span class="H">const</span>&nbsp;<span class="H">char</span>&nbsp;*<span class="J">s</span>)</p>
<p id="String::operator+=(const String&)" class="O"><span class="H">const</span>&nbsp;<a href="String"><u>String</u></a><span class="H">&amp;</span>&nbsp;<span class="I">operator+=</span>(<span class="H">const</span>&nbsp;<a href="String"><u>String</u></a><span class="H">&amp;</span>&nbsp;<span class="J">s</span>)</p>
<p class="P">Appends a zero terminated string <span class="J">s</span>.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="String::operator=(const String&)" class="O"><a href="String"><u>String</u></a><span class="H">&amp;</span>&nbsp;<span class="I">operator=</span>(<span class="H">const</span>&nbsp;<a href="String"><u>String</u></a><span class="H">&amp;</span>&nbsp;<span class="J">s</span>)</p>
<p class="P">Assigns another string <span class="J">s</span>. This operations is relatively fast and does not depend on the length of string.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Upp::String::operator=(Upp::String&&)" class="O"><a href="Upp::String"><u>String</u></a><span class="H">&amp;</span>&nbsp;<span class="I">operator=</span>(<a href="Upp::String"><u>String</u></a><span class="H">&amp;&amp;</span>&nbsp;<span class="J">s</span>)</p>
<p class="P">Pick assignment.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="String::operator=(const char*)" class="O"><a href="String"><u>String</u></a><span class="H">&amp;</span>&nbsp;<span class="I">operator=</span>(<span class="H">const</span>&nbsp;<span class="H">char</span>&nbsp;*<span class="J">s</span>)</p>
<p class="P">Assign a zero terminated string <span class="J">s</span>.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="String::operator=(StringBuffer&)" class="O"><a href="String"><u>String</u></a><span class="H">&amp;</span>&nbsp;<span class="I">operator=</span>(<a href="StringBuffer"><u>StringBuffer</u></a><span class="H">&amp;</span>&nbsp;<span class="J">b</span>)</p>
<p class="P">Assigns the content of <span class="I">StringBuffer</span>. After the operation,b is emptied.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="String::operator<<=(const String&)" class="O"><a href="String"><u>String</u></a><span class="H">&amp;</span>&nbsp;<span class="I">operator&lt;&lt;=</span>(<span class="H">const</span>&nbsp;<a href="String"><u>String</u></a><span class="H">&amp;</span>&nbsp;<span class="J">s</span>)</p>
<p class="P">&quot;Deep&quot; assignment. It is equivalent of standard assignment followed by <span class="I">Shrink </span>operation (in other words, internal buffer gets reallocated to the exact size of source).</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="String::ToStd()const" class="Q"><a href="http://en.cppreference.com/w/cpp/string/basic_string"><span class="R"><u>std::string</u></span></a><span class="R">&nbsp;</span><span class="S">ToStd</span><span class="R">()&nbsp;</span>const</p>
<p class="P">Converts String to std::string.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="String0::operator const char*()const" class="Q">operator<span class="R">&nbsp;</span>const<span class="R">&nbsp;</span>char<span class="R">&nbsp;*()&nbsp;</span>const</p>
<p id="String0::operator~()const" class="Q">const<span class="R">&nbsp;</span>char<span class="R">&nbsp;*</span><span class="S">operator~</span><span class="R">()&nbsp;</span>const</p>
<p class="P">Returns <span class="I">Begin</span>().</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="String0::operator[](int)const" class="Q">int<span class="R">&nbsp;</span><span class="S">operator[]</span><span class="R">(</span>int<span class="R">&nbsp;</span><span class="J">i</span><span class="R">)&nbsp;</span>const</p>
<p class="U"><span class="V">Returns the character at position </span>i.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Upp::String::Make(int,Maker)" class="O"><span class="H">template</span>&nbsp;&lt;<span class="H">class</span>&nbsp;<span class="W">Maker</span>&gt;&nbsp;<span class="H">static</span>&nbsp;<a href="Upp::String"><u>String</u></a>&nbsp;<span class="I">Make</span>(<span class="H">int</span>&nbsp;<span class="J">alloc</span>, <span class="W">Maker</span>&nbsp;<span class="J">m</span>)</p>
<p class="P">Optimized static method for creating Strings. This method creates internal buffer of at least <span class="J">alloc</span> and then invokes lambda <span class="J">m</span> passing the char * pointer to the internal buffer as lambda parameter. Lambda is then supposed to fill the characters to this buffer and return the length of string (which must be &lt;= <span class="J">alloc</span>). For the best performance, <span class="J">alloc</span> should be constant.</p>
<p class="A">&nbsp;</p>
<p class="A">&nbsp;</p>
<table width="100%" border="0" cellpadding="0" cellspacing="0"><tr><td width="100%"><table width="100%" class="C"><colgroup><col width="100%"></colgroup>
<tr><td class="D"><p class="E">WString</p>
</td>
</tr>
</table></td>
</tr></table>
<p class="F">&nbsp;</p>
<p id="WString::class" class="G"><span class="H">class</span>&nbsp;<span class="I">WString</span>&nbsp;:&nbsp;<span class="H">public</span>&nbsp;<span class="J">Moveable</span><span class="H">&lt;</span><span class="I">WString</span>, <a href="AString"><u>AString</u></a><span class="H">&lt;</span><a href="WString0"><u>WString0</u></a><span class="H">&gt;</span>&nbsp;&gt;&nbsp;</p>
<p class="K">WString is similar to String, but it uses 16 bit Ucs2 encoding. String and WString share a number of common functions through the AString interface.</p>
<p class="F">&nbsp;</p>
<p class="A">&nbsp;</p>
<table width="100%" border="0" cellpadding="0" cellspacing="0"><tr><td width="100%"><table width="100%" class="L"><colgroup><col width="100%"></colgroup>
<tr><td class="M"><p class="N">Constructor Detail</p>
</td>
</tr>
</table></td>
</tr></table>
<p class="F">&nbsp;</p>
<p id="WString::WString()" class="O"><span class="I">WString</span>()</p>
<p class="P">Default constructor. Constructs empty <span class="I">WString</span>.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="WString::WString(const WString&)" class="O"><span class="I">WString</span>(<span class="H">const</span>&nbsp;<span class="I">WString</span><span class="H">&amp;</span>&nbsp;<span class="J">s</span>)</p>
<p class="P">Default copy constructor.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="WString::WString(const wchar*)" class="O"><span class="I">WString</span>(<span class="H">const</span>&nbsp;<a href="wchar"><u>wchar</u></a>&nbsp;*<span class="J">s</span>)</p>
<p class="P">Creates a copy of zero terminated string <span class="J">s</span>.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="WString::WString(const char*)" class="O"><span class="I">WString</span>(<span class="H">const</span>&nbsp;<span class="H">char</span>&nbsp;*<span class="J">s</span>)</p>
<p class="P">Creates a copy of zero terminated string <span class="J">s</span>.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="WString::WString(const WString&,int)" class="O"><span class="I">WString</span>(<span class="H">const</span>&nbsp;<span class="I">WString</span><span class="H">&amp;</span>&nbsp;<span class="J">s</span>, <span class="H">int</span>&nbsp;<span class="J">n</span>)</p>
<p class="P">Constructs a string equal to first <span class="J">n</span> characters of <span class="I">WString</span> <span class="J">s</span> (<span class="J">s </span>can contain zero characters).</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="WString::WString(const wchar*,int)" class="O"><span class="I">WString</span>(<span class="H">const</span>&nbsp;<a href="wchar"><u>wchar</u></a>&nbsp;*<span class="J">s</span>, <span class="H">int</span>&nbsp;<span class="J">n</span>)</p>
<p class="P">Constructs a string equal to first <span class="J">n</span> characters of <span class="J">s </span>(<span class="J">s </span>can contain zero characters).</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="WString::WString(const wchar*,const wchar*)" class="O"><span class="I">WString</span>(<span class="H">const</span>&nbsp;<a href="wchar"><u>wchar</u></a>&nbsp;*<span class="J">s</span>, <span class="H">const</span>&nbsp;<a href="wchar"><u>wchar</u></a>&nbsp;*<span class="J">lim</span>)</p>
<p class="P">Constructs a string equal to first <span class="J">lim</span> - <span class="J">s</span> characters of <span class="J">s</span> (<span class="J">s </span>can contain zero characters).</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="WString::WString(const char*,int)" class="O"><span class="I">WString</span>(<span class="H">const</span>&nbsp;<span class="H">char</span>&nbsp;*<span class="J">s</span>, <span class="H">int</span>&nbsp;<span class="J">n</span>)</p>
<p class="P">Constructs a string equal to first <span class="J">n</span> characters of zero terminated string <span class="J">s </span>(<span class="J">s </span>can contain zero characters).</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="WString::WString(const char*,const char*)" class="O"><span class="I">WString</span>(<span class="H">const</span>&nbsp;<span class="H">char</span>&nbsp;*<span class="J">s</span>, <span class="H">const</span>&nbsp;<span class="H">char</span>&nbsp;*<span class="J">lim</span>)</p>
<p class="P">Constructs a string equal to first <span class="J">n</span> characters of zero terminated string <span class="J">s </span>(<span class="J">s </span>can contain zero characters).</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="WString::WString(int,int)" class="O"><span class="I">WString</span>(<span class="H">int</span>&nbsp;<span class="J">chr</span>, <span class="H">int</span>&nbsp;<span class="J">count</span>)</p>
<p class="P">Constructs a string consisting of <span class="J">count</span> characters equal to <span class="J">chr</span>. <span class="J">chr</span> can be zero.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="WString::WString(WStringBuffer&)" class="O"><span class="I">WString</span>(<a href="WStringBuffer"><u>WStringBuffer</u></a><span class="H">&amp;</span>&nbsp;<span class="J">b</span>)</p>
<p class="P">Constructs a string from <span class="J">b</span>. <span class="J">b</span> is emptied by this operation.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="WString::WString(const Nuller&)" class="O"><span class="I">WString</span>(<span class="H">const</span>&nbsp;<a href="Nuller"><u>Nuller</u></a><span class="H">&amp;</span>)</p>
<p class="P">Constructs empty <span class="I">WString</span>. This variant is important to allow assigning <span class="I">Null</span> to <span class="I">WString</span> (which is same as assigning the empty <span class="I">WString</span>).</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="WString::WString(const wstring&)" class="O"><span class="I">WString</span>(<span class="H">const</span>&nbsp;std::wstring<span class="H">&amp;</span>&nbsp;<span class="J">s</span>)</p>
<p class="P">Constructor to achieve minimal STL compatibility.</p>
<p class="F">&nbsp;</p>
<p class="A">&nbsp;</p>
<table width="100%" border="0" cellpadding="0" cellspacing="0"><tr><td width="100%"><table width="100%" class="L"><colgroup><col width="100%"></colgroup>
<tr><td class="M"><p class="N">Public Member List</p>
</td>
</tr>
</table></td>
</tr></table>
<p class="F">&nbsp;</p>
<p id="WString::Shrink()" class="O"><span class="H">void</span>&nbsp;<span class="I">Shrink</span>()</p>
<p class="P">Reduces memory used by string to minimum (size optimization).</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="WString::ToString()const" class="Q"><a href="String"><span class="R"><u>String</u></span></a><span class="R">&nbsp;</span><span class="S">ToString</span><span class="R">()&nbsp;</span>const</p>
<p class="P">Converts <span class="I">WString </span>to <span class="I">String </span>using current default character set. Also serves as standard text conversion (for <span class="I">AsString</span> and <span class="I">operator&lt;&lt;</span> templates).</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="WString::GetVoid()" class="O"><span class="H">static</span> <a href="WString"><u>WString</u></a>&nbsp;<span class="I">GetVoid</span>()</p>
<p class="P">Returns special Void value. This value is same as empty string, but IsVoid method returns true for it. It can be used in special scenarios where client code needs to distinguish between two empty values (let us say Void is &quot;more empty&quot;...). For example, LoadFile returns Void string if file failed to load, but normal empty string if it is empty.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="WString::IsVoid()const" class="Q">bool<span class="R">&nbsp;</span><span class="S">IsVoid</span><span class="R">()&nbsp;</span>const</p>
<p class="P">Returns true if String is special value returned by <span class="I">GetVoid</span>.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="WString0::Begin()const" class="Q">const<span class="R">&nbsp;</span><a href="wchar"><span class="R"><u>wchar</u></span></a><span class="R">&nbsp;*</span><span class="S">Begin</span><span class="R">()&nbsp;</span>const</p>
<p class="P">Returns a pointer to the first character.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="WString0::End()const" class="Q">const<span class="R">&nbsp;</span><a href="wchar"><span class="R"><u>wchar</u></span></a><span class="R">&nbsp;*</span><span class="S">End</span><span class="R">()&nbsp;</span>const</p>
<p class="P">Returns a pointer to ending zero.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="WString0::GetCount()const" class="Q">int<span class="R">&nbsp;</span><span class="S">GetCount</span><span class="R">()&nbsp;</span>const</p>
<p id="WString0::GetLength()const" class="Q">int<span class="R">&nbsp;</span><span class="S">GetLength</span><span class="R">()&nbsp;</span>const</p>
<p class="P">Returns the number of characters.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="WString0::GetAlloc()const" class="Q">int<span class="R">&nbsp;</span><span class="S">GetAlloc</span><span class="R">()&nbsp;</span>const</p>
<p class="P">Returns the number of allocated characters (maximum string length before it has to grow) </p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="WString0::Cat(int)" class="O"><span class="H">void</span>&nbsp;<span class="I">Cat</span>(<span class="H">int</span>&nbsp;<span class="J">c</span>)</p>
<p class="P">Appends single character <span class="J">c</span>. This operations has constant amortized time (in other words, internal space used by implementation grows exponentially, like with Vector or std::vector).</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="WString0::Cat(const wchar*,int)" class="O"><span class="H">void</span>&nbsp;<span class="I">Cat</span>(<span class="H">const</span>&nbsp;<a href="wchar"><u>wchar</u></a>&nbsp;*<span class="J">s</span>, <span class="H">int</span>&nbsp;<span class="J">length</span>)</p>
<p class="P">Appends <span class="J">len</span> characters from string <span class="J">s</span> (<span class="J">s </span>can contain zero characters).</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="WString0::GetHashValue()const" class="Q">hash_t<span class="R">&nbsp;</span><span class="S">GetHashValue</span><span class="R">()&nbsp;</span>const</p>
<p class="P">Returns the hash value of the string.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="WString0::IsEqual(const WString0&)const" class="Q">bool<span class="R">&nbsp;</span><span class="S">IsEqual</span><span class="R">(</span>const<span class="R">&nbsp;</span><a href="WString0"><span class="R"><u>WString</u></span></a>&amp;<span class="R">&nbsp;</span><span class="J">s</span><span class="R">)&nbsp;</span>const</p>
<p class="P">Return true if string is equal to <span class="J">s</span>.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="WString0::Compare(const WString0&)const" class="Q">int<span class="R">&nbsp;</span><span class="S">Compare</span><span class="R">(</span>const<span class="R">&nbsp;</span><a href="WString0"><span class="R"><u>WString</u></span></a>&amp;<span class="R">&nbsp;</span><span class="J">s</span><span class="R">)&nbsp;</span>const</p>
<p class="P">Lexicographic comparison, return -1 if this string is lower, 0 for equality, 1 if this string is greater. Individual characters are compared as unsigned integer values.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="WString0::Remove(int,int)" class="O"><span class="H">void</span>&nbsp;<span class="I">Remove</span>(<span class="H">int</span>&nbsp;<span class="J">pos</span>, <span class="H">int</span>&nbsp;<span class="J">count</span>&nbsp;=&nbsp;<span class="T">1</span>)</p>
<p class="P">Removes <span class="J">count</span> element starting at position <span class="J">pos</span>.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="WString0::Insert(int,const wchar*,int)" class="O"><span class="H">void</span>&nbsp;<span class="I">Insert</span>(<span class="H">int</span>&nbsp;<span class="J">pos</span>, <span class="H">const</span>&nbsp;<a href="wchar"><u>wchar</u></a>&nbsp;*<span class="J">s</span>, <span class="H">int</span>&nbsp;<span class="J">count</span>)</p>
<p class="P">Inserts first <span class="J">count</span> characters of <span class="J">s</span> at position <span class="J">pos</span>.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="WString0::Clear()" class="O"><span class="H">void</span>&nbsp;<span class="I">Clear</span>()</p>
<p class="P">Empties the string.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="WString0::Set(int,int)" class="O"><span class="H">void</span>&nbsp;<span class="I">Set</span>(<span class="H">int</span>&nbsp;<span class="J">pos</span>, <span class="H">int</span>&nbsp;<span class="J">ch</span>)</p>
<p class="P">Replace character at position <span class="J">pos</span> &nbsp;with <span class="J">ch</span>.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="WString0::Trim(int)" class="O"><span class="H">void</span>&nbsp;<span class="I">Trim</span>(<span class="H">int</span>&nbsp;<span class="J">pos</span>)</p>
<p class="P">Sets the number of characters (length) to <span class="J">pos</span>.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="WString::ToStd()const" class="Q"><a href="http://en.cppreference.com/w/cpp/string/basic_string"><span class="R"><u>std::wstring</u></span></a><span class="R">&nbsp;</span><span class="S">ToStd</span><span class="R">()&nbsp;</span>const</p>
<p class="P">Converts WString to std::string.</p>
<p class="A">&nbsp;</p>
<p class="A">&nbsp;</p>
<table width="100%" border="0" cellpadding="0" cellspacing="0"><tr><td width="100%"><table width="100%" class="C"><colgroup><col width="100%"></colgroup>
<tr><td class="D"><p class="E">AString</p>
</td>
</tr>
</table></td>
</tr></table>
<p class="F">&nbsp;</p>
<p id="noref" class="X">template<span class="R">&nbsp;&lt;</span>class<span class="R">&nbsp;</span><span class="J">B</span>&gt;</p>
<p id="AString::class" class="Y"><span class="Z">class</span><span class="V">&nbsp;</span><span class="R">AString</span><span class="V">&nbsp;:&nbsp;</span><span class="Z">public</span><span class="V">&nbsp;</span>B</p>
<p class="K">A class that implements behavior common to both String and WString.</p>
<p class="F">&nbsp;</p>
<p class="A">&nbsp;</p>
<table width="100%" border="0" cellpadding="0" cellspacing="0"><tr><td width="100%"><table width="100%" class="L"><colgroup><col width="100%"></colgroup>
<tr><td class="M"><p class="N">Public Member List</p>
</td>
</tr>
</table></td>
</tr></table>
<p class="F">&nbsp;</p>
<p id="AString::Clear()" class="O"><span class="H">void</span>&nbsp;<span class="I">Clear</span>()</p>
<p class="P">Clears the content of the string.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="AString::GetLength()const" class="Q">int<span class="R">&nbsp;</span><span class="S">GetLength</span><span class="R">()&nbsp;</span>const</p>
<p class="P">Returns the length of the string.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="AString::IsEmpty()const" class="Q">bool<span class="R">&nbsp;</span><span class="S">IsEmpty</span><span class="R">()&nbsp;</span>const</p>
<p class="P">Return true if the length of the string is zero.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="AString::End()const" class="Q">const<span class="R">&nbsp;</span><a href="AString::tchar"><span class="R"><u>tchar</u></span></a><span class="R">&nbsp;*</span><span class="S">End</span><span class="R">()&nbsp;</span>const</p>
<p class="P">Returns a pointer to the end of the string.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="AString::Last()const" class="Q">const<span class="R">&nbsp;</span><a href="AString::tchar"><span class="R"><u>tchar</u></span></a><span class="R">&nbsp;*</span><span class="S">Last</span><span class="R">()&nbsp;</span>const</p>
<p class="P">Returns a pointer to the last character in the string. If string is empty, returns a pointer to the ending zero.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="AString::GetIter(int)const" class="Q">const<span class="R">&nbsp;</span><a href="AString::tchar"><span class="R"><u>tchar</u></span></a><span class="R">&nbsp;*</span><span class="S">GetIter</span><span class="R">(</span>int<span class="R">&nbsp;</span><span class="J">i</span><span class="R">)&nbsp;</span>const</p>
<p class="P">Returns a pointer to character index <span class="J">i</span> of the string.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="AString::operator[](int)const" class="Q">int<span class="R">&nbsp;</span><span class="S">operator[]</span><span class="R">(</span>int<span class="R">&nbsp;</span><span class="J">i</span><span class="R">)&nbsp;</span>const</p>
<p class="P">Returns the character with index <span class="J">i</span>.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="AString::operator const tchar*()const" class="Q">operator<span class="R">&nbsp;</span>const<span class="R">&nbsp;tchar&nbsp;*()&nbsp;</span>const</p>
<p id="AString::operator~()const" class="Q">const<span class="R">&nbsp;</span><a href="AString::tchar"><span class="R"><u>tchar</u></span></a><span class="R">&nbsp;*</span><span class="S">operator~</span><span class="R">()&nbsp;</span>const</p>
<p id="AString::operator const void*()const" class="Q">operator<span class="R">&nbsp;</span>const<span class="R">&nbsp;</span>void<span class="R">&nbsp;*()&nbsp;</span>const</p>
<p id="AString::operator const bchar*()const" class="Q">operator<span class="R">&nbsp;</span>const<span class="R">&nbsp;bchar&nbsp;*()&nbsp;</span>const</p>
<p class="P">Same as <span class="I">Begin()</span>.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="AString::Insert(int,int)" class="O"><span class="H">void</span>&nbsp;<span class="I">Insert</span>(<span class="H">int</span>&nbsp;<span class="J">pos</span>, <span class="H">int</span>&nbsp;<span class="J">c</span>)</p>
<p id="AString::Insert(int,const AString::tchar*,int)" class="O"><span class="H">void</span>&nbsp;<span class="I">Insert</span>(<span class="H">int</span>&nbsp;<span class="J">pos</span>, <span class="H">const</span>&nbsp;<a href="AString::tchar"><u>tchar</u></a>&nbsp;*<span class="J">s</span>, <span class="H">int</span>&nbsp;<span class="J">count</span>)</p>
<p id="AString::Insert(int,const AString::String&)" class="O"><span class="H">void</span>&nbsp;<span class="I">Insert</span>(<span class="H">int</span>&nbsp;<span class="J">pos</span>, <span class="H">const</span>&nbsp;<a href="AString::String"><u>String</u></a><span class="H">&amp;</span>&nbsp;<span class="J">s</span>)</p>
<p id="AString::Insert(int,const char*)" class="O"><span class="H">void</span>&nbsp;<span class="I">Insert</span>(<span class="H">int</span>&nbsp;<span class="J">pos</span>, <span class="H">const</span>&nbsp;<span class="H">char</span>&nbsp;*<span class="J">s</span>)</p>
<p class="P">Inserts item <span class="J">c</span>/<span class="J">s</span> at position <span class="J">pos</span> (<span class="J">count</span> times).</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Upp::AString::TrimLast(int)" class="O"><span class="H">void</span>&nbsp;<span class="I">TrimLast</span>(<span class="H">int</span>&nbsp;<span class="J">count</span>&nbsp;=&nbsp;<span class="T">1</span>)</p>
<p class="P">Removes <span class="J">count</span> characters from the end of String. Same as Remove(GetCount() - count).</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="AString::Mid(int,int)const" class="Q"><a href="AString::String"><span class="R"><u>String</u></span></a><span class="R">&nbsp;</span><span class="S">Mid</span><span class="R">(</span>int<span class="R">&nbsp;</span><span class="J">pos</span><span class="R">, </span>int<span class="R">&nbsp;</span><span class="J">length</span><span class="R">)&nbsp;</span>const</p>
<p class="P">Returns a substring that begins from <span class="J">pos</span> and with <span class="J">length </span>chars.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="AString::Mid(int)const" class="Q"><a href="AString::String"><span class="R"><u>String</u></span></a><span class="R">&nbsp;</span><span class="S">Mid</span><span class="R">(</span>int<span class="R">&nbsp;</span><span class="J">pos</span><span class="R">)&nbsp;</span>const</p>
<p class="P">Returns a substring that begins from <span class="J">pos</span>.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="AString::Right(int)const" class="Q"><a href="AString::String"><span class="R"><u>String</u></span></a><span class="R">&nbsp;</span><span class="S">Right</span><span class="R">(</span>int<span class="R">&nbsp;</span><span class="J">count</span><span class="R">)&nbsp;</span>const</p>
<p class="P">Returns a substring with <span class="J">count </span>chars beginning from the ens of the string.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="AString::Left(int)const" class="Q"><a href="AString::String"><span class="R"><u>String</u></span></a><span class="R">&nbsp;</span><span class="S">Left</span><span class="R">(</span>int<span class="R">&nbsp;</span><span class="J">count</span><span class="R">)&nbsp;</span>const</p>
<p class="P">Returns a substring with <span class="J">count </span>chars beginning from the begin of the string.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Upp::AString::Find(int,const Upp::AString::tchar*,int)const" class="Q">int<span class="R">&nbsp;</span><span class="S">Find</span><span class="R">(</span>int<span class="R">&nbsp;</span><span class="J">len</span><span class="R">, </span>const<span class="R">&nbsp;</span><a href="Upp::AString::tchar"><span class="R"><u>tchar</u></span></a><span class="R">&nbsp;*</span><span class="J">s</span><span class="R">, </span>int<span class="R">&nbsp;</span><span class="J">from</span><span class="R">)&nbsp;</span>const</p>
<p id="AString::Find(const AString::tchar*,int)const" class="Q">int<span class="R">&nbsp;</span><span class="S">Find</span><span class="R">(</span>const<span class="R">&nbsp;</span><a href="AString::tchar"><span class="R"><u>tchar</u></span></a><span class="R">&nbsp;*</span><span class="J">s</span><span class="R">, </span>int<span class="R">&nbsp;</span><span class="J">from</span><span class="R">&nbsp;=&nbsp;</span><span class="T">0</span><span class="R">)&nbsp;</span>const</p>
<p id="AString::Find(const AString::String&,int)const" class="Q">int<span class="R">&nbsp;</span><span class="S">Find</span><span class="R">(</span>const<span class="R">&nbsp;</span><a href="AString::String"><span class="R"><u>String</u></span></a>&amp;<span class="R">&nbsp;</span><span class="J">s</span><span class="R">, </span>int<span class="R">&nbsp;</span><span class="J">from</span><span class="R">&nbsp;=&nbsp;</span><span class="T">0</span><span class="R">)&nbsp;</span>const</p>
<p class="P">Returns first position of substring <span class="J">s</span> greater than or equal to <span class="J">from</span>, or -1 if <span class="J">s</span> is not found.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="AString::FindAfter(const AString::tchar*,int)const" class="Q">int<span class="R">&nbsp;</span><span class="S">FindAfter</span><span class="R">(</span>const<span class="R">&nbsp;</span><a href="AString::tchar"><span class="R"><u>tchar</u></span></a><span class="R">&nbsp;*</span><span class="J">s</span><span class="R">, </span>int<span class="R">&nbsp;</span><span class="J">from</span><span class="R">&nbsp;=&nbsp;</span><span class="T">0</span><span class="R">)&nbsp;</span>const</p>
<p id="AString::FindAfter(const AString::String&,int)const" class="Q">int<span class="R">&nbsp;</span><span class="S">FindAfter</span><span class="R">(</span>const<span class="R">&nbsp;</span><a href="AString::String"><span class="R"><u>String</u></span></a>&amp;<span class="R">&nbsp;</span><span class="J">s</span><span class="R">, </span>int<span class="R">&nbsp;</span><span class="J">from</span><span class="R">&nbsp;=&nbsp;</span><span class="T">0</span><span class="R">)&nbsp;</span>const</p>
<p class="P">Similiar to Find, but if found, returns position <span class="AA">after</span> the substring found. In other words, if not found returns -1, if found, returns Find(<span class="J">s</span>, <span class="J">from</span>) + length of <span class="J">s</span>.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Upp::AString::ReverseFind(int,const Upp::AString::tchar*,int)const" class="Q">int<span class="R">&nbsp;</span><span class="S">ReverseFind</span><span class="R">(</span>int<span class="R">&nbsp;</span><span class="J">len</span><span class="R">, </span>const<span class="R">&nbsp;</span><a href="Upp::AString::tchar"><span class="R"><u>tchar</u></span></a><span class="R">&nbsp;*</span><span class="J">s</span><span class="R">, </span>int<span class="R">&nbsp;</span><span class="J">from</span><span class="R">)&nbsp;</span>const</p>
<p id="Upp::AString::ReverseFind(const Upp::AString::tchar*,int)const" class="Q">int<span class="R">&nbsp;</span><span class="S">ReverseFind</span><span class="R">(</span>const<span class="R">&nbsp;</span><a href="Upp::AString::tchar"><span class="R"><u>tchar</u></span></a><span class="R">&nbsp;*</span><span class="J">s</span><span class="R">, </span>int<span class="R">&nbsp;</span><span class="J">from</span><span class="R">)&nbsp;</span>const</p>
<p id="Upp::AString::ReverseFind(const Upp::AString::String&,int)const" class="Q">int<span class="R">&nbsp;</span><span class="S">ReverseFind</span><span class="R">(</span>const<span class="R">&nbsp;</span><a href="Upp::AString::String"><span class="R"><u>String</u></span></a>&amp;<span class="R">&nbsp;</span><span class="J">s</span><span class="R">, </span>int<span class="R">&nbsp;</span><span class="J">from</span><span class="R">)&nbsp;</span>const</p>
<p id="Upp::AString::ReverseFind(const Upp::AString::tchar*)const" class="Q">int<span class="R">&nbsp;</span><span class="S">ReverseFind</span><span class="R">(</span>const<span class="R">&nbsp;</span><a href="Upp::AString::tchar"><span class="R"><u>tchar</u></span></a><span class="R">&nbsp;*</span><span class="J">s</span><span class="R">)&nbsp;</span>const</p>
<p id="Upp::AString::ReverseFind(const Upp::AString::String&)const" class="Q">int<span class="R">&nbsp;</span><span class="S">ReverseFind</span><span class="R">(</span>const<span class="R">&nbsp;</span><a href="Upp::AString::String"><span class="R"><u>String</u></span></a>&amp;<span class="R">&nbsp;</span><span class="J">s</span><span class="R">)&nbsp;</span>const</p>
<p class="P">Finds the <span class="AA">last</span> position of <span class="J">s</span> less than <span class="J">from</span>, or -1 if not found.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Upp::AString::ReverseFindAfter(int,const Upp::AString::tchar*,int)const" class="Q">int<span class="R">&nbsp;</span><span class="S">ReverseFindAfter</span><span class="R">(</span>int<span class="R">&nbsp;</span><span class="J">len</span><span class="R">, </span>const<span class="R">&nbsp;</span><a href="Upp::AString::tchar"><span class="R"><u>tchar</u></span></a><span class="R">&nbsp;*</span><span class="J">s</span><span class="R">, </span>int<span class="R">&nbsp;</span><span class="J">from</span><span class="R">)&nbsp;</span>const</p>
<p id="Upp::AString::ReverseFindAfter(const Upp::AString::tchar*,int)const" class="Q">int<span class="R">&nbsp;</span><span class="S">ReverseFindAfter</span><span class="R">(</span>const<span class="R">&nbsp;</span><a href="Upp::AString::tchar"><span class="R"><u>tchar</u></span></a><span class="R">&nbsp;*</span><span class="J">s</span><span class="R">, </span>int<span class="R">&nbsp;</span><span class="J">from</span><span class="R">)&nbsp;</span>const</p>
<p id="Upp::AString::ReverseFindAfter(const Upp::AString::String&,int)const" class="Q">int<span class="R">&nbsp;</span><span class="S">ReverseFindAfter</span><span class="R">(</span>const<span class="R">&nbsp;</span><a href="Upp::AString::String"><span class="R"><u>String</u></span></a>&amp;<span class="R">&nbsp;</span><span class="J">s</span><span class="R">, </span>int<span class="R">&nbsp;</span><span class="J">from</span><span class="R">)&nbsp;</span>const</p>
<p id="Upp::AString::ReverseFindAfter(const Upp::AString::tchar*)const" class="Q">int<span class="R">&nbsp;</span><span class="S">ReverseFindAfter</span><span class="R">(</span>const<span class="R">&nbsp;</span><a href="Upp::AString::tchar"><span class="R"><u>tchar</u></span></a><span class="R">&nbsp;*</span><span class="J">s</span><span class="R">)&nbsp;</span>const</p>
<p id="Upp::AString::ReverseFindAfter(const Upp::AString::String&)const" class="Q">int<span class="R">&nbsp;</span><span class="S">ReverseFindAfter</span><span class="R">(</span>const<span class="R">&nbsp;</span><a href="Upp::AString::String"><span class="R"><u>String</u></span></a>&amp;<span class="R">&nbsp;</span><span class="J">s</span><span class="R">)&nbsp;</span>const</p>
<p class="P">Similar to ReverseFind, but returns position <span class="AA">after</span> the substring found. In other words, if not found returns -1, if found, returns Find(<span class="J">s</span>, <span class="J">from</span>) + length of <span class="J">s</span>.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Upp::AString::Replace(const Upp::AString::tchar*,int,const Upp::AString::tchar*,int)" class="O"><span class="H">void</span>&nbsp;<span class="I">Replace</span>(<span class="H">const</span>&nbsp;<a href="Upp::AString::tchar"><u>tchar</u></a>&nbsp;*<span class="J">find</span>, <span class="H">int</span>&nbsp;<span class="J">findlen</span>, <span class="H">const</span>&nbsp;<a href="Upp::AString::tchar"><u>tchar</u></a>&nbsp;*<span class="J">replace</span>, <span class="H">int</span>&nbsp;<span class="J">replacelen</span>)</p>
<p id="AString::Replace(const AString::String&,const AString::String&)" class="O"><span class="H">void</span>&nbsp;<span class="I">Replace</span>(<span class="H">const</span>&nbsp;<a href="AString::String"><u>String</u></a><span class="H">&amp;</span>&nbsp;<span class="J">find</span>, <span class="H">const</span>&nbsp;<a href="AString::String"><u>String</u></a><span class="H">&amp;</span>&nbsp;<span class="J">replace</span>)</p>
<p id="AString::Replace(const AString::tchar*,const AString::tchar*)" class="O"><span class="H">void</span>&nbsp;<span class="I">Replace</span>(<span class="H">const</span>&nbsp;<a href="AString::tchar"><u>tchar</u></a>&nbsp;*<span class="J">find</span>, <span class="H">const</span>&nbsp;<a href="AString::tchar"><u>tchar</u></a>&nbsp;*<span class="J">replace</span>)</p>
<p id="AString::Replace(const AString::String&,const AString::tchar*)" class="O"><span class="H">void</span>&nbsp;<span class="I">Replace</span>(<span class="H">const</span>&nbsp;<a href="AString::String"><u>String</u></a><span class="H">&amp;</span>&nbsp;<span class="J">find</span>, <span class="H">const</span>&nbsp;<a href="AString::tchar"><u>tchar</u></a>&nbsp;*<span class="J">replace</span>)</p>
<p id="AString::Replace(const AString::tchar*,const AString::String&)" class="O"><span class="H">void</span>&nbsp;<span class="I">Replace</span>(<span class="H">const</span>&nbsp;<a href="AString::tchar"><u>tchar</u></a>&nbsp;*<span class="J">find</span>, <span class="H">const</span>&nbsp;<a href="AString::String"><u>String</u></a><span class="H">&amp;</span>&nbsp;<span class="J">replace</span>)</p>
<p class="P">Replaces substring <span class="J">find</span> with <span class="J">replace </span>string for all times <span class="J">find</span> string appears.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Upp::AString::StartsWith(const Upp::AString::tchar*,int)const" class="Q">bool<span class="R">&nbsp;</span><span class="S">StartsWith</span><span class="R">(</span>const<span class="R">&nbsp;</span><a href="Upp::AString::tchar"><span class="R"><u>tchar</u></span></a><span class="R">&nbsp;*</span><span class="J">s</span><span class="R">, </span>int<span class="R">&nbsp;</span><span class="J">len</span><span class="R">)&nbsp;</span>const</p>
<p id="Upp::AString::StartsWith(const Upp::AString::tchar*)const" class="Q">bool<span class="R">&nbsp;</span><span class="S">StartsWith</span><span class="R">(</span>const<span class="R">&nbsp;</span><a href="Upp::AString::tchar"><span class="R"><u>tchar</u></span></a><span class="R">&nbsp;*</span><span class="J">s</span><span class="R">)&nbsp;</span>const</p>
<p id="Upp::AString::StartsWith(const Upp::AString::String&)const" class="Q">bool<span class="R">&nbsp;</span><span class="S">StartsWith</span><span class="R">(</span>const<span class="R">&nbsp;</span><a href="Upp::AString::String"><span class="R"><u>String</u></span></a>&amp;<span class="R">&nbsp;</span><span class="J">s</span><span class="R">)&nbsp;</span>const</p>
<p class="P">Returns true if string starts with <span class="J">s</span>.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Upp::AString::TrimStart(const Upp::AString::tchar*,int)" class="O"><span class="H">bool</span>&nbsp;<span class="I">TrimStart</span>(<span class="H">const</span>&nbsp;<a href="Upp::AString::tchar"><u>tchar</u></a>&nbsp;*<span class="J">s</span>, <span class="H">int</span>&nbsp;<span class="J">len</span>)</p>
<p id="Upp::AString::TrimStart(const Upp::AString::tchar*)" class="O"><span class="H">bool</span>&nbsp;<span class="I">TrimStart</span>(<span class="H">const</span>&nbsp;<a href="Upp::AString::tchar"><u>tchar</u></a>&nbsp;*<span class="J">s</span>)</p>
<p id="Upp::AString::TrimStart(const Upp::AString::String&)" class="O"><span class="H">bool</span>&nbsp;<span class="I">TrimStart</span>(<span class="H">const</span>&nbsp;<a href="Upp::AString::String"><u>String</u></a><span class="H">&amp;</span>&nbsp;<span class="J">s</span>)</p>
<p class="P">If string starts with <span class="J">s</span>, trims the start to remove it and returns true.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Upp::AString::EndsWith(const Upp::AString::tchar*,int)const" class="Q">bool<span class="R">&nbsp;</span><span class="S">EndsWith</span><span class="R">(</span>const<span class="R">&nbsp;</span><a href="Upp::AString::tchar"><span class="R"><u>tchar</u></span></a><span class="R">&nbsp;*</span><span class="J">s</span><span class="R">, </span>int<span class="R">&nbsp;</span><span class="J">len</span><span class="R">)&nbsp;</span>const</p>
<p id="Upp::AString::EndsWith(const Upp::AString::tchar*)const" class="Q">bool<span class="R">&nbsp;</span><span class="S">EndsWith</span><span class="R">(</span>const<span class="R">&nbsp;</span><a href="Upp::AString::tchar"><span class="R"><u>tchar</u></span></a><span class="R">&nbsp;*</span><span class="J">s</span><span class="R">)&nbsp;</span>const</p>
<p id="Upp::AString::EndsWith(const Upp::AString::String&)const" class="Q">bool<span class="R">&nbsp;</span><span class="S">EndsWith</span><span class="R">(</span>const<span class="R">&nbsp;</span><a href="Upp::AString::String"><span class="R"><u>String</u></span></a>&amp;<span class="R">&nbsp;</span><span class="J">s</span><span class="R">)&nbsp;</span>const</p>
<p class="P">Returns true if string ends with <span class="J">s</span>.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Upp::AString::TrimEnd(const Upp::AString::tchar*,int)" class="O"><span class="H">bool</span>&nbsp;<span class="I">TrimEnd</span>(<span class="H">const</span>&nbsp;<a href="Upp::AString::tchar"><u>tchar</u></a>&nbsp;*<span class="J">s</span>, <span class="H">int</span>&nbsp;<span class="J">len</span>)</p>
<p id="Upp::AString::TrimEnd(const Upp::AString::tchar*)" class="O"><span class="H">bool</span>&nbsp;<span class="I">TrimEnd</span>(<span class="H">const</span>&nbsp;<a href="Upp::AString::tchar"><u>tchar</u></a>&nbsp;*<span class="J">s</span>)</p>
<p id="Upp::AString::TrimEnd(const Upp::AString::String&)" class="O"><span class="H">bool</span>&nbsp;<span class="I">TrimEnd</span>(<span class="H">const</span>&nbsp;<a href="Upp::AString::String"><u>String</u></a><span class="H">&amp;</span>&nbsp;<span class="J">s</span>)</p>
<p class="P">If string ends with <span class="J">s</span>, trims the end to remove it and returns true.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Upp::AString::FindFirstOf(int,const Upp::AString::tchar*,int)const" class="Q">int<span class="R">&nbsp;</span><span class="S">FindFirstOf</span><span class="R">(</span>int<span class="R">&nbsp;</span><span class="J">len</span><span class="R">, </span>const<span class="R">&nbsp;</span><a href="Upp::AString::tchar"><span class="R"><u>tchar</u></span></a><span class="R">&nbsp;*</span><span class="J">set</span><span class="R">, </span>int<span class="R">&nbsp;</span><span class="J">from</span><span class="R">)&nbsp;</span>const</p>
<p class="P">Returns the first position of any character from <span class="J">set</span> starting at <span class="J">from</span>. The number of characters in <span class="J">set</span> is <span class="J">len</span>. Returns -1 if not found.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Upp::AString::FindFirstOf(const Upp::AString::tchar*,int)const" class="Q">int<span class="R">&nbsp;</span><span class="S">FindFirstOf</span><span class="R">(</span>const<span class="R">&nbsp;</span><a href="Upp::AString::tchar"><span class="R"><u>tchar</u></span></a><span class="R">&nbsp;*</span><span class="J">set</span><span class="R">, </span>int<span class="R">&nbsp;</span><span class="J">from</span><span class="R">&nbsp;=&nbsp;</span><span class="T">0</span><span class="R">)&nbsp;</span>const</p>
<p class="P">Returns the first position of any character from zero terminated <span class="J">set</span> starting at <span class="J">from</span>. Returns -1 if not found.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Upp::AString::FindFirstOf(const Upp::AString::String&,int)const" class="Q">int<span class="R">&nbsp;</span><span class="S">FindFirstOf</span><span class="R">(</span>const<span class="R">&nbsp;</span><a href="Upp::AString::String"><span class="R"><u>String</u></span></a>&amp;<span class="R">&nbsp;</span><span class="J">set</span><span class="R">, </span>int<span class="R">&nbsp;</span><span class="J">from</span><span class="R">&nbsp;=&nbsp;</span><span class="T">0</span><span class="R">)&nbsp;</span>const</p>
<p class="P">Returns the first position of any character from <span class="J">set</span> starting at <span class="J">from</span>. Returns -1 if not found.</p>
<p class="P">&nbsp;</p>
<p class="F">&nbsp;</p>
<p class="F">&nbsp;</p>
</TD>
</TR>
</TABLE>
</TD>
</TR>
</TABLE>
<TABLE BORDER="0" WIDTH="100%"><TR><TD></TD>
</TR>
</TABLE>
<TABLE BORDER="0" CELLSPACING="0" CELLPADDING="0" BGCOLOR="#FFFFFF" WIDTH="100%" style="border-style: solid; border-width: 1px; border-color: #6E89AE;padding: 10px;;"><TR><TD><TABLE BORDER="0" CELLSPACING="0" CELLPADDING="0" WIDTH="100%"><TR><TD><p class="A"><span class="B"> </span><a href="www$uppweb$contribweb$en-us.html">Do you want to contribute?</a></p>
</TD>
</TR>
</TABLE>
</TD>
</TR>
</TABLE>
</TD>
</TR>
</TABLE>
<script type="text/javascript">var a={};var p=window.location.pathname.split("/");p=p[p.length-1];var s='<select id="lang" onchange="window.location=document.getElementById(\'lang\').value;">';for(l in a){if(p==l){d=" selected=1"}else{d=""}s+='<option value="'+l+'"'+d+'>'+a[l]+'</option>'}s+='</select>';var d=document.createElement('div');d.innerHTML=s;var c=document.getElementById('langs');c.replaceChild(d,c.firstChild);document.getElementById('langbox').style.display='block';</script></BODY>
