<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML lang="en-us">
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="Generator" CONTENT="U++ HTML Package">
<TITLE>Ctrl :: U++</TITLE>
<STYLE TYPE="text/css"><!--
.A{margin:0px 0px 0px 0px;text-indent:0px;text-align:left;color:#000000;font-family:sans-serif;font-size:10pt;font-weight:normal;font-style:normal;}
.B{font-size:12pt;}
.C{border-collapse:collapse;table-layout:auto;border: 2px solid #000000;}
.D{padding: 3px 5px 3px 5px;border-left: 1px solid #000000;border-top: 1px solid #000000;border-right: 1px solid #000000;border-bottom: 1px solid #000000;background-color:#712A00;vertical-align:middle;}
.E{margin:0px 0px 0px 0px;text-indent:0px;text-align:left;color:#e0e0e0;font-family:sans-serif;font-size:16pt;font-weight:bold;font-style:normal;}
.F{margin:0px 0px 0px 0px;text-indent:0px;text-align:left;color:#000000;font-family:sans-serif;font-size:6pt;font-weight:normal;font-style:normal;}
.G{margin:0px 0px 5px 0px;text-indent:0px;text-align:left;color:#000000;font-family:sans-serif;font-size:12pt;font-weight:normal;font-style:normal;}
.H{color:#0000ff;}
.I{font-weight:bold;}
.J{color:#800000;font-weight:bold;}
.K{margin:8px 0px 0px 0px;text-indent:0px;text-align:left;color:#000000;font-family:sans-serif;font-size:10pt;font-weight:normal;font-style:normal;}
.L{border-collapse:collapse;table-layout:auto;border: 2px solid #808080;}
.M{padding: 3px 5px 3px 5px;border-left: 1px solid #808080;border-top: 1px solid #808080;border-right: 1px solid #808080;border-bottom: 1px solid #808080;background-color:#C0C0C0;vertical-align:middle;}
.N{margin:0px 0px 0px 0px;text-indent:0px;text-align:left;color:#000000;font-family:sans-serif;font-size:10pt;font-weight:bold;font-style:normal;}
.O{font-weight:normal;}
.P{margin:3px 0px 3px 57px;text-indent:0px;text-align:left;color:#000000;font-family:sans-serif;font-size:10pt;font-weight:normal;font-style:normal;}
.Q{color:#800000;font-family:monospace;font-weight:bold;}
.R{font-weight:bold;font-style:italic;}
.S{margin:0px 0px 0px 32px;text-indent:0px;text-align:left;color:#000000;font-family:sans-serif;font-size:10pt;font-weight:bold;font-style:normal;}
.T{margin:0px 0px 0px 32px;text-indent:0px;text-align:left;color:#000000;font-family:sans-serif;font-size:10pt;font-weight:normal;font-style:normal;}
.U{margin:0px 0px 5px 0px;text-indent:0px;text-align:left;color:#404040;font-family:sans-serif;font-size:10pt;font-weight:bold;font-style:normal;}
.V{color:#000000;}
.W{margin:0px 0px 5px 0px;text-indent:0px;text-align:left;color:#000000;font-family:sans-serif;font-size:10pt;font-weight:normal;font-style:normal;}
.X{margin:0px 0px 0px 57px;text-indent:0px;text-align:left;color:#000000;font-family:sans-serif;font-size:10pt;font-weight:normal;font-style:normal;}
.Y{margin:0px 0px 5px 0px;text-indent:0px;text-align:left;color:#0000ff;font-family:sans-serif;font-size:10pt;font-weight:normal;font-style:normal;}
.Z{color:#000000;font-weight:bold;}
.AA{font-style:italic;}
.AB{margin:0px 0px 5px 0px;text-indent:0px;text-align:left;color:#000000;font-family:sans-serif;font-size:10pt;font-weight:bold;font-style:normal;}
.AC{color:#800000;}
.AD{color:#008000;font-weight:bold;}
.AE{margin:0px 0px 5px 0px;text-indent:0px;text-align:left;color:#0000ff;font-family:sans-serif;font-size:10pt;font-weight:bold;font-style:normal;}
.AF{color:#404040;}
.AG{margin:0px 0px 0px 57px;text-indent:0px;text-align:left;color:#000080;font-family:sans-serif;font-size:8pt;font-weight:bold;font-style:normal;}
.AH{margin:0px 0px 0px 57px;text-indent:0px;text-align:left;color:#0000ff;font-family:sans-serif;font-size:10pt;font-weight:normal;font-style:normal;}
.AI{color:#000000;font-style:italic;}
.AJ{margin:3px 0px 3px 57px;text-indent:0px;text-align:left;color:#000000;font-family:sans-serif;font-size:10pt;font-weight:bold;font-style:italic;}
.AK{font-weight:normal;font-style:normal;}
.AL{margin:0px 0px 0px 57px;text-indent:0px;text-align:left;color:#000080;font-family:sans-serif;font-size:10pt;font-weight:bold;font-style:normal;}
.AM{color:#800000;font-style:normal;}
.AN{margin:0px 0px 5px 0px;text-indent:0px;text-align:left;color:#000000;font-family:sans-serif;font-size:12pt;font-weight:bold;font-style:normal;}
.AO{color:#0000ff;font-weight:normal;}
.AP{margin:3px 0px 3px 70px;text-indent:0px;text-align:left;color:#000000;font-family:sans-serif;font-size:10pt;font-weight:normal;font-style:normal;}
a.l1         { text-decoration:none; font-size: 8pt; font-family: sans-serif; font-weight: normal; }
a.l1:link    { color:#000000; }
a.l1:visited { color:#000080; }
a.l1:hover   { color:#9933CC; }
a.l1:active  { color:#000000; }
a.l2         { text-decoration:none; font-size: 12pt; font-family: sans-serif; font-variant: small-caps; }
a.l2:link    { color:#0066FF; }
a.l2:visited { color:#FF6600; }
a.l2:hover   { color:#BC0624; }
a.l2:active  { color:#BC0024; }

-->
</STYLE>
<META NAME="keywords" CONTENT="framework, toolkit, widget, c++, visual, studio, dev-cpp, builder, ide, class, component,wxwidgets, qt, rapid, application, development, rad, mfc, linux, macos, gui, sdl, directx, desktop"><META name="robots" content="index,follow">
<LINK rel="alternate" type="application/rss+xml" title="SVN changes" href="svnchanges.xml">
<LINK rel="shortcut icon" type="image/png" href="favicon.png">
</HEAD><BODY BGCOLOR="#D2D9D2" ALINK="#800000" LINK="#000000" VLINK="#000080"><TABLE BORDER="0" CELLSPACING="0" CELLPADDING="0" WIDTH="100%"><TR><TD COLSPAN="3"><TABLE BORDER="0" CELLSPACING="0" CELLPADDING="0" WIDTH="100%" BGCOLOR="#FFFFFF" style="border: 1px solid #6E89AE;padding-left: 10px;padding-right: 0px;padding-top: 0px;padding-bottom: 0px;"><TR><TD><A HREF="index.html"><IMG SRC="0i.png" ALT="" BORDER="0"></A>
</TD>
<TD ALIGN="RIGHT" VALIGN="BOTTOM" STYLE="padding-bottom: 5px; background-image: url('1i.png')"><span style="font-size: 14pt; font-family: sans-serif;"><script type="text/javascript"><!--
google_ad_client = "pub-1082147624384270";
google_ad_width = 468;
google_ad_height = 60;
google_ad_format = "468x60_as";
google_ad_type = "text_image";
google_ad_channel = "";
google_color_border = "336699";
google_color_bg = "FFFFFF";
google_color_link = "0000FF";
google_color_text = "000000";
google_color_url = "008000";
//--></script>
<script type="text/javascript"
  src="https://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
&nbsp;&nbsp;</span>
</TD>
</TR>
</TABLE>
</TD>
</TR>
</TABLE>
<TABLE BORDER="0" CELLSPACING="0" CELLPADDING="0" WIDTH="100%"><TR><TD COLSPAN="3" BGCOLOR="#D2D9D2" HEIGHT="6"></TD>
</TR>
<TR><TD VALIGN="TOP" ALIGN="CENTER"><TABLE BORDER="0" CELLSPACING="0" CELLPADDING="0" WIDTH="160"><TR><TD ALIGN="CENTER"><TABLE BORDER="0" CELLSPACING="0" CELLPADDING="0" WIDTH="100%" BGCOLOR="#FFFFFF" style="border-style: solid; border-width: 1px; border-color: #6E89AE;padding: 0px"><TR><TD WIDTH="100%" VALIGN="MIDDLE" STYLE="background-image: url('2i.png'); border: 0px solid black; padding-left:12px; padding-right:0px; padding-top:6px; padding-bottom:6px;"><A HREF="www$uppweb$overview$en-us.html" CLASS="l1">Overview</A>
</TD>
</TR>
<TR><TD WIDTH="100%" VALIGN="MIDDLE" STYLE="background-image: url('2i.png'); border: 0px solid black; padding-left:12px; padding-right:0px; padding-top:6px; padding-bottom:6px; border-top: 1px solid #6E89AE;"><A HREF="www$uppweb$examples$en-us.html" CLASS="l1">Examples</A>
</TD>
</TR>
<TR><TD WIDTH="100%" VALIGN="MIDDLE" STYLE="background-image: url('2i.png'); border: 0px solid black; padding-left:12px; padding-right:0px; padding-top:6px; padding-bottom:6px; border-top: 1px solid #6E89AE;"><A HREF="www$uppweb$ss$en-us.html" CLASS="l1">Screenshots</A>
</TD>
</TR>
<TR><TD WIDTH="100%" VALIGN="MIDDLE" STYLE="background-image: url('2i.png'); border: 0px solid black; padding-left:12px; padding-right:0px; padding-top:6px; padding-bottom:6px; border-top: 1px solid #6E89AE;"><A HREF="www$uppweb$comparison$en-us.html" CLASS="l1">Comparisons</A>
</TD>
</TR>
<TR><TD WIDTH="100%" VALIGN="MIDDLE" STYLE="background-image: url('2i.png'); border: 0px solid black; padding-left:12px; padding-right:0px; padding-top:6px; padding-bottom:6px; border-top: 1px solid #6E89AE;"><A HREF="www$uppweb$apps$en-us.html" CLASS="l1">Applications</A>
</TD>
</TR>
<TR><TD WIDTH="100%" VALIGN="MIDDLE" STYLE="background-image: url('2i.png'); border: 0px solid black; padding-left:12px; padding-right:0px; padding-top:6px; padding-bottom:6px; border-top: 1px solid #6E89AE;"><A HREF="www$uppweb$download$en-us.html" CLASS="l1">Download</A>
</TD>
</TR>
<TR><TD WIDTH="100%" VALIGN="MIDDLE" STYLE="background-image: url('2i.png'); border: 0px solid black; padding-left:12px; padding-right:0px; padding-top:6px; padding-bottom:6px; border-top: 1px solid #6E89AE;"><A HREF="www$uppweb$documentation$en-us.html" CLASS="l1">Documentation</A>
</TD>
</TR>
<TR><TD WIDTH="100%" VALIGN="MIDDLE" STYLE="background-image: url('2i.png'); border: 0px solid black; padding-left:12px; padding-right:0px; padding-top:6px; padding-bottom:6px; border-top: 1px solid #6E89AE;"><A HREF="www$uppweb$Tutorials$en-us.html" CLASS="l1">Tutorials</A>
</TD>
</TR>
<TR><TD WIDTH="100%" VALIGN="MIDDLE" STYLE="background-image: url('2i.png'); border: 0px solid black; padding-left:12px; padding-right:0px; padding-top:6px; padding-bottom:6px; border-top: 1px solid #6E89AE;"><A HREF="app$ide$UppHub$en-us.html" CLASS="l1">UppHub</A>
</TD>
</TR>
<TR><TD WIDTH="100%" VALIGN="MIDDLE" STYLE="background-image: url('2i.png'); border: 0px solid black; padding-left:12px; padding-right:0px; padding-top:6px; padding-bottom:6px; border-top: 1px solid #6E89AE;"><A HREF="www$uppweb$Roadmap$en-us.html" CLASS="l1">Status & Roadmap</A>
</TD>
</TR>
<TR><TD WIDTH="100%" VALIGN="MIDDLE" STYLE="background-image: url('2i.png'); border: 0px solid black; padding-left:12px; padding-right:0px; padding-top:6px; padding-bottom:6px; border-top: 1px solid #6E89AE;"><A HREF="www$uppweb$FAQ$en-us.html" CLASS="l1">FAQ</A>
</TD>
</TR>
<TR><TD WIDTH="100%" VALIGN="MIDDLE" STYLE="background-image: url('2i.png'); border: 0px solid black; padding-left:12px; padding-right:0px; padding-top:6px; padding-bottom:6px; border-top: 1px solid #6E89AE;"><A HREF="app$ide$About$en-us.html" CLASS="l1">Authors & License</A>
</TD>
</TR>
<TR><TD WIDTH="100%" VALIGN="MIDDLE" STYLE="background-image: url('2i.png'); border: 0px solid black; padding-left:12px; padding-right:0px; padding-top:6px; padding-bottom:6px; border-top: 1px solid #6E89AE;"><A HREF="https://www.ultimatepp.org/forums" CLASS="l1">Forums</A>
</TD>
</TR>
<TR><TD WIDTH="100%" VALIGN="MIDDLE" STYLE="background-image: url('2i.png'); border: 0px solid black; padding-left:12px; padding-right:0px; padding-top:6px; padding-bottom:6px; border-top: 1px solid #6E89AE;"><A HREF="www$uppweb$Funding$en-us.html" CLASS="l1">Funding U++</A>
</TD>
</TR>
</TABLE>
<TABLE BORDER="0" WIDTH="100%"><TR><TD></TD>
</TR>
</TABLE>
<TABLE BORDER="0" CELLSPACING="0" CELLPADDING="0" WIDTH="100%" BGCOLOR="#FFFFFF" style="border-style: solid; border-width: 1px; border-color: #6E89AE;padding: 0px"><TR><TD WIDTH="100%" VALIGN="MIDDLE" STYLE="background-image: url('3i.png'); border: 0px solid black;padding-left:12px; padding-right:0px; padding-top:1px; padding-bottom:1px;color:#FFFFFF;"><B><span style="font-size: 8pt; font-family: sans-serif;">Search on this site</span>
</B>
</TD>
</TR>
<TR><TD WIDTH="100%" VALIGN="MIDDLE" STYLE="background-image: url('2i.png'); border: 0px solid black; padding-left:6px; padding-right:0px; padding-top:4px; padding-bottom:4px;border-top: 1px solid #6E89AE;"><TABLE BORDER="0" CELLSPACING="0" CELLPADDING="0" WIDTH="100%"><TR><TD><IMG SRC="4i.png" ALT="" BORDER="0"></TD>
<TD><FORM ACTION="https://www.google.com/search" METHOD="GET" STYLE="margin:0px;padding:0px;"><INPUT TYPE="HIDDEN" NAME="ie" VALUE="UTF-8"><INPUT TYPE="HIDDEN" NAME="oe" VALUE="UTF-8"><INPUT TYPE="TEXT" NAME="q" SIZE="15" MAXLENGTH="256" placeholder="Site search"><INPUT TYPE="HIDDEN" NAME="sitesearch" VALUE="ultimatepp.org"></FORM>
</TD>
</TR>
</TABLE>
</TD>
</TR>
</TABLE>
<TABLE BORDER="0" WIDTH="100%"><TR><TD></TD>
</TR>
</TABLE>
<br><div id="fb-root"></div>
<script type="text/javascript">(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) {return;}
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/en_US/all.js#xfbml=1";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>

<div class="fb-like" data-href="https://www.facebook.com/pages/Upp-Framework/262346610476027?sk=wall" data-send="false" data-layout="button_count" data-width="160" data-show-faces="false" data-font="arial"></div>
<br><br><script type="text/javascript"><!--
google_ad_client = "pub-1082147624384270";
google_ad_width = 160;
google_ad_height = 600;
google_ad_format = "160x600_as";
google_ad_type = "text_image";
google_ad_channel = "";
google_color_border = "336699";
google_color_bg = "FFFFFF";
google_color_link = "0000FF";
google_color_text = "000000";
google_color_url = "008000";
//--></script>
<script type="text/javascript"
  src="https://pagead2.googlesyndication.com/pagead/show_ads.js">
</script><br><br><script type="text/javascript"><!--
google_ad_client = "pub-1082147624384270";
google_ad_width = 160;
google_ad_height = 90;
google_ad_format = "160x90_0ads_al_s";
google_ad_channel = "";
google_color_border = "336699";
google_color_bg = "FFFFFF";
google_color_link = "0000FF";
google_color_text = "000000";
google_color_url = "008000";
//--></script>
<script type="text/javascript"
  src="https://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
<br><br><script type="text/javascript"><!--
google_ad_client = "pub-1082147624384270";
google_ad_width = 160;
google_ad_height = 600;
google_ad_format = "160x600_as";
google_ad_type = "text_image";
google_ad_channel = "";
google_color_border = "336699";
google_color_bg = "FFFFFF";
google_color_link = "0000FF";
google_color_text = "000000";
google_color_url = "008000";
//--></script>
<script type="text/javascript"
  src="https://pagead2.googlesyndication.com/pagead/show_ads.js">
</script><br><br><br><br><br><br><A HREF="https://sourceforge.net/projects/upp/"><IMG SRC="https://sourceforge.net/sflogo.php?group_id=93970&amp;type=2" ALT="SourceForge.net Logo" BORDER="0" WIDTH="125" HEIGHT="37"></A>
<br><br><A HREF="https://flathub.org/en/apps/org.ultimatepp.TheIDE"><IMG SRC="5i.png" ALT="SourceForge.net Logo" BORDER="0" WIDTH="125" HEIGHT="37"></A>
<br><br><div style="background-color:#ffffff;width:125;height:35"><A HREF="https://github.com/ultimatepp"><IMG SRC="6i.png" ALT="GitHub Logo" BORDER="0" WIDTH="125" HEIGHT="35"></A>
</div><br><div style="background-color:#ffffff;width:125;height:35"><div style="height:5"></div><A HREF="https://discord.gg/8XzqQzXZzb"><IMG SRC="https://assets-global.website-files.com/6257adef93867e50d84d30e2/636e0b5061df29d55a92d945_full_logo_blurple_RGB.svg" ALT="Discord Logo" BORDER="0" WIDTH="125" HEIGHT="25"></A>
</div><br></TD>
</TR>
</TABLE>
</TD>
<TD VALIGN="TOP" BGCOLOR="#D2D9D2"><TABLE BORDER="0" CELLSPACING="0" CELLPADDING="0" WIDTH="6"><TR><TD></TD>
</TR>
</TABLE>
</TD>
<TD VALIGN="TOP" WIDTH="100%" BGCOLOR="#D2D9D2"><TABLE BORDER="0" CELLSPACING="0" CELLPADDING="0" BGCOLOR="#FFFFFF" WIDTH="100%" style="border-style: solid; border-width: 1px; border-color: #6E89AE;padding: 10px;;"><TR><TD><TABLE BORDER="0" CELLSPACING="0" CELLPADDING="0" WIDTH="100%"><TR><TD><table width="100%" border="0" cellpadding="0" cellspacing="0"><tr><td width="100%"><table width="100%" class="C"><colgroup><col width="100%"></colgroup>
<tr><td class="D"><p class="E">Ctrl</p>
</td>
</tr>
</table></td>
</tr></table>
<p class="F">&nbsp;</p>
<p id="Ctrl::class" class="G"><span class="H">class</span>&nbsp;<span class="I">Ctrl</span>&nbsp;:&nbsp;<span class="H">public</span>&nbsp;<span class="J">Pte</span>&lt;<span class="I">Ctrl</span>&gt;&nbsp;</p>
<p class="K">(Derivation from Pte&lt;Ctrl&gt; allows Ctrl to be pointed to by Ptr&lt;Ctrl&gt;</p>
<p class="A">&nbsp;</p>
<p class="A">This the base class of GUI widgets hierarchy (that is why U++ widgets are also named &quot;Ctrls&quot;).</p>
<p class="F">&nbsp;</p>
<p class="A">&nbsp;</p>
<table width="100%" border="0" cellpadding="0" cellspacing="0"><tr><td width="100%"><table width="100%" class="L"><colgroup><col width="100%"></colgroup>
<tr><td class="M"><p class="N">Public Member List</p>
</td>
</tr>
</table></td>
</tr></table>
<p class="F">&nbsp;</p>
<p class="N"><span class="O">enum&nbsp;</span>PlacementConstants</p>
<p class="P">Constants used in logical coordinates.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p id="Ctrl::CENTER" class="A"><span class="Q">CENTER</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p id="Ctrl::CENTER" class="A">Center alignment.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p id="Ctrl::LEFT" class="A"><span class="Q">LEFT</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p id="Ctrl::LEFT" class="A">Left alignment.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p id="Ctrl::RIGHT" class="A"><span class="Q">RIGHT</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p id="Ctrl::RIGHT" class="A">Right alignment.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p id="Ctrl::TOP" class="A"><span class="Q">TOP</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p id="Ctrl::TOP" class="A">Equal to LEFT (better name for vertical coordinate).</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p id="Ctrl::BOTTOM" class="A"><span class="Q">BOTTOM</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p id="Ctrl::BOTTOM" class="A">Equal to RIGHT (better name for vertical coordinate)</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p id="Ctrl::SIZE" class="A"><span class="Q">SIZE</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p id="Ctrl::SIZE" class="A">Size alignment.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p id="Ctrl::MINSIZE" class="A"><span class="Q">MINSIZE</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p id="Ctrl::MINSIZE" class="A">Value is determined using GetMinSize.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p id="Ctrl::MAXSIZE" class="A"><span class="Q">MAXSIZE</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p id="Ctrl::MAXSIZE" class="A">Value is determined using GetMaxSize.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p id="Ctrl::STDSIZE" class="A"><span class="Q">STDSIZE</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p id="Ctrl::STDSIZE" class="A">Value is determined using Get</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p class="N"><span class="O">enum&nbsp;</span>StateReason</p>
<p class="P">Arguments of State virtual method.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p id="Ctrl::FOCUS" class="A"><span class="Q">FOCUS</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p id="Ctrl::FOCUS" class="A">Ctrl got/lost focus.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p id="Ctrl::ACTIVATE" class="A"><span class="Q">ACTIVATE</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p id="Ctrl::ACTIVATE" class="A">Ctrl was activated.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p id="Ctrl::DEACTIVATE" class="A"><span class="Q">DEACTIVATE</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p id="Ctrl::DEACTIVATE" class="A">Ctrl was deactivated.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p id="Ctrl::SHOW" class="A"><span class="Q">SHOW</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p id="Ctrl::SHOW" class="A">Ctrl visibility changed.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p id="Ctrl::ENABLE" class="A"><span class="Q">ENABLE</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p id="Ctrl::ENABLE" class="A">Ctrl was enabled/disable.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p id="Ctrl::EDITABLE" class="A"><span class="Q">EDITABLE</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p id="Ctrl::EDITABLE" class="A">Ctrl editable status changed.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p id="Ctrl::OPEN" class="A"><span class="Q">OPEN</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p id="Ctrl::OPEN" class="A">Ctrl was open (its top-level Ctrl was open on screen).</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p id="Ctrl::CLOSE" class="A"><span class="Q">CLOSE</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p id="Ctrl::CLOSE" class="A">Ctrl was closed (its top-level Ctrl was closed).</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p class="N"><span class="O">enum&nbsp;</span>MouseEvents</p>
<p class="P">Constants that make up <span class="R">event</span> argument of <span class="R">MouseEvent</span> and <span class="R">FrameMouseEvent</span> virtual methods. Value is combination of button and action bit fields.</p>
<p class="P">&nbsp;</p>
<p class="S">Field masks</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p id="Ctrl::BUTTON" class="A"><span class="Q">BUTTON</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p id="Ctrl::BUTTON" class="A">Mask for button field.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p id="Ctrl::ACTION" class="A"><span class="Q">ACTION</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p id="Ctrl::ACTION" class="A">Mask for action field. </p></td></tr></table>
<p class="A">&nbsp;</p>
<p class="S">Actions</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p id="Ctrl::MOUSEENTER" class="A"><span class="Q">MOUSEENTER</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p id="Ctrl::MOUSEENTER" class="A">Mouse entered Ctrl.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p id="Ctrl::MOUSEMOVE" class="A"><span class="Q">MOUSEMOVE</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p id="Ctrl::MOUSEMOVE" class="A">Mouse moved over Ctrl.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p id="Ctrl::MOUSELEAVE" class="A"><span class="Q">MOUSELEAVE</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p id="Ctrl::MOUSELEAVE" class="A">Mouse left Ctrl.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p id="Ctrl::CURSORIMAGE" class="A"><span class="Q">CURSORIMAGE</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p id="Ctrl::CURSORIMAGE" class="A">Cursor image has to be determined (method should respond with image).</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p id="Ctrl::MOUSEWHEEL" class="A"><span class="Q">MOUSEWHEEL</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p id="Ctrl::MOUSEWHEEL" class="A">Mouse wheel rotated.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p id="Ctrl::DOWN" class="A"><span class="Q">DOWN</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p id="Ctrl::DOWN" class="A">Mouse button was pressed.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p id="Ctrl::UP" class="A"><span class="Q">UP</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p id="Ctrl::UP" class="A">Mouse button was released.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p id="Ctrl::DOUBLE" class="A"><span class="Q">DOUBLE</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p id="Ctrl::DOUBLE" class="A">Mouse button was double-clicked.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p id="Ctrl::REPEAT" class="A"><span class="Q">REPEAT</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p id="Ctrl::REPEAT" class="A">When mouse button is pressed for a while, U++ imitates keyboard autorepeat sending this message.</p></td></tr></table>
<p class="T"><span class="I">Buttons</span> </p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">LEFT</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Left button. (This constant is not defined in MouseEvents, instead LEFT from Placements Constants is used).</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">RIGHT</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Left button. (This constant is not defined in MouseEvents, instead LEFT from Placements Constants is used).</p></td></tr></table>
<p class="S">Combinations</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p id="Ctrl::LEFTDOWN" class="A"><span class="Q">LEFTDOWN</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p id="Ctrl::LEFTDOWN" class="A">Left button pressed.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p id="Ctrl::LEFTDOUBLE" class="A"><span class="Q">LEFTDOUBLE</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p id="Ctrl::LEFTDOUBLE" class="A">Left button double pressed.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p id="Ctrl::LEFTREPEAT" class="A"><span class="Q">LEFTREPEAT</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p id="Ctrl::LEFTREPEAT" class="A">Left button autorepeat.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p id="Ctrl::LEFTUP" class="A"><span class="Q">LEFTUP</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p id="Ctrl::LEFTUP" class="A">Left button released.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p id="Ctrl::RIGHTDOWN" class="A"><span class="Q">RIGHTDOWN</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p id="Ctrl::RIGHTDOWN" class="A">Right button pressed.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p id="Ctrl::RIGHTDOUBLE" class="A"><span class="Q">RIGHTDOUBLE</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p id="Ctrl::RIGHTDOUBLE" class="A">Right button double pressed.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p id="Ctrl::RIGHTREPEAT" class="A"><span class="Q">RIGHTREPEAT</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p id="Ctrl::RIGHTREPEAT" class="A">Right button autorepeat.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p id="Ctrl::RIGHTUP" class="A"><span class="Q">RIGHTUP</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p id="Ctrl::RIGHTUP" class="A">Right button released.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p class="A">enum&nbsp;{&nbsp;<span class="J">NOBACKPAINT</span>, <span class="J">FULLBACKPAINT</span>, <span class="J">TRANSPARENTBACKPAINT</span>, <span class="J">EXCLUDEPAINT</span>&nbsp;}</p>
<p class="P">These constants are parameters of BackPaint method. They determine back-plane drawing style.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p id="Ctrl::NOBACKPAINT" class="A"><span class="Q">NOBACKPAINT</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p id="Ctrl::NOBACKPAINT" class="A">No backpaint is used.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p id="Ctrl::FULLBACKPAINT" class="A"><span class="Q">FULLBACKPAINT</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p id="Ctrl::FULLBACKPAINT" class="A">Whole area of Ctrl is backpainted.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p id="Ctrl::TRANSPARENTBACKPAINT" class="A"><span class="Q">TRANSPARENTBACKPAINT</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p id="Ctrl::TRANSPARENTBACKPAINT" class="A">Only transparent child Ctrls are backpainted.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p id="Ctrl::EXCLUDEPAINT" class="A"><span class="Q">EXCLUDEPAINT</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p id="Ctrl::EXCLUDEPAINT" class="A">Ctrl is not painted. This is special case for specific system related situations (like OLE control painted by regular Windows routine).</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p class="U">typedef&nbsp;<span class="H">bool</span>&nbsp;(*<span class="V">MouseHook</span>)(Ctrl&nbsp;*ctrl, <span class="H">bool</span>&nbsp;inframe, <span class="H">int</span>&nbsp;event, Point&nbsp;p, <span class="H">int</span>&nbsp;zdelta, dword&nbsp;keyflags)</p>
<p class="P">Type for hooking mouse events across all Ctrls.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p class="U">typedef&nbsp;<span class="H">bool</span>&nbsp;(*<span class="V">KeyHook</span>)(Ctrl&nbsp;*ctrl, dword&nbsp;key, <span class="H">int</span>&nbsp;count)</p>
<p class="P">Type for hooking keyboard events across all Ctrls.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p class="U">typedef&nbsp;<span class="H">bool</span>&nbsp;(*<span class="V">StateHook</span>)(Ctrl&nbsp;*ctrl, <span class="H">int</span>&nbsp;reason)</p>
<p class="P">Type for hooking state changes across all Ctrls.</p>
<p class="A">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::PosLeft(int,int)" class="W"><span class="H">static</span> <a href="Ctrl::Logc"><u>Logc</u></a>&nbsp;<span class="I">PosLeft</span>(<span class="H">int</span>&nbsp;<span class="J">pos</span>, <span class="H">int</span>&nbsp;<span class="J">size</span>)</p>
<p class="P">Creates left (or top) aligned logical coordinate (Logc).</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">pos</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Distance between left margin and left margin of parent's view.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">size</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Size.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Logical coordinate.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::PosRight(int,int)" class="W"><span class="H">static</span> <a href="Ctrl::Logc"><u>Logc</u></a>&nbsp;<span class="I">PosRight</span>(<span class="H">int</span>&nbsp;<span class="J">pos</span>, <span class="H">int</span>&nbsp;<span class="J">size</span>)</p>
<p class="P">Creates right (or bottom) aligned logical coordinate (Logc).</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">pos</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Distance between right margin and right margin of parent's view.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">size</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Size.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Logical coordinate.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::PosTop(int,int)" class="W"><span class="H">static</span> <u>Logc</u>&nbsp;<span class="I">PosTop</span>(<span class="H">int</span>&nbsp;<span class="J">pos</span>, <span class="H">int</span>&nbsp;<span class="J">size</span>)</p>
<p class="P">Equal to PosLeft(pos, size).</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">pos</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Distance between top margin and top margin of parent's view.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">size</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Size.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Logical coordinate.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::PosBottom(int,int)" class="W"><span class="H">static</span> <u>Logc</u>&nbsp;<span class="I">PosBottom</span>(<span class="H">int</span>&nbsp;<span class="J">pos</span>, <span class="H">int</span>&nbsp;<span class="J">size</span>)</p>
<p class="P">Equal to PosRight(pos, size).</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">pos</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Distance between bottom margin and bottom margin of parent's view.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">size</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Size.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Logical coordinate.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::PosSize(int,int)" class="W"><span class="H">static</span> <u>Logc</u>&nbsp;<span class="I">PosSize</span>(<span class="H">int</span>&nbsp;<span class="J">lpos</span>, <span class="H">int</span>&nbsp;<span class="J">rpos</span>)</p>
<p class="P">Creates logical coordinate where distances between margins and parent's view margins are fixed and size of Ctrl is variable (depends of parent's view size).</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">lpos</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Distance between left/top margin and left/top margin of parent's view.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">rpos</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Distance between right/bottom margin and right/bottom margin of parent's view.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Logical coordinate.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::PosCenter(int,int)" class="W"><span class="H">static</span> <u>Logc</u>&nbsp;<span class="I">PosCenter</span>(<span class="H">int</span>&nbsp;<span class="J">size</span>, <span class="H">int</span>&nbsp;<span class="J">offset</span>)</p>
<p class="P">Creates centered logical coordinate, where Ctrl is placed in specified distance from center of parent's view. </p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">size</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Size.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">offset</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Offset from center.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Logical coordinate.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::PosCenter(int)" class="W"><span class="H">static</span> <u>Logc</u>&nbsp;<span class="I">PosCenter</span>(<span class="H">int</span>&nbsp;<span class="J">size</span>)</p>
<p class="P">Equal to PosCenter(size, 0).</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">size</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Size.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Logical coordinate.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::GetTopCtrls()" class="W"><span class="H">static</span> <u>Vector</u><span class="H">&lt;</span>Ctrl&nbsp;*&gt;&nbsp;<span class="I">GetTopCtrls</span>()</p>
<p class="P">Returns all opened top-level Ctrls of process. Top-level Ctrls are those without parent (GetParent() == NULL) - TopWindow Ctrls and pop-up Ctrls.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Vector of all top Ctrls.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::GetTopWindows()" class="W"><span class="H">static</span> <u>Vector</u><span class="H">&lt;</span>Ctrl&nbsp;*&gt;&nbsp;<span class="I">GetTopWindows</span>()</p>
<p class="P">Returns all opened TopWindows (that is, instances of TopWindow class or classes derived from TopWindow) of process. The difference between GetTopWindows and GetTopCtrls is that GetTopCtrls returns pop-ups too. </p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Vector of all TopWindows.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::CloseTopCtrls()" class="W"><span class="H">static</span> <span class="H">void</span>&nbsp;<span class="I">CloseTopCtrls</span>()</p>
<p class="P">Closes all top-level Ctrls.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::InstallMouseHook(Ctrl::MouseHook)" class="W"><span class="H">static</span> <span class="H">void</span>&nbsp;<span class="I">InstallMouseHook</span>(<u>MouseHook</u>&nbsp;<span class="J">hook</span>)</p>
<p class="P">Installs mouse hook - a routine that receives all mouse input of application before it gets processed by Ctrls. You can install more mouse hooks. Mouse hook routine should return true to indicate the end of processing (and event propagation).</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">hook</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Pointer to hook routine.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::DeinstallMouseHook(Ctrl::MouseHook)" class="W"><span class="H">static</span> <span class="H">void</span>&nbsp;<span class="I">DeinstallMouseHook</span>(<u>MouseHook</u>&nbsp;<span class="J">hook</span>)</p>
<p class="P">Uninstalls previously installed mouse hook.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">hook</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Pointer to hook routine.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::InstallKeyHook(Ctrl::KeyHook)" class="W"><span class="H">static</span> <span class="H">void</span>&nbsp;<span class="I">InstallKeyHook</span>(<u>KeyHook</u>&nbsp;<span class="J">hook</span>)</p>
<p class="P">Installs keyboard hook - a routine that receives all keyboard input of application before it gets processed by Ctrls. You can install more than one keyboard hooks. Keyboard hook routine should return true to indicate the end of processing (and event propagation).</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">hook</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Pointer to hook routine.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::DeinstallKeyHook(Ctrl::KeyHook)" class="W"><span class="H">static</span> <span class="H">void</span>&nbsp;<span class="I">DeinstallKeyHook</span>(<u>KeyHook</u>&nbsp;<span class="J">hook</span>)</p>
<p class="P">Uninstalls previously installed keyboard hook.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">hook</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Pointer to hook routine.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::InstallStateHook(Ctrl::StateHook)" class="W"><span class="H">static</span> <span class="H">void</span>&nbsp;<span class="I">InstallStateHook</span>(<u>StateHook</u>&nbsp;<span class="J">hook</span>)</p>
<p class="P">Installs state hook - a routine that receives all state changes of any Ctrls.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">hook</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Pointer to hook routine.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::DeinstallStateHook(Ctrl::StateHook)" class="W"><span class="H">static</span> <span class="H">void</span>&nbsp;<span class="I">DeinstallStateHook</span>(<u>StateHook</u>&nbsp;<span class="J">hook</span>)</p>
<p class="P">Deinstalls previously installed state hook.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">hook</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Pointer to hook routine.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::Paint(Draw&)" class="W"><span class="H">virtual</span> <span class="H">void</span>&nbsp;<span class="I">Paint</span>(<u>Draw</u><span class="H">&amp;</span>&nbsp;<span class="J">draw</span>)</p>
<p class="P">This method is called when Ctrl's view area is about to be repainted.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">draw</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Target of draw operations.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::CancelMode()" class="W"><span class="H">virtual</span> <span class="H">void</span>&nbsp;<span class="I">CancelMode</span>()</p>
<p class="P">This method is called by U++ core in situations when internal state of Ctrl that represents ongoing user action is about to be cleared to default. Typical example of such action is state of Button that is pushed by mouse click - if the pushed state is internally recorded in Button, it should by cleared by this method. Examples of situations when this method is called by framework is removing Ctrl from its parent or releasing mouse capture.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::Activate()" class="W"><span class="H">virtual</span> <span class="H">void</span>&nbsp;<span class="I">Activate</span>()</p>
<p class="P">This method is called when Ctrl is top-level and is activated - it or some of its child Ctrls receives keyboard focus (activation usually has other signs as bringing window foreground or changing its caption).</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::Deactivate()" class="W"><span class="H">virtual</span> <span class="H">void</span>&nbsp;<span class="I">Deactivate</span>()</p>
<p class="P">This method is called when Ctrl is top-level and is deactivated - focus has gone outside of Ctrl and its child Ctrls.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Upp::Ctrl::DeactivateBy(Upp::Ctrl*)" class="W"><span class="H">virtual</span> <span class="H">void</span>&nbsp;<span class="I">DeactivateBy</span>(<a href="Upp::Ctrl"><u>Ctrl</u></a>&nbsp;*<span class="J">new_focus</span>)</p>
<p class="X">Similar to Deactivate without parameter, but if a widget that caused deactivation by getting a focus is part of the same appliaction, <span class="J">new_focus</span> contains a pointer to it. If deactivation is caused by switching to another application, this parameter is NULL. Both variants of Deactivate are called, the variant with paremeter is called first.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::FrameMouseEvent(int,Point,int,dword)" class="W"><span class="H">virtual</span> <u>Image</u>&nbsp;<span class="I">FrameMouseEvent</span>(<span class="H">int</span>&nbsp;<span class="J">event</span>, <u>Point</u>&nbsp;<span class="J">p</span>, <span class="H">int</span>&nbsp;<span class="J">zdelta</span>, <u>dword</u>&nbsp;<span class="J">keyflags</span>)</p>
<p class="P">This method is called when mouse event happens in frame area of Ctrl not containing any child Ctrls. Default implementation does nothing and returns Image::Arrow().</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">event</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Type of event define by <a href="src$CtrlCore$Ctrl$en-us.html#::Ctrl::enum MouseEvents { BUTTON, ACTION, MOUSEENTER, MOUSEMOVE, MOUSELEAVE, CURSORIMAGE, MOUSEWHEEL, DOWN, UP, DOUBLE, REPEAT, LEFTDOWN, LEFTDOUBLE, LEFTREPEAT, LEFTUP, RIGHTDOWN, RIGHTDOUBLE, RIGHTREPEAT, RIGHTUP }">MouseEvents</a> enum.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">p</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Position of mouse cursor in frame coordinates.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">zdelta</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Mouse wheel rotation delta (if event is MOUSEWHEEL).</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">keyflags</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Combination of key flags for Shift, Ctrl and Alt keys.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">If event is MOUSEIMAGE, method should return Image to be displayed as mouse cursor.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::MouseEvent(int,Point,int,dword)" class="W"><span class="H">virtual</span> <u>Image</u>&nbsp;<span class="I">MouseEvent</span>(<span class="H">int</span>&nbsp;<span class="J">event</span>, <u>Point</u>&nbsp;<span class="J">p</span>, <span class="H">int</span>&nbsp;<span class="J">zdelta</span>, <u>dword</u>&nbsp;<span class="J">keyflags</span>)</p>
<p class="P">This method is called when mouse event happens in view area of Ctrl not containing any child Ctrls. Default implementation calls specific mouse event methods based on event parameter.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">event</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Type of event define by <a href="src$CtrlCore$Ctrl$en-us.html#::Ctrl::enum MouseEvents { BUTTON, ACTION, MOUSEENTER, MOUSEMOVE, MOUSELEAVE, CURSORIMAGE, MOUSEWHEEL, DOWN, UP, DOUBLE, REPEAT, LEFTDOWN, LEFTDOUBLE, LEFTREPEAT, LEFTUP, RIGHTDOWN, RIGHTDOUBLE, RIGHTREPEAT, RIGHTUP }">MouseEvents</a> enum.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">p</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Position of mouse cursor in view coordinates.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">zdelta</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Mouse wheel rotation delta (if event is MOUSEWHEEL).</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">keyflags</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Combination of key flags for Shift, Ctrl and Alt keys.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">If event is MOUSEIMAGE, method should return Image to be displayed as mouse cursor.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::MouseEnter(Point,dword)" class="W"><span class="H">virtual</span> <span class="H">void</span>&nbsp;<span class="I">MouseEnter</span>(<u>Point</u>&nbsp;<span class="J">p</span>, <u>dword</u>&nbsp;<span class="J">keyflags</span>)</p>
<p class="P">This method is called by default implementation of MouseEvent when mouse cursor enters the view area of Ctrl.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">p</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Point of mouse cursor in view coordinates.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">keyflags</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Combination of key flags for Shift, Ctrl and Alt keys.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::MouseMove(Point,dword)" class="W"><span class="H">virtual</span> <span class="H">void</span>&nbsp;<span class="I">MouseMove</span>(<u>Point</u>&nbsp;<span class="J">p</span>, <u>dword</u>&nbsp;<span class="J">keyflags</span>)</p>
<p class="P">This method is called by default implementation of MouseEvent when mouse cursor hovers above view area of Ctrl.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">p</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Position of mouse cursor in view coordinates.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">keyflags</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Combination of key flags for Shift, Ctrl and Alt keys.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::LeftDown(Point,dword)" class="W"><span class="H">virtual</span> <span class="H">void</span>&nbsp;<span class="I">LeftDown</span>(<u>Point</u>&nbsp;<span class="J">p</span>, <u>dword</u>&nbsp;<span class="J">keyflags</span>)</p>
<p class="P">This method is called by default implementation of MouseEvent when mouse left button is pressed.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">p</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Position of mouse cursor in view coordinates.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">keyflags</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Combination of key flags for Shift, Ctrl and Alt keys.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::LeftDouble(Point,dword)" class="W"><span class="H">virtual</span> <span class="H">void</span>&nbsp;<span class="I">LeftDouble</span>(<u>Point</u>&nbsp;<span class="J">p</span>, <u>dword</u>&nbsp;<span class="J">keyflags</span>)</p>
<p class="P">This method is called by default implementation of MouseEvent when mouse left button is double-clicked. Default implementation calls LeftDown.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">p</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Position of mouse cursor in view coordinates.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">keyflags</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Combination of key flags for Shift, Ctrl and Alt keys.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::LeftTriple(Point,dword)" class="W"><span class="H">virtual</span> <span class="H">void</span>&nbsp;<span class="I">LeftTriple</span>(<u>Point</u>&nbsp;<span class="J">p</span>, <u>dword</u>&nbsp;<span class="J">keyflags</span>)</p>
<p class="P">This method is called by default implementation of MouseEvent when mouse left button is triple-clicked. Default implementation calls LeftDown.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::LeftDrag(Point,dword)" class="W"><span class="H">virtual</span> <span class="H">void</span>&nbsp;<span class="I">LeftDrag</span>(<u>Point</u>&nbsp;<span class="J">p</span>, <u>dword</u>&nbsp;<span class="J">keyflags</span>)</p>
<p class="P">This method is called by default implementation of MouseEvent when user moves the mouse while holding left button by more than GUI_DragDistance pixels. <span class="J">p</span> is the starting point of drag, not the current mouse position.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::LeftHold(Point,dword)" class="W"><span class="H">virtual</span> <span class="H">void</span>&nbsp;<span class="I">LeftHold</span>(<u>Point</u>&nbsp;<span class="J">p</span>, <u>dword</u>&nbsp;<span class="J">keyflags</span>)</p>
<p class="P">This method is called by default implementation of MouseEvent when user holds the mouse left button down for a while.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::LeftRepeat(Point,dword)" class="W"><span class="H">virtual</span> <span class="H">void</span>&nbsp;<span class="I">LeftRepeat</span>(<u>Point</u>&nbsp;<span class="J">p</span>, <u>dword</u>&nbsp;<span class="J">keyflags</span>)</p>
<p class="P">This method is repeatedly called by default implementation of MouseEvent when mouse left button is pressed for some time, imitating keyboard autorepeat behaviour.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">p</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Position of mouse cursor in view coordinates.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">keyflags</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Combination of key flags for Shift, Ctrl and Alt keys.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::LeftUp(Point,dword)" class="W"><span class="H">virtual</span> <span class="H">void</span>&nbsp;<span class="I">LeftUp</span>(<u>Point</u>&nbsp;<span class="J">p</span>, <u>dword</u>&nbsp;<span class="J">keyflags</span>)</p>
<p class="P">This method is called by default implementation of MouseEvent when mouse left button is released.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">p</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Position of mouse cursor in view coordinates.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">keyflags</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Combination of key flags for Shift, Ctrl and Alt keys.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::RightDown(Point,dword)" class="W"><span class="H">virtual</span> <span class="H">void</span>&nbsp;<span class="I">RightDown</span>(<u>Point</u>&nbsp;<span class="J">p</span>, <u>dword</u>&nbsp;<span class="J">keyflags</span>)</p>
<p class="P">This method is called by default implementation of MouseEvent when mouse right button is pressed.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">p</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Position of mouse cursor in view coordinates.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">keyflags</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Combination of key flags for Shift, Ctrl and Alt keys.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::RightDouble(Point,dword)" class="W"><span class="H">virtual</span> <span class="H">void</span>&nbsp;<span class="I">RightDouble</span>(<u>Point</u>&nbsp;<span class="J">p</span>, <u>dword</u>&nbsp;<span class="J">keyflags</span>)</p>
<p class="P">This method is called by default implementation of MouseEvent when mouse right button is double-clicked. Default implementation calls RightDown.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">p</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Position of mouse cursor in view coordinates.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">keyflags</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Combination of key flags for Shift, Ctrl and Alt keys.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::RightTriple(Point,dword)" class="W"><span class="H">virtual</span> <span class="H">void</span>&nbsp;<span class="I">RightTriple</span>(<u>Point</u>&nbsp;<span class="J">p</span>, <u>dword</u>&nbsp;<span class="J">keyflags</span>)</p>
<p class="P">This method is called by default implementation of MouseEvent when mouse right button is triple-clicked. Default implementation calls RightDown.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::RightDrag(Point,dword)" class="W"><span class="H">virtual</span> <span class="H">void</span>&nbsp;<span class="I">RightDrag</span>(<u>Point</u>&nbsp;<span class="J">p</span>, <u>dword</u>&nbsp;<span class="J">keyflags</span>)</p>
<p class="P">This method is called by default implementation of MouseEvent when user moves the mouse while holding right button by more than GUI_DragDistance pixels. <span class="J">p</span> is the starting point of drag, not the current mouse position.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::RightHold(Point,dword)" class="W"><span class="H">virtual</span> <span class="H">void</span>&nbsp;<span class="I">RightHold</span>(<u>Point</u>&nbsp;<span class="J">p</span>, <u>dword</u>&nbsp;<span class="J">keyflags</span>)</p>
<p class="P">This method is called by default implementation of MouseEvent when user holds the mouse right button down for a while.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::RightRepeat(Point,dword)" class="W"><span class="H">virtual</span> <span class="H">void</span>&nbsp;<span class="I">RightRepeat</span>(<u>Point</u>&nbsp;<span class="J">p</span>, <u>dword</u>&nbsp;<span class="J">keyflags</span>)</p>
<p class="P">This method is repeatedly called by default implementation of MouseEvent when mouse right button is pressed for some time, imitating keyboard autorepeat behaviour.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">p</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Position of mouse cursor in view coordinates.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">keyflags</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Combination of key flags for Shift, Ctrl and Alt keys.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::RightUp(Point,dword)" class="W"><span class="H">virtual</span> <span class="H">void</span>&nbsp;<span class="I">RightUp</span>(<u>Point</u>&nbsp;<span class="J">p</span>, <u>dword</u>&nbsp;<span class="J">keyflags</span>)</p>
<p class="P">This method is called by default implementation of MouseEvent when mouse left button is released.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">p</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Position of mouse cursor in view coordinates.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">keyflags</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Combination of key flags for Shift, Ctrl and Alt keys.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::MiddleDown(Point,dword)" class="W"><span class="H">virtual</span> <span class="H">void</span>&nbsp;<span class="I">MiddleDown</span>(<a href="Point"><u>Point</u></a>&nbsp;<span class="J">p</span>, <a href="dword"><u>dword</u></a>&nbsp;<span class="J">keyflags</span>)</p>
<p class="P">This method is called by default implementation of MouseEvent when mouse middle button is pressed.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">p</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Position of mouse cursor in view coordinates.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">keyflags</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Combination of key flags for Shift, Ctrl and Alt keys.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::MiddleDouble(Point,dword)" class="W"><span class="H">virtual</span> <span class="H">void</span>&nbsp;<span class="I">MiddleDouble</span>(<a href="Point"><u>Point</u></a>&nbsp;<span class="J">p</span>, <a href="dword"><u>dword</u></a>&nbsp;<span class="J">keyflags</span>)</p>
<p class="P">This method is called by default implementation of MouseEvent when mouse left button is double-clicked.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">p</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Position of mouse cursor in view coordinates.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">keyflags</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Combination of key flags for Shift, Ctrl and Alt keys.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::MiddleTriple(Point,dword)" class="W"><span class="H">virtual</span> <span class="H">void</span>&nbsp;<span class="I">MiddleTriple</span>(<a href="Point"><u>Point</u></a>&nbsp;<span class="J">p</span>, <a href="dword"><u>dword</u></a>&nbsp;<span class="J">keyflags</span>)</p>
<p class="X">This method is called by default implementation of MouseEvent when mouse right button is triple-clicked.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">p</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Position of mouse cursor in view coordinates.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">keyflags</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Combination of key flags for Shift, Ctrl and Alt keys.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::MiddleRepeat(Point,dword)" class="W"><span class="H">virtual</span> <span class="H">void</span>&nbsp;<span class="I">MiddleRepeat</span>(<a href="Point"><u>Point</u></a>&nbsp;<span class="J">p</span>, <a href="dword"><u>dword</u></a>&nbsp;<span class="J">keyflags</span>)</p>
<p class="X">This method is repeatedly called by default implementation of MouseEvent when mouse right button is pressed for some time, imitating keyboard autorepeat behaviour.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">p</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Position of mouse cursor in view coordinates.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">keyflags</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Combination of key flags for Shift, Ctrl and Alt keys.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::MiddleDrag(Point,dword)" class="W"><span class="H">virtual</span> <span class="H">void</span>&nbsp;<span class="I">MiddleDrag</span>(<a href="Point"><u>Point</u></a>&nbsp;<span class="J">p</span>, <a href="dword"><u>dword</u></a>&nbsp;<span class="J">keyflags</span>)</p>
<p class="X">This method is called by default implementation of MouseEvent when user moves the mouse while holding middle button by more than GUI_DragDistance pixels. <span class="J">p</span> is the starting point of drag, not the current mouse position.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::MiddleHold(Point,dword)" class="W"><span class="H">virtual</span> <span class="H">void</span>&nbsp;<span class="I">MiddleHold</span>(<a href="Point"><u>Point</u></a>&nbsp;<span class="J">p</span>, <a href="dword"><u>dword</u></a>&nbsp;<span class="J">keyflags</span>)</p>
<p class="X">This method is called by default implementation of MouseEvent when user holds the mouse middle button down for a while.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">p</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Position of mouse cursor in view coordinates.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">keyflags</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Combination of key flags for Shift, Ctrl and Alt keys.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::MiddleUp(Point,dword)" class="W"><span class="H">virtual</span> <span class="H">void</span>&nbsp;<span class="I">MiddleUp</span>(<a href="Point"><u>Point</u></a>&nbsp;<span class="J">p</span>, <a href="dword"><u>dword</u></a>&nbsp;<span class="J">keyflags</span>)</p>
<p class="X">This method is called by default implementation of MouseEvent when mouse middle button is released.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">p</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Position of mouse cursor in view coordinates.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">keyflags</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Combination of key flags for Shift, Ctrl and Alt keys.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::MouseWheel(Point,int,dword)" class="W"><span class="H">virtual</span> <span class="H">void</span>&nbsp;<span class="I">MouseWheel</span>(<u>Point</u>&nbsp;<span class="J">p</span>, <span class="H">int</span>&nbsp;<span class="J">zdelta</span>, <u>dword</u>&nbsp;<span class="J">keyflags</span>)</p>
<p class="P">This method is called by default implementation of MouseEvent when mouse wheel is rotated. Default implementation of this method propagates event to the parent and suppresses call of ChildMouseEvent for the parent.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">p</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Position of mouse cursor in view coordinates.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">zdelta</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Amount of rotation.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">keyflags</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Combination of key flags for Shift, Ctrl and Alt keys.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::MouseLeave()" class="W"><span class="H">virtual</span> <span class="H">void</span>&nbsp;<span class="I">MouseLeave</span>()</p>
<p class="P">This method is called by default implementation of MouseEvent when mouse cursor leaves view area of Ctrl.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Upp::Ctrl::GetPreedit()" class="W"><a href="Upp::Point"><u>Point</u></a>&nbsp;<span class="I">GetPreedit</span>()</p>
<p class="X">If the widget is supposed to support text input, it should return top-left corner of insertion point so that host input method can eventually display a composition window near the insertion point with U++ displaying composition text over the spot. Should return Null if widget does not require the text input. Default implementation returns the position of caret.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Upp::Ctrl::GetPreeditFont()" class="W"><a href="Upp::Font"><u>Font</u></a>&nbsp;<span class="I">GetPreeditFont</span>()</p>
<p class="X">Should return the font that is supposed to be used for composition text. Default implementation returns StdFont().</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::DragAndDrop(Point,PasteClip&)" class="W"><span class="H">virtual</span> <span class="H">void</span>&nbsp;<span class="I">DragAndDrop</span>(<a href="Point"><u>Point</u></a>&nbsp;<span class="J">p</span>, <a href="PasteClip"><u>PasteClip</u></a><span class="H">&amp;</span>&nbsp;<span class="J">d</span>)</p>
<p class="X">This method is called when user performs drag and drop operation over view area. The drag operation can either be just moving the mouse, or actual drop - the difference is that for actual drop the PasteClip::Accept method returns true. This allows to share drag and drop logic, which is very similar, in the single method.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::FrameDragAndDrop(Point,PasteClip&)" class="W"><span class="H">virtual</span> <span class="H">void</span>&nbsp;<span class="I">FrameDragAndDrop</span>(<a href="Point"><u>Point</u></a>&nbsp;<span class="J">p</span>, <a href="PasteClip"><u>PasteClip</u></a><span class="H">&amp;</span>&nbsp;<span class="J">d</span>)</p>
<p class="X">This method is called when user performs drag and drop operation over frame area. The drag operation can either be just moving the mouse, or actual drop - the difference is that for actual drop the PasteClip::Accept method returns true. This allows to share drag and drop logic, which is very similar, in the single method.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::DragRepeat(Point)" class="W"><span class="H">virtual</span> <span class="H">void</span>&nbsp;<span class="I">DragRepeat</span>(<a href="Point"><u>Point</u></a>&nbsp;<span class="J">p</span>)</p>
<p class="X">This method is called when user holds his drag operation over single position for some time. This is similar to LeftRepeat and it is usually used to scroll the content of view when DragRepeat occurs at the border area of view.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::DragEnter()" class="W"><span class="H">virtual</span> <span class="H">void</span>&nbsp;<span class="I">DragEnter</span>()</p>
<p class="X">Called when user enters view with drag.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::DragLeave()" class="W"><span class="H">virtual</span> <span class="H">void</span>&nbsp;<span class="I">DragLeave</span>()</p>
<p class="X">Called when user's drag leaves the view.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::GetDropData(const String&)const" class="Y">virtual<span class="V"> </span><a href="String"><span class="V"><u>String</u></span></a><span class="V">&nbsp;</span><span class="Z">GetDropData</span><span class="V">(</span>const<span class="V">&nbsp;</span><a href="String"><span class="V"><u>String</u></span></a>&amp;<span class="V">&nbsp;</span><span class="J">fmt</span><span class="V">)&nbsp;</span>const</p>
<p class="X">This method is invoked to obtain drop data from Ctrl if such data was not supplied as ClipData in call to DoDragAndDrop. Default implementation calls GetSelectionData.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::GetSelectionData(const String&)const" class="Y">virtual<span class="V"> </span><a href="String"><span class="V"><u>String</u></span></a><span class="V">&nbsp;</span><span class="Z">GetSelectionData</span><span class="V">(</span>const<span class="V">&nbsp;</span><a href="String"><span class="V"><u>String</u></span></a>&amp;<span class="V">&nbsp;</span><span class="J">fmt</span><span class="V">)&nbsp;</span>const</p>
<p class="X">This method should return the widget's actual selection in requested format. It is used for X11 middle mouse selection paste operation ans as default implementation of GetDropData, because usually the data to be transfered by drag&amp;drop operation is the selection.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::CursorImage(Point,dword)" class="W"><span class="H">virtual</span> <u>Image</u>&nbsp;<span class="I">CursorImage</span>(<u>Point</u>&nbsp;<span class="J">p</span>, <u>dword</u>&nbsp;<span class="J">keyflags</span>)</p>
<p class="P">This method is called by default implementation of MouseEvent when the shape of mouse cursor is to be determined..</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">p</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Position of mouse cursor in view coordinates.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">keyflags</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Combination of key flags for Shift, Ctrl and Alt keys.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Image of new cursor. Default implementation returns Image::Arrow().</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::Key(dword,int)" class="W"><span class="H">virtual</span> <span class="H">bool</span>&nbsp;<span class="I">Key</span>(<u>dword</u>&nbsp;<span class="J">key</span>, <span class="H">int</span>&nbsp;<span class="J">count</span>)</p>
<p class="P">This method provides keyboard input. When keyboard event occurs and some of U++ application Ctrls has input focus, its Key method is called. If Key method returns true, processing of key event is finished. If it returns false, U++ calls Key method of parent Ctrl and it repeats until either true is returned or Ctrl has no parent. If such top-level Ctrl is reached, U++ calls its HotKey method. Default implementation is void and returns false.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">key</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Key identifier. If it is less than 65536, it indicates character code, otherwise it is key-code. Key-code is combination of basic key codes and further flags indicating state of shift keys and push/release events.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">count</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Accumulated autorepeat count.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Method should return true if further propagation is not desirable (in most cases this indicates that Ctrl accepted the key).</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::HotKey(dword)" class="W"><span class="H">virtual</span> <span class="H">bool</span>&nbsp;<span class="I">HotKey</span>(<u>dword</u>&nbsp;<span class="J">key</span>)</p>
<p class="P">This method is called when no Ctrl accepts key event using Key method. Default implementation calls HotKey method child Ctrls. If some child Ctrl returns true, method returns true, otherwise it returns false.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">key</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Key indentifier.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Method should return true to stop further distribution of key event via HotKey methods.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::GotFocus()" class="W"><span class="H">virtual</span> <span class="H">void</span>&nbsp;<span class="I">GotFocus</span>()</p>
<p class="P">This method is called when Ctrl receives input focus. Default implementation is void.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::LostFocus()" class="W"><span class="H">virtual</span> <span class="H">void</span>&nbsp;<span class="I">LostFocus</span>()</p>
<p class="P">This method is called when Ctrl loses input focus. Default implementation is void.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::ChildFrameMouseEvent(Ctrl*,int,Point,int,dword)" class="W"><span class="H">virtual</span> <span class="H">void</span>&nbsp;<span class="I">ChildFrameMouseEvent</span>(<a href="Ctrl"><u>Ctrl</u></a>&nbsp;*<span class="J">child</span>, <span class="H">int</span>&nbsp;<span class="J">event</span>, <a href="Point"><u>Point</u></a>&nbsp;<span class="J">p</span>, <span class="H">int</span>&nbsp;<span class="J">zdelta</span>, <a href="dword"><u>dword</u></a>&nbsp;<span class="J">keyflags</span>)</p>
<p class="X">This method is invoked before the <span class="AA">frame</span> mouse <span class="J">event</span> is routed to the <span class="J">child</span>. Parameters of the event are the same as those in MouseEvent method. Default implementation calls the parent's ChildMouseEvent method.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::ChildMouseEvent(Ctrl*,int,Point,int,dword)" class="W"><span class="H">virtual</span> <span class="H">void</span>&nbsp;<span class="I">ChildMouseEvent</span>(<u>Ctrl</u>&nbsp;*<span class="J">child</span>, <span class="H">int</span>&nbsp;<span class="J">event</span>, <u>Point</u>&nbsp;<span class="J">p</span>, <span class="H">int</span>&nbsp;<span class="J">zdelta</span>, <u>dword</u>&nbsp;<span class="J">keyflags</span>)</p>
<p class="P">This method is invoked before the mouse <span class="J">event</span> is routed to the <span class="J">child</span>. Parameters of the event are the same as those in MouseEvent method. Default implementation calls the parent's ChildMouseEvent method.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::ChildGotFocus()" class="W"><span class="H">virtual</span> <span class="H">void</span>&nbsp;<span class="I">ChildGotFocus</span>()</p>
<p class="P">This method is invoked when any of child Ctrls receives input focus.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::ChildLostFocus()" class="W"><span class="H">virtual</span> <span class="H">void</span>&nbsp;<span class="I">ChildLostFocus</span>()</p>
<p class="P">This method is invoked when any of child Ctrls loses input focus.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::GetAccessKeys()const" class="Y">virtual<span class="V"> </span><span class="V"><u>dword</u></span><span class="V">&nbsp;</span><span class="Z">GetAccessKeys</span><span class="V">()&nbsp;</span>const</p>
<p class="P">Ctrl should use this method to signal presence of access keys. Access keys are keyboard keys that can be used to access or activate dialog functions when pressed together with Alt key. They can be defined by application designer (usually using &amp; or \b in labels), or they are automatically synthesized using <span class="I">AssignAccessKeys</span> method. If Ctrl (of one of Ctrls in its child tree) has some access keys and those keys are letters (in range 'A' - 'Z'), they should be returned as bit value using AccessKeyBit function. Other access keys should be indicated by bit 0 (that means, by binary or of 1 to result). Default implementation returns 0.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Bit set of access keys.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::AssignAccessKeys(dword)" class="W"><span class="H">virtual</span> <span class="H">void</span>&nbsp;<span class="I">AssignAccessKeys</span>(<u>dword</u>&nbsp;<span class="J">used</span>)</p>
<p class="P">This method gives a Ctrl chance to synthesize its letter access keys.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">used</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Set of letter access keys that are already used and should not be chosen by Ctrl as its access keys.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::ChildAdded(Ctrl*)" class="W"><span class="H">virtual</span> <span class="H">void</span>&nbsp;<span class="I">ChildAdded</span>(<u>Ctrl</u>&nbsp;*<span class="J">child</span>)</p>
<p class="P">This method is invoked when child is added to Ctrl.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">child</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Pointer to child added.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::ChildRemoved(Ctrl*)" class="W"><span class="H">virtual</span> <span class="H">void</span>&nbsp;<span class="I">ChildRemoved</span>(<u>Ctrl</u>&nbsp;*<span class="J">child</span>)</p>
<p class="P">This method is invoked when child is removed from Ctrl.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">child</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Pointer to child removed.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::ParentChange()" class="W"><span class="H">virtual</span> <span class="H">void</span>&nbsp;<span class="I">ParentChange</span>()</p>
<p class="P">This method is called when Ctrl is added or removed from parent.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::State(int)" class="W"><span class="H">virtual</span> <span class="H">void</span>&nbsp;<span class="I">State</span>(<span class="H">int</span>&nbsp;<span class="J">reason</span>)</p>
<p class="P">This method is used to notify Ctrls about special state-change events that are not covered by virtual methods. Method is called for entire child tree of Ctrl whose state has changed.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">reason</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Code of event. Standard reasons are enumerated by StateReason enum.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::Layout()" class="W"><span class="H">virtual</span> <span class="H">void</span>&nbsp;<span class="I">Layout</span>()</p>
<p class="P">This method is invoked when layout of Ctrl has to be refreshed. This is usually either before window is displayed or when the Ctrl is resized.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::GetMinSize()const" class="Y">virtual<span class="V"> </span><span class="V"><u>Size</u></span><span class="V">&nbsp;</span><span class="Z">GetMinSize</span><span class="V">()&nbsp;</span>const</p>
<p class="P">This method should return <span class="AA">minimal</span> size of Ctrl. This is used e.g. to limit the minimal size of windows. Default implementation returns size suitable for edit-field type of widget, based on default GUI font and EditFieldIsThin setting.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::GetStdSize()const" class="Y">virtual<span class="V"> </span><span class="V"><u>Size</u></span><span class="V">&nbsp;</span><span class="Z">GetStdSize</span><span class="V">()&nbsp;</span>const</p>
<p class="P">This method should return <span class="AA">standard</span> size of Ctrl. Default implementation returns calls GetMinSize, increases width 10 and returns resulting Size.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::GetMaxSize()const" class="Y">virtual<span class="V"> </span><a href="Size"><span class="V"><u>Size</u></span></a><span class="V">&nbsp;</span><span class="Z">GetMaxSize</span><span class="V">()&nbsp;</span>const</p>
<p class="X">This method should return <span class="AA">maximal</span> size of Ctrl. Default implementation returns the size of virtual working area. Redefinition can be used to e.g. define the maximum size of window (as maximal size of view area).</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::IsShowEnabled()const" class="Y">virtual<span class="V"> </span>bool<span class="V">&nbsp;</span><span class="Z">IsShowEnabled</span><span class="V">()&nbsp;</span>const</p>
<p class="P">This method indicates whether Ctrl should be painted as enabled. Default implementation returns IsEnabled() &amp;&amp; (!parent || parent-&gt;IsShowEnabled()), however TopWindow overloads this function so that owner of modal dialogs while being disabled during modal dialog lifetime are displayed with enabled Ctrls.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">true if Ctrl should be painted as enabled.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::GetOpaqueRect()const" class="Y">virtual<span class="V"> </span><a href="Rect"><span class="V"><u>Rect</u></span></a><span class="V">&nbsp;</span><span class="Z">GetOpaqueRect</span><span class="V">()&nbsp;</span>const</p>
<p class="X">Returns the rectangle of view area that is opaque (is completely filled when painting the widget). The default implementation returns the whole view area if Transparent flag is set, empty rectangle otherwise. Paint routine uses this information to optimize.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::GetVoidRect()const" class="Y">virtual<span class="V"> </span><a href="Rect"><span class="V"><u>Rect</u></span></a><span class="V">&nbsp;</span><span class="Z">GetVoidRect</span><span class="V">()&nbsp;</span>const</p>
<p class="X">Returns the rectangle of view area that is fully transparent (nothing is painted in that rectangle). Paint routine uses this information to optimize.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::Updated()" class="W"><span class="H">virtual</span> <span class="H">void</span>&nbsp;<span class="I">Updated</span>()</p>
<p class="X">Invoked by Update method. Default implementation is empty.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::OverPaint()const" class="Y">virtual<span class="V"> </span>int<span class="V">&nbsp;</span><span class="Z">OverPaint</span><span class="V">()&nbsp;</span>const</p>
<p class="P">This method can returns non-zero number that represents paint extension margin of view area - Ctrl can paint inside this margin despite that fact that it does not belong to view. This is useful to represent some specific skinning effect (like glare around the button). Default implementation returns zero.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::Close()" class="W"><span class="H">virtual</span> <span class="H">void</span>&nbsp;<span class="I">Close</span>()</p>
<p class="P">Closes top-level Ctrl. If Ctrl is not top-level, has no effect. If it is and is open in host GUI (either as pop-up or as <a href="src$CtrlCore$TopWindow$en-us.html#::TopWindow::class">TopWindow</a>), it should close it. Default implementation closes. TopWindow overrides this method to break modal loop instead of closing if modal loop is performed for it.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::IsOcxChild()" class="W"><span class="H">virtual</span> <span class="H">bool</span>&nbsp;<span class="I">IsOcxChild</span>()</p>
<p class="P">Used for Ocx control implementation.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::GetDesc()const" class="Y">virtual<span class="V"> </span><a href="String"><span class="V"><u>String</u></span></a><span class="V">&nbsp;</span><span class="Z">GetDesc</span><span class="V">()&nbsp;</span>const</p>
<p class="X">Returns description of Ctrl for diagnostic purposes. Default implementation is empty.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::WhenAction" class="AB"><a href="Callback"><span class="O"><u>Callback</u></span></a><span class="O">&nbsp;</span>WhenAction</p>
<p class="X">This callback is used to signal that <span class="AA">user</span> has changed the value (or state) of widget.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::SetData(const Value&)" class="W"><span class="H">virtual</span> <span class="H">void</span>&nbsp;<span class="I">SetData</span>(<span class="H">const</span>&nbsp;<u>Value</u><span class="H">&amp;</span>&nbsp;<span class="J">data</span>)</p>
<p class="P">Sets the new value to the object. Default implementation is void.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::GetData()const" class="Y">virtual<span class="V"> </span><span class="V"><u>Value</u></span><span class="V">&nbsp;</span><span class="Z">GetData</span><span class="V">()&nbsp;</span>const</p>
<p class="P">Gets current value of the object. Default implementation returns Value() - void value.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Value of object.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::SetModify()" class="W"><span class="H">virtual</span> <span class="H">void</span>&nbsp;<span class="I">SetModify</span>()</p>
<p class="P">Sets modification flag.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::ClearModify()" class="W"><span class="H">virtual</span> <span class="H">void</span>&nbsp;<span class="I">ClearModify</span>()</p>
<p class="P">Clears modification flag.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::IsModified()const" class="Y">virtual<span class="V"> </span>bool<span class="V">&nbsp;</span><span class="Z">IsModified</span><span class="V">()&nbsp;</span>const</p>
<p class="P">Returns the value modification flag.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::Accept()" class="W"><span class="H">virtual</span> <span class="H">bool</span>&nbsp;<span class="I">Accept</span>()</p>
<p class="P">This virtual method is called when value of Ctrl is about to be accepted. Default implementation calls Accept for all child Ctrls and returns false if any of child Ctrls returns false, true otherwise.</p>
<p class="P">Typical use is when user pressed OK button. If any Ctrl of dialog returns false, OK is canceled.</p>
<p class="P">Typical implementation of this method should test whether current state of Ctrl (its edited value) matches requirements. If it does, it should finish editing, accept edited value and return true. Otherwise it should return false, </p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Ctrl should return true if it successfully finished editing, false otherwise.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::Reject()" class="W"><span class="H">virtual</span> <span class="H">void</span>&nbsp;<span class="I">Reject</span>()</p>
<p class="P">This virtual method is called when Ctrl should abort editing, discarding edited value. Default implementation calls Reject for all child Ctrls.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::Serialize(Stream&)" class="W"><span class="H">virtual</span> <span class="H">void</span>&nbsp;<span class="I">Serialize</span>(<u>Stream</u><span class="H">&amp;</span>&nbsp;<span class="J">s</span>)</p>
<p class="P">Serialization method. Should serialize the value of Ctrl in a way that is suitable for dialog backup and optional restore (e.g. when user presses Cancel button).</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::Jsonize(JsonIO&)" class="W"><span class="H">virtual</span> <span class="H">void</span>&nbsp;<span class="I">Jsonize</span>(<a href="JsonIO"><u>JsonIO</u></a><span class="H">&amp;</span>&nbsp;<span class="J">jio</span>)</p>
<p class="X">Method to convert the data of widget to/from JSON. Default implementation calls Jsonize for Value obtained/set by GetData/SetData.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::Xmlize(XmlIO&)" class="W"><span class="H">virtual</span> <span class="H">void</span>&nbsp;<span class="I">Xmlize</span>(<a href="XmlIO"><u>XmlIO</u></a><span class="H">&amp;</span>&nbsp;<span class="J">xio</span>)</p>
<p class="X">Method to convert the data of widget to/from XML. Default implementation calls Jsonize for Value obtained/set by GetData/SetData.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::AddChild(Ctrl*)" class="W"><span class="H">void</span>&nbsp;<span class="I">AddChild</span>(<u>Ctrl</u>&nbsp;*<span class="J">child</span>)</p>
<p class="P">Adds a child Ctrl as last one.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">child</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Pointer to child Ctrl at the end of child list. Note that U++ never takes ownership of Ctrls - never calls delete for <span class="AC">child. </span>That allows using non-heap based Ctrls. </p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::AddChild(Ctrl*,Ctrl*)" class="W"><span class="H">void</span>&nbsp;<span class="I">AddChild</span>(<u>Ctrl</u>&nbsp;*<span class="J">child</span>, <u>Ctrl</u>&nbsp;*<span class="J">insafter</span>)</p>
<p class="P">Inserts child Ctrl after another Ctrl that is already child. If <span class="J">insafter</span> is NULL, child is inserted as the first child.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">child</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Pointer to child Ctrl.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">insafter</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Ctrl that will be before inserted Ctrl.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::AddChildBefore(Ctrl*,Ctrl*)" class="W"><span class="H">void</span>&nbsp;<span class="I">AddChildBefore</span>(<u>Ctrl</u>&nbsp;*<span class="J">child</span>, <u>Ctrl</u>&nbsp;*<span class="J">insbefore</span>)</p>
<p class="P">Inserts child Ctrl before another Ctrl that is already child. If <span class="J">insbefore</span>, child is inserted as last child.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">child</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Pointer to child Ctrl.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">insbefore</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Ctrl that will be after inserted Ctrl.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::RemoveChild(Ctrl*)" class="W"><span class="H">void</span>&nbsp;<span class="I">RemoveChild</span>(<u>Ctrl</u>&nbsp;*<span class="J">child</span>)</p>
<p class="P">Removes Ctrl from child list. Ctrl is never deleted.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">child</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Child to be removed.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::GetParent()const" class="Y"><span class="V"><u>Ctrl</u></span><span class="V">&nbsp;*</span><span class="Z">GetParent</span><span class="V">()&nbsp;</span>const</p>
<p class="P">Returns parent of Ctrl or NULL if Ctrl is topmost.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Pointer to parent Ctrl.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::GetLastChild()const" class="Y"><span class="V"><u>Ctrl</u></span><span class="V">&nbsp;*</span><span class="Z">GetLastChild</span><span class="V">()&nbsp;</span>const</p>
<p class="P">Returns last child.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Pointer to last child or NULL if Ctrl has no children.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::GetFirstChild()const" class="Y"><span class="V"><u>Ctrl</u></span><span class="V">&nbsp;*</span><span class="Z">GetFirstChild</span><span class="V">()&nbsp;</span>const</p>
<p class="P">Returns first child.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Pointer to first child or NULL if Ctrl has no children.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::GetPrev()const" class="Y"><span class="V"><u>Ctrl</u></span><span class="V">&nbsp;*</span><span class="Z">GetPrev</span><span class="V">()&nbsp;</span>const</p>
<p class="P">Returns child that is before this Ctrl in child list or NULL if Ctrl is first or not in list.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Pointer to previous child or NULL.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::GetNext()const" class="Y"><span class="V"><u>Ctrl</u></span><span class="V">&nbsp;*</span><span class="Z">GetNext</span><span class="V">()&nbsp;</span>const</p>
<p class="P">Returns next child that is after this Ctrl in child list or NULL if Ctrl is last or not in list.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Pointer to next child or NULL.</p></td></tr></table>
<p class="F">&nbsp;</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::GetChildIndex(const Ctrl*)const" class="Y">int<span class="V">&nbsp;</span><span class="Z">GetChildIndex</span><span class="V">(</span>const<span class="V">&nbsp;</span><a href="Ctrl"><span class="V"><u>Ctrl</u></span></a><span class="V">&nbsp;*</span><span class="J">child</span><span class="V">)&nbsp;</span>const</p>
<p class="X">Returns the index of <span class="J">child</span> (first child has index 0, second child 1 etc...). If <span class="J">child</span> is not present in this Ctrl, returns -1. Note that this function performs sequential scan of child (results in O(n) complexity).</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::GetChildCount()const" class="Y">int<span class="V">&nbsp;</span><span class="Z">GetChildCount</span><span class="V">()&nbsp;</span>const</p>
<p class="X">Returns the number of child ctrls. Note that this function performs sequential scan of child (results in O(n) complexity).</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Upp::Ctrl::GetAscendant()const" class="Y">template<span class="V">&nbsp;&lt;</span>class<span class="V">&nbsp;</span><span class="AD">T</span><span class="V">&gt;&nbsp;</span><span class="AD">T</span><span class="V">&nbsp;*</span><span class="Z">GetAscendant</span><span class="V">()&nbsp;</span>const</p>
<p class="X">Returns first ascendant (parent, parent of parent etc..) that has type <span class="AD">T</span>.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::GetIndexChild(int)const" class="Y"><a href="Ctrl"><span class="V"><u>Ctrl</u></span></a><span class="V">&nbsp;*</span><span class="Z">GetIndexChild</span><span class="V">(</span>int<span class="V">&nbsp;</span><span class="J">i</span><span class="V">)&nbsp;</span>const</p>
<p class="X">Retruns child at index <span class="J">i</span> or NULL if there is none. Note that this function performs sequential scan of child (results in O(n) complexity).</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Upp::Ctrl::GetViewChildIndex(const Upp::Ctrl*)const" class="Y">int<span class="V">&nbsp;</span><span class="Z">GetViewChildIndex</span><span class="V">(</span>const<span class="V">&nbsp;</span><a href="Upp::Ctrl"><span class="V"><u>Ctrl</u></span></a><span class="V">&nbsp;*</span><span class="J">child</span><span class="V">)&nbsp;</span>const</p>
<p class="X">Returns the index of view <span class="J">child</span> (first child has index 0, second child 1 etc...). If <span class="J">child</span> is not present in this Ctrl or is in frame, returns -1. Note that this function performs sequential scan of child (results in O(n) complexity). This is similar to GetChildIndex, but frame widgets are ignored.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Upp::Ctrl::GetViewChildCount()const" class="Y">int<span class="V">&nbsp;</span><span class="Z">GetViewChildCount</span><span class="V">()&nbsp;</span>const</p>
<p class="X">Returns the number of child ctrls. Note that this function performs sequential scan of child (results in O(n) complexity). This is similar to GetChildCount, but frame widgets are ignored.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Upp::Ctrl::GetViewIndexChild(int)const" class="Y"><a href="Upp::Ctrl"><span class="V"><u>Ctrl</u></span></a><span class="V">&nbsp;*</span><span class="Z">GetViewIndexChild</span><span class="V">(</span>int<span class="V">&nbsp;</span><span class="J">ii</span><span class="V">)&nbsp;</span>const</p>
<p class="X">Retruns view child at index <span class="J">i</span> or NULL if there is none. Note that this function performs sequential scan of child (results in O(n) complexity). This is similar to GetIndexChild, but frame widgets are ignored.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::IsChild()const" class="Y">bool<span class="V">&nbsp;</span><span class="Z">IsChild</span><span class="V">()&nbsp;</span>const</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">True if Ctrl has parent.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::ChildFromPoint(Point&)const" class="Y"><span class="V"><u>Ctrl</u></span><span class="V">&nbsp;*</span><span class="Z">ChildFromPoint</span><span class="V">(</span><span class="V"><u>Point</u></span>&amp;<span class="V">&nbsp;</span><span class="J">pt</span><span class="V">)&nbsp;</span>const</p>
<p class="P">Checks whether opened top-level Ctrl is foreground.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">True if Ctrl is foreground.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::IsForeground()const" class="Y">bool<span class="V">&nbsp;</span><span class="Z">IsForeground</span><span class="V">()&nbsp;</span>const</p>
<p class="X">Returns true if Ctrl or its top-level parent is foreground window.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::SetForeground()" class="W"><span class="H">void</span>&nbsp;<span class="I">SetForeground</span>()</p>
<p class="P">Asks platform to put top-level Ctrl to foreground.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::GetTopCtrl()const" class="Y">const<span class="V">&nbsp;</span><a href="Ctrl"><span class="V"><u>Ctrl</u></span></a><span class="V">&nbsp;*</span><span class="Z">GetTopCtrl</span><span class="V">()&nbsp;</span>const</p>
<p class="X">Gets the top-level Ctrl, that is Ctrl that has this Ctrl in child tree and has no parent.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Pointer to top-level Ctrl. Can return this.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::GetTopCtrl()" class="W"><a href="Ctrl"><u>Ctrl</u></a>&nbsp;*<span class="I">GetTopCtrl</span>()</p>
<p class="X">Gets the top-level Ctrl, that is Ctrl that has this Ctrl in child tree and has no parent.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Pointer to top-level Ctrl. Can return this.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::GetOwner()const" class="Y">const<span class="V">&nbsp;</span><a href="Ctrl"><span class="V"><u>Ctrl</u></span></a><span class="V">&nbsp;*</span><span class="Z">GetOwner</span><span class="V">()&nbsp;</span>const</p>
<p class="X">Returns owner of top-level Ctrl. Example of owned window is dialog launched from main application window. Owner is another top-level Ctrl.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Pointer to owner top-level Ctrl or NULL is window is not owned.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::GetOwner()" class="W"><u>Ctrl</u>&nbsp;*<span class="I">GetOwner</span>()</p>
<p class="P">Returns owner of top-level Ctrl.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Pointer to owner top-level Ctrl or NULL is window is not owned.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::GetTopCtrlOwner()const" class="Y">const<span class="V">&nbsp;</span><a href="Ctrl"><span class="V"><u>Ctrl</u></span></a><span class="V">&nbsp;*</span><span class="Z">GetTopCtrlOwner</span><span class="V">()&nbsp;</span>const</p>
<p class="X">Equivalent to GetTopCtrl()-&gt;GetOwner() call.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Pointer to owner of top-level Ctrl.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::GetTopCtrlOwner()" class="W"><u>Ctrl</u>&nbsp;*<span class="I">GetTopCtrlOwner</span>()</p>
<p class="P">Equivalent to GetTopCtrl()-&gt;GetOwner() call.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Pointer to owner of top-level Ctrl.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::GetOwnerCtrl()" class="W"><u>Ctrl</u>&nbsp;*<span class="I">GetOwnerCtrl</span>()</p>
<p id="Ctrl::GetOwnerCtrl()const" class="AE">const<span class="AF">&nbsp;</span><span class="AF">Ctrl</span><span class="AF">&nbsp;*</span><span class="V">GetOwnerCtrl</span><span class="AF">()&nbsp;</span>const</p>
<p class="P">Returns the owner Ctrl. Unlike GetOwner, it returns actual widget that was used as &quot;owner&quot; parameter in Open or PopUp calls.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::GetTopWindow()const" class="Y">const<span class="V">&nbsp;</span><a href="TopWindow"><span class="V"><u>TopWindow</u></span></a><span class="V">&nbsp;*</span><span class="Z">GetTopWindow</span><span class="V">()&nbsp;</span>const</p>
<p class="X">TopWindow that contains this Ctrl.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Pointer to TopWindow.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::GetTopWindow()" class="W"><u>TopWindow</u>&nbsp;*<span class="I">GetTopWindow</span>()</p>
<p class="P">TopWindow that contains this Ctrl.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Pointer to TopWindow.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::GetMainWindow()const" class="Y">const<span class="V">&nbsp;</span><a href="TopWindow"><span class="V"><u>TopWindow</u></span></a><span class="V">&nbsp;*</span><span class="Z">GetMainWindow</span><span class="V">()&nbsp;</span>const</p>
<p class="X">Returns main window (one with no owner) that directly or indirectly owns this Ctrl.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Pointer to main window.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::GetMainWindow()" class="W"><u>TopWindow</u>&nbsp;*<span class="I">GetMainWindow</span>()</p>
<p class="P">Returns main window (one with no owner) that directly or indirectly owns this Ctrl.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Pointer to main window.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::SetFrame(int,CtrlFrame&)" class="W"><u>Ctrl</u><span class="H">&amp;</span>&nbsp;<span class="I">SetFrame</span>(<span class="H">int</span>&nbsp;<span class="J">i</span>, <u>CtrlFrame</u><span class="H">&amp;</span>&nbsp;<span class="J">frm</span>)</p>
<p class="P">Sets Frame at given position. If there is no such position yet, required number of NullFrame frames is added. Only reference to frame is stored, that means that frame must exists during the time it is used in Ctrl. Also, some frames can also be used for multiple Ctrls.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">i</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Position. First frame with i == 0 is outermost.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">frm</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Reference to frame.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Returns *this to allow chaining of method calls.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::SetFrame(CtrlFrame&)" class="W"><u>Ctrl</u><span class="H">&amp;</span>&nbsp;<span class="I">SetFrame</span>(<u>CtrlFrame</u><span class="H">&amp;</span>&nbsp;<span class="J">frm</span>)</p>
<p class="P">Sets frame at position 0.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">frm</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Reference to frame.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">*this.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::AddFrame(CtrlFrame&)" class="W"><u>Ctrl</u><span class="H">&amp;</span>&nbsp;<span class="I">AddFrame</span>(<u>CtrlFrame</u><span class="H">&amp;</span>&nbsp;<span class="J">frm</span>)</p>
<p class="P">Adds frame at inner-most position.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">frm</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Reference to frame.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">*this.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::GetFrame(int)const" class="Y">const<span class="V">&nbsp;</span><span class="V"><u>CtrlFrame</u></span>&amp;<span class="V">&nbsp;</span><span class="Z">GetFrame</span><span class="V">(</span>int<span class="V">&nbsp;</span><span class="J">i</span><span class="V">&nbsp;=&nbsp;</span><span class="AC">0</span><span class="V">)&nbsp;</span>const</p>
<p class="P">Returns reference to frame at given position.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">i</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Position.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Reference to frame.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::GetFrame(int)" class="W"><a href="CtrlFrame"><u>CtrlFrame</u></a><span class="H">&amp;</span>&nbsp;<span class="I">GetFrame</span>(<span class="H">int</span>&nbsp;<span class="J">i</span>&nbsp;=&nbsp;<span class="AC">0</span>)</p>
<p class="X">Returns reference to frame at given position.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">i</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Position.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Reference to frame.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::RemoveFrame(int)" class="W"><span class="H">void</span>&nbsp;<span class="I">RemoveFrame</span>(<span class="H">int</span>&nbsp;<span class="J">i</span>)</p>
<p class="X">Removes frame at given position.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">i</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Index of frame.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::RemoveFrame(CtrlFrame&)" class="W"><span class="H">void</span>&nbsp;<span class="I">RemoveFrame</span>(<u>CtrlFrame</u><span class="H">&amp;</span>&nbsp;<span class="J">frm</span>)</p>
<p class="P">Removes first frame equal to <span class="AC">frm</span>. Equality means here that pointers to both frames are the same (it is same instance).</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">frm</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Frame to remove.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::InsertFrame(int,CtrlFrame&)" class="W"><span class="H">void</span>&nbsp;<span class="I">InsertFrame</span>(<span class="H">int</span>&nbsp;<span class="J">i</span>, <u>CtrlFrame</u><span class="H">&amp;</span>&nbsp;<span class="J">frm</span>)</p>
<p class="P">Inserts frame at given position.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">i</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Position.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">frm</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Reference to frame.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::FindFrame(CtrlFrame&)" class="W"><span class="H">int</span>&nbsp;<span class="I">FindFrame</span>(<u>CtrlFrame</u><span class="H">&amp;</span>&nbsp;<span class="J">frm</span>)</p>
<p class="P">Finds first frame equal to <span class="AC">frm</span>. Equality means here that pointers to both frames are the same (it is same instance).</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">frm</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Frame to find.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Index of frame or negative value if frame is not found.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::GetFrameCount()const" class="Y">int<span class="V">&nbsp;</span><span class="Z">GetFrameCount</span><span class="V">()&nbsp;</span>const</p>
<p class="P">Returns count of frames in Ctrl.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Count of frames.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::ClearFrames()" class="W"><span class="H">void</span>&nbsp;<span class="I">ClearFrames</span>()</p>
<p class="P">Removes all frames from Ctrl. Frame at position 0 then added and set to NullFrame.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::IsOpen()const" class="Y">bool<span class="V">&nbsp;</span><span class="Z">IsOpen</span><span class="V">()&nbsp;</span>const</p>
<p class="P">Checks whether top-level Ctrl of this Ctrl is open.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">true if open.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::Shutdown()" class="W"><span class="H">void</span>&nbsp;<span class="I">Shutdown</span>()</p>
<p class="P">Sets internal flag indicating that Ctrl is being destructed. This is rarely used to solve some destruction order problems.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::IsShutdown()const" class="Y">bool<span class="V">&nbsp;</span><span class="Z">IsShutdown</span><span class="V">()&nbsp;</span>const</p>
<p class="P">Checks whether internal shutdown flag is set.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">True if in shutdown mode.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::SetPos(Ctrl::LogPos,bool)" class="W"><u>Ctrl</u><span class="H">&amp;</span>&nbsp;<span class="I">SetPos</span>(<u>LogPos</u>&nbsp;<span class="J">p</span>, <span class="H">bool</span>&nbsp;<span class="J">inframe</span>)</p>
<p class="P">Sets <a href="topic://CtrlCore/src/LogPos$en-us">logical position</a> of Ctrl. If Ctrl is top-level, logical position must be of left-top type.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">p</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Logical position.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">inframe</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">If true, Ctrl is placed into <a href="topic://CtrlCore/src/AboutFrames$en-us">frame area</a> instead of view area</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">*this.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::SetPos(Ctrl::LogPos)" class="W"><u>Ctrl</u><span class="H">&amp;</span>&nbsp;<span class="I">SetPos</span>(<u>LogPos</u>&nbsp;<span class="J">p</span>)</p>
<p class="P">Sets logical position of Ctrl in view area.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">p</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Logical position.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">*this.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::SetPos(Ctrl::Logc,Ctrl::Logc)" class="W"><u>Ctrl</u><span class="H">&amp;</span>&nbsp;<span class="I">SetPos</span>(<u>Logc</u>&nbsp;<span class="J">x</span>, <u>Logc</u>&nbsp;<span class="J">y</span>)</p>
<p class="P">Sets logical position by individual coordinates (in view area).</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">x</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Horizontal logical position.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">y</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Vertical logical postion.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">*this.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::SetPosX(Ctrl::Logc)" class="W"><u>Ctrl</u><span class="H">&amp;</span>&nbsp;<span class="I">SetPosX</span>(<u>Logc</u>&nbsp;<span class="J">x</span>)</p>
<p class="P">Sets horizontal logical position only (in view area).</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">x</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Horizontal logical position.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">*this.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::SetPosY(Ctrl::Logc)" class="W"><u>Ctrl</u><span class="H">&amp;</span>&nbsp;<span class="I">SetPosY</span>(<u>Logc</u>&nbsp;<span class="J">y</span>)</p>
<p class="P">Sets vertical logical position only (in view area).</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">y</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Vertical logical position.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">*this.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::SetRect(const Rect&)" class="W"><span class="H">void</span>&nbsp;<span class="I">SetRect</span>(<span class="H">const</span>&nbsp;<u>Rect</u><span class="H">&amp;</span>&nbsp;<span class="J">r</span>)</p>
<p class="P">Sets left-top logical position (in view area).</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">r</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Rectangle determines left-top position.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::SetRect(int,int,int,int)" class="W"><span class="H">void</span>&nbsp;<span class="I">SetRect</span>(<span class="H">int</span>&nbsp;<span class="J">x</span>, <span class="H">int</span>&nbsp;<span class="J">y</span>, <span class="H">int</span>&nbsp;<span class="J">cx</span>, <span class="H">int</span>&nbsp;<span class="J">cy</span>)</p>
<p class="P">Sets left-top logical position (in view area).</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">x</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Distance between parent rectangle left-edge and Ctrl.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">y</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Distance between parent rectangle top-edge and Ctrl.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">cx</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Horizontal size.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">cy</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Vertical size.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::SetRectX(int,int)" class="W"><span class="H">void</span>&nbsp;<span class="I">SetRectX</span>(<span class="H">int</span>&nbsp;<span class="J">x</span>, <span class="H">int</span>&nbsp;<span class="J">cx</span>)</p>
<p class="P">Sets left horizontal logical position (in view area).</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">x</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Distance between parent rectangle left-edge and Ctrl.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">cx</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Horizontal size.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::SetRectY(int,int)" class="W"><span class="H">void</span>&nbsp;<span class="I">SetRectY</span>(<span class="H">int</span>&nbsp;<span class="J">y</span>, <span class="H">int</span>&nbsp;<span class="J">cy</span>)</p>
<p class="P">Sets top vertical logical position (in view area).</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">y</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Distance between parent rectangle top-edge and Ctrl.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">cy</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Vertical size.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::SetFramePos(Ctrl::LogPos)" class="W"><u>Ctrl</u><span class="H">&amp;</span>&nbsp;<span class="I">SetFramePos</span>(<u>LogPos</u>&nbsp;<span class="J">p</span>)</p>
<p class="P">Sets logical position of Ctrl in frame area.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">p</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Logical position.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">*this.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::SetFramePos(Ctrl::Logc,Ctrl::Logc)" class="W"><u>Ctrl</u><span class="H">&amp;</span>&nbsp;<span class="I">SetFramePos</span>(<u>Logc</u>&nbsp;<span class="J">x</span>, <u>Logc</u>&nbsp;<span class="J">y</span>)</p>
<p class="P">Sets logical position by individual coordinates (in frame area).</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">x</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Horizontal logical position.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">y</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Vertical logical postion.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">*this.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::SetFramePosX(Ctrl::Logc)" class="W"><u>Ctrl</u><span class="H">&amp;</span>&nbsp;<span class="I">SetFramePosX</span>(<u>Logc</u>&nbsp;<span class="J">x</span>)</p>
<p class="P">Sets horizontal logical position only (in frame area).</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">x</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Horizontal logical position.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">*this.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::SetFramePosY(Ctrl::Logc)" class="W"><u>Ctrl</u><span class="H">&amp;</span>&nbsp;<span class="I">SetFramePosY</span>(<u>Logc</u>&nbsp;<span class="J">y</span>)</p>
<p class="P">Sets vertical logical position only (in frame area).</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">y</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Vertical logical position.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">*this.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::SetFrameRect(const Rect&)" class="W"><span class="H">void</span>&nbsp;<span class="I">SetFrameRect</span>(<span class="H">const</span>&nbsp;<u>Rect</u><span class="H">&amp;</span>&nbsp;<span class="J">r</span>)</p>
<p class="P">Sets left-top logical position (in frame area).</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">r</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Rectangle determines left-top position.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::SetFrameRect(int,int,int,int)" class="W"><span class="H">void</span>&nbsp;<span class="I">SetFrameRect</span>(<span class="H">int</span>&nbsp;<span class="J">x</span>, <span class="H">int</span>&nbsp;<span class="J">y</span>, <span class="H">int</span>&nbsp;<span class="J">cx</span>, <span class="H">int</span>&nbsp;<span class="J">cy</span>)</p>
<p class="P">Sets left-top logical position (in frame area).</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">x</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Distance between parent rectangle left-edge and Ctrl.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">y</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Distance between parent rectangle top-edge and Ctrl.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">cx</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Horizontal size.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">cy</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Vertical size.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::SetFrameRectX(int,int)" class="W"><span class="H">void</span>&nbsp;<span class="I">SetFrameRectX</span>(<span class="H">int</span>&nbsp;<span class="J">x</span>, <span class="H">int</span>&nbsp;<span class="J">cx</span>)</p>
<p class="P">Sets left horizontal logical position (in frame area).</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">x</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Distance between parent rectangle left-edge and Ctrl.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">cx</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Horizontal size.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::SetFrameRectY(int,int)" class="W"><span class="H">void</span>&nbsp;<span class="I">SetFrameRectY</span>(<span class="H">int</span>&nbsp;<span class="J">y</span>, <span class="H">int</span>&nbsp;<span class="J">cy</span>)</p>
<p class="P">Sets top vertical logical position (in frame area).</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">y</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Distance between parent rectangle top-edge and Ctrl.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">cy</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Vertical size.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::InFrame()const" class="Y">bool<span class="V">&nbsp;</span><span class="Z">InFrame</span><span class="V">()&nbsp;</span>const</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">true when Ctrl has position in frame area.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::InView()const" class="Y">bool<span class="V">&nbsp;</span><span class="Z">InView</span><span class="V">()&nbsp;</span>const</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">true when Ctrl has position in view area.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::GetPos()const" class="Y"><span class="V"><u>LogPos</u></span><span class="V">&nbsp;</span><span class="Z">GetPos</span><span class="V">()&nbsp;</span>const</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Logical position of Ctrl</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::RefreshLayout()" class="W"><span class="H">void</span>&nbsp;<span class="I">RefreshLayout</span>()</p>
<p class="P">Recomputes layout for Ctrl. This includes calling FrameLayout for all frames and calling Layout virtual method. Layout of child widgets is recomputed if their size changes.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::RefreshLayoutDeep()" class="W"><span class="H">void</span>&nbsp;<span class="I">RefreshLayoutDeep</span>()</p>
<p class="X">Recomputes layout for the whole Ctrl tree - unlike RefreshLayout, recomputes layout of all descendants regardless whether their size has changed.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::RefreshParentLayout()" class="W"><span class="H">void</span>&nbsp;<span class="I">RefreshParentLayout</span>()</p>
<p class="P">If Ctrl has parent, calls parent-&gt;RefreshLayout().</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::UpdateLayout()" class="W"><span class="H">void</span>&nbsp;<span class="I">UpdateLayout</span>()</p>
<p class="X">Recomputes layout of widget by recalculating its frame coverage, then, if view size has changed, calls Layout method (this is the difference from RefreshLayout, which calls Layout always). Layout of child widgets is recomputed if their size changes.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::UpdateParentLayout()" class="W"><span class="H">void</span>&nbsp;<span class="I">UpdateParentLayout</span>()</p>
<p class="X">Calls UpdateLayout for parent (if exists).</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::LeftPos(int,int)" class="W"><u>Ctrl</u><span class="H">&amp;</span>&nbsp;<span class="I">LeftPos</span>(<span class="H">int</span>&nbsp;<span class="J">a</span>, <span class="H">int</span>&nbsp;<span class="J">size</span>&nbsp;=&nbsp;STDSIZE)</p>
<p class="P">Sets left horizontal position (in view area).</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">a</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Distance from left border of parent.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">size</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Horizontal size.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">*this for method chaining.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::RightPos(int,int)" class="W"><u>Ctrl</u><span class="H">&amp;</span>&nbsp;<span class="I">RightPos</span>(<span class="H">int</span>&nbsp;<span class="J">a</span>, <span class="H">int</span>&nbsp;<span class="J">size</span>&nbsp;=&nbsp;STDSIZE)</p>
<p class="P">Sets right horizontal position (in view area).</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">a</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Distance from the right border of parent.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">size</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Horizontal size.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">*this for method chaining.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::TopPos(int,int)" class="W"><u>Ctrl</u><span class="H">&amp;</span>&nbsp;<span class="I">TopPos</span>(<span class="H">int</span>&nbsp;<span class="J">a</span>, <span class="H">int</span>&nbsp;<span class="J">size</span>&nbsp;=&nbsp;STDSIZE)</p>
<p class="P">Sets top vertical position (in view area).</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">a</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Distance from the top border of parent.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">size</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Vertical size.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">*this for method chaining.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::BottomPos(int,int)" class="W"><u>Ctrl</u><span class="H">&amp;</span>&nbsp;<span class="I">BottomPos</span>(<span class="H">int</span>&nbsp;<span class="J">a</span>, <span class="H">int</span>&nbsp;<span class="J">size</span>&nbsp;=&nbsp;STDSIZE)</p>
<p class="P">Sets bottom vertical position (in view area).</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">a</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Distance from the bottom border of parent.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">size</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Vertical size.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">*this for method chaining.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::HSizePos(int,int)" class="W"><u>Ctrl</u><span class="H">&amp;</span>&nbsp;<span class="I">HSizePos</span>(<span class="H">int</span>&nbsp;<span class="J">a</span>&nbsp;=&nbsp;<span class="AC">0</span>, <span class="H">int</span>&nbsp;<span class="J">b</span>&nbsp;=&nbsp;<span class="AC">0</span>)</p>
<p class="P">Sets horizontal sizing position (in view area).</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">a</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Distance from left border of parent.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">b</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Distance from right border of parent.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">*this for method chaining.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::VSizePos(int,int)" class="W"><u>Ctrl</u><span class="H">&amp;</span>&nbsp;<span class="I">VSizePos</span>(<span class="H">int</span>&nbsp;<span class="J">a</span>&nbsp;=&nbsp;<span class="AC">0</span>, <span class="H">int</span>&nbsp;<span class="J">b</span>&nbsp;=&nbsp;<span class="AC">0</span>)</p>
<p class="P">Sets vertical sizing position (in view area).</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">a</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Distance form top border of parent.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">b</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Distance from bottom border of parent.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">*this for method chaining.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::SizePos()" class="W"><u>Ctrl</u><span class="H">&amp;</span>&nbsp;<span class="I">SizePos</span>()</p>
<p class="P">Same as VSizePos().HSizePos().</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">*this for method chaining.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::HCenterPos(int,int)" class="W"><u>Ctrl</u><span class="H">&amp;</span>&nbsp;<span class="I">HCenterPos</span>(<span class="H">int</span>&nbsp;<span class="J">size</span>&nbsp;=&nbsp;STDSIZE, <span class="H">int</span>&nbsp;<span class="J">delta</span>&nbsp;=&nbsp;<span class="AC">0</span>)</p>
<p class="P">Horizontal centered position (in view area).</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">size</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Horizontal size.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">delta</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Offset from centered position (rarely used).</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">*this for method chaining.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::VCenterPos(int,int)" class="W"><u>Ctrl</u><span class="H">&amp;</span>&nbsp;<span class="I">VCenterPos</span>(<span class="H">int</span>&nbsp;<span class="J">size</span>&nbsp;=&nbsp;STDSIZE, <span class="H">int</span>&nbsp;<span class="J">delta</span>&nbsp;=&nbsp;<span class="AC">0</span>)</p>
<p class="P">Vertical centered position (in view area).</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">size</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Vertical size.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">delta</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Offset from centered position (rarely used).</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">*this for method chaining.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::LeftPosZ(int,int)" class="W"><u>Ctrl</u><span class="H">&amp;</span>&nbsp;<span class="I">LeftPosZ</span>(<span class="H">int</span>&nbsp;<span class="J">a</span>, <span class="H">int</span>&nbsp;<span class="J">size</span>&nbsp;=&nbsp;STDSIZE)</p>
<p class="P">Sets left horizontal <span class="AA">zoomed </span>position (in view area). Distances are recalculated using zoom factor to accommodate size differences between standard font used during layout design and actual standard font.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">a</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Distance from the left border of parent.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">size</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Horizontal size.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">*this for method chaining.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::RightPosZ(int,int)" class="W"><u>Ctrl</u><span class="H">&amp;</span>&nbsp;<span class="I">RightPosZ</span>(<span class="H">int</span>&nbsp;<span class="J">a</span>, <span class="H">int</span>&nbsp;<span class="J">size</span>&nbsp;=&nbsp;STDSIZE)</p>
<p class="P">Sets right horizontal <span class="AA">zoomed </span>position (in view area). Distances are recalculated using zoom factor to accommodate size differences between standard font used during layout design and actual standard font.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">a</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Distance from the right border of parent.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">size</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Horizontal size.</p></td></tr></table>
<p class="P"><span class="R">Return value</span>&nbsp;&nbsp;&nbsp;&nbsp;*this for method chaining.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::TopPosZ(int,int)" class="W"><u>Ctrl</u><span class="H">&amp;</span>&nbsp;<span class="I">TopPosZ</span>(<span class="H">int</span>&nbsp;<span class="J">a</span>, <span class="H">int</span>&nbsp;<span class="J">size</span>&nbsp;=&nbsp;STDSIZE)</p>
<p class="P">Sets top vertical <span class="AA">zoomed </span>position (in view area). Distances are recalculated using zoom factor to accommodate size differences between standard font used during layout design and actual standard font.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">a</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Distance from the top border of parent.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">size</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Vertical size.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">*this for method chaining.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::BottomPosZ(int,int)" class="W"><u>Ctrl</u><span class="H">&amp;</span>&nbsp;<span class="I">BottomPosZ</span>(<span class="H">int</span>&nbsp;<span class="J">a</span>, <span class="H">int</span>&nbsp;<span class="J">size</span>&nbsp;=&nbsp;STDSIZE)</p>
<p class="P">Sets bottom vertical <span class="AA">zoomed </span>position (in view area). Distances are recalculated using zoom factor to accommodate size differences between standard font used during layout design and actual standard font.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">a</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Distance from the bottom border of parent.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">size</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Vertical size.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">*this for method chaining.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::HSizePosZ(int,int)" class="W"><u>Ctrl</u><span class="H">&amp;</span>&nbsp;<span class="I">HSizePosZ</span>(<span class="H">int</span>&nbsp;<span class="J">a</span>&nbsp;=&nbsp;<span class="AC">0</span>, <span class="H">int</span>&nbsp;<span class="J">b</span>&nbsp;=&nbsp;<span class="AC">0</span>)</p>
<p class="P">Sets vertical <span class="AA">zoomed </span>sizing position (in view area). Distances are recalculated using zoom factor to accommodate size differences between standard font used during layout design and actual standard font.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">a</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Distance form top border of parent.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">b</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Distance from bottom border of parent.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">*this for method chaining.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::VSizePosZ(int,int)" class="W"><u>Ctrl</u><span class="H">&amp;</span>&nbsp;<span class="I">VSizePosZ</span>(<span class="H">int</span>&nbsp;<span class="J">a</span>&nbsp;=&nbsp;<span class="AC">0</span>, <span class="H">int</span>&nbsp;<span class="J">b</span>&nbsp;=&nbsp;<span class="AC">0</span>)</p>
<p class="P">Sets vertical <span class="AA">zoomed </span>sizing position (in view area). Distances are recalculated using zoom factor to accommodate size differences between standard font used during layout design and actual standard font.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">a</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Distance form top border of parent.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">b</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Distance from bottom border of parent.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">*this for method chaining.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::HCenterPosZ(int,int)" class="W"><u>Ctrl</u><span class="H">&amp;</span>&nbsp;<span class="I">HCenterPosZ</span>(<span class="H">int</span>&nbsp;<span class="J">size</span>&nbsp;=&nbsp;STDSIZE, <span class="H">int</span>&nbsp;<span class="J">delta</span>&nbsp;=&nbsp;<span class="AC">0</span>)</p>
<p class="P">Horizontal centered <span class="AA">zoomed </span>position (in view area). Distances are recalculated using zoom factor to accommodate size differences between standard font used during layout design and actual standard font.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">size</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Horizontal size.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">delta</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Offset from centered position (rarely used).</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">*this for method chaining.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::VCenterPosZ(int,int)" class="W"><u>Ctrl</u><span class="H">&amp;</span>&nbsp;<span class="I">VCenterPosZ</span>(<span class="H">int</span>&nbsp;<span class="J">size</span>&nbsp;=&nbsp;STDSIZE, <span class="H">int</span>&nbsp;<span class="J">delta</span>&nbsp;=&nbsp;<span class="AC">0</span>)</p>
<p class="P">Vertical centered <span class="AA">zoomed</span> position (in view area). Distances are recalculated using zoom factor to accommodate size differences between standard font used during layout design and actual standard font.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">size</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Vertical size.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">delta</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Offset from centered position (rarely used).</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">*this for method chaining.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::GetRect()const" class="Y"><span class="V"><u>Rect</u></span><span class="V">&nbsp;</span><span class="Z">GetRect</span><span class="V">()&nbsp;</span>const</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Returns current position in parent. It is either position in view or frame coordinates.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::GetScreenRect()const" class="Y"><span class="V"><u>Rect</u></span><span class="V">&nbsp;</span><span class="Z">GetScreenRect</span><span class="V">()&nbsp;</span>const</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Returns current position in absolute screen coordinates.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::GetView()const" class="Y"><span class="V"><u>Rect</u></span><span class="V">&nbsp;</span><span class="Z">GetView</span><span class="V">()&nbsp;</span>const</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Returns position of view rectangle in frame coordinates.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::GetScreenView()const" class="Y"><span class="V"><u>Rect</u></span><span class="V">&nbsp;</span><span class="Z">GetScreenView</span><span class="V">()&nbsp;</span>const</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Returns position of view rectangle in absolute screen coordinates.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::GetSize()const" class="Y"><span class="V"><u>Size</u></span><span class="V">&nbsp;</span><span class="Z">GetSize</span><span class="V">()&nbsp;</span>const</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Returns size of view rectangle of Ctrl.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::GetVisibleScreenRect()const" class="Y"><span class="V"><u>Rect</u></span><span class="V">&nbsp;</span><span class="Z">GetVisibleScreenRect</span><span class="V">()&nbsp;</span>const</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Returns current position in parent intersected with either parent's visible screen rectangle for frame Ctrl (as obtained using GetVisibleScreenRect) or parent's screen view rectangle for view Ctrl (obtained using GetVisibleScreenView). This method is useful when rectangle of Ctrl exceeds it's parent area - in this case this method returns part of Ctrl that is not clipped out by parent's are limits.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::GetVisibleScreenView()const" class="Y"><span class="V"><u>Rect</u></span><span class="V">&nbsp;</span><span class="Z">GetVisibleScreenView</span><span class="V">()&nbsp;</span>const</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Returns current position of view area intersected with either parent's visible screen rectangle for frame Ctrl (as obtained using GetVisibleScreenRect) or parent's screen view rectangle for view Ctrl (obtained using GetVisibleScreenView). This method is useful when rectangle of Ctrl exceeds it's parent area - in this case this method returns part of Ctrl view that is not clipped out by parent's are limits.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::GetWorkArea()const" class="Y"><a href="Rect"><span class="V"><u>Rect</u></span></a><span class="V">&nbsp;</span><span class="Z">GetWorkArea</span><span class="V">()&nbsp;</span>const</p>
<p class="X">Returns the work area (the maximum rectangle that window can use) for screen that this window is in.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::AddFrameSize(int,int)const" class="Y"><span class="V"><u>Size</u></span><span class="V">&nbsp;</span><span class="Z">AddFrameSize</span><span class="V">(</span>int<span class="V">&nbsp;</span><span class="J">cx</span><span class="V">, </span>int<span class="V">&nbsp;</span><span class="J">cy</span><span class="V">)&nbsp;</span>const</p>
<p class="P">Computes size of Ctrl for given size of view and actual set of frames.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">cx</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Width.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">cy</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Height.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Size of Ctrl that would have requested view size.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::AddFrameSize(Size)const" class="Y"><span class="V"><u>Size</u></span><span class="V">&nbsp;</span><span class="Z">AddFrameSize</span><span class="V">(</span><span class="V"><u>Size</u></span><span class="V">&nbsp;</span><span class="J">sz</span><span class="V">)&nbsp;</span>const</p>
<p class="P">Same as AddFrameSize(sz.cx, sz.cy).</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">sz</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Size.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Size of Ctrl that would have requested view size.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::Refresh(const Rect&)" class="W"><span class="H">void</span>&nbsp;<span class="I">Refresh</span>(<span class="H">const</span>&nbsp;<a href="Rect"><u>Rect</u></a><span class="H">&amp;</span>&nbsp;<span class="J">r</span>)</p>
<p class="X">Marks requested rectangle of view area for repainting. Actual repaint is deferred for performance reasons.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">r</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Rectangle in view.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::Refresh(int,int,int,int)" class="W"><span class="H">void</span>&nbsp;<span class="I">Refresh</span>(<span class="H">int</span>&nbsp;<span class="J">x</span>, <span class="H">int</span>&nbsp;<span class="J">y</span>, <span class="H">int</span>&nbsp;<span class="J">cx</span>, <span class="H">int</span>&nbsp;<span class="J">cy</span>)</p>
<p class="P">Marks requested rectangle of view area for repainting. Actual repaint is deferred for performance reasons.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">x</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Left position of rectangle.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">y</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Top position of rectangle.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">cx</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Width.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">cy</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Height.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::Refresh()" class="W"><span class="H">void</span>&nbsp;<span class="I">Refresh</span>()</p>
<p class="P">Marks whole view area for repainting.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::IsFullRefresh()const" class="Y">bool<span class="V">&nbsp;</span><span class="Z">IsFullRefresh</span><span class="V">()&nbsp;</span>const</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">true when whole view area is marked for repainting but was not repainted yet.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::RefreshFrame(const Rect&)" class="W"><span class="H">void</span>&nbsp;<span class="I">RefreshFrame</span>(<span class="H">const</span>&nbsp;<u>Rect</u><span class="H">&amp;</span>&nbsp;<span class="J">r</span>)</p>
<p class="P">Marks requested rectangle of frame area for repainting. Actual repainting is deferred for performance reasons.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">r</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Area to repaint.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::RefreshFrame(int,int,int,int)" class="W"><span class="H">void</span>&nbsp;<span class="I">RefreshFrame</span>(<span class="H">int</span>&nbsp;<span class="J">x</span>, <span class="H">int</span>&nbsp;<span class="J">y</span>, <span class="H">int</span>&nbsp;<span class="J">cx</span>, <span class="H">int</span>&nbsp;<span class="J">cy</span>)</p>
<p class="P">Marks requested rectangle of frame area for repainting. Actual repaint is deferred for performance reasons.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">x</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Left position of rectangle.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">y</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Top position of rectangle.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">cx</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Width.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">cy</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Height.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::RefreshFrame()" class="W"><span class="H">void</span>&nbsp;<span class="I">RefreshFrame</span>()</p>
<p class="P">Marks whole Ctrl area for repainting.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::ScrollView(const Rect&,int,int)" class="W"><span class="H">void</span>&nbsp;<span class="I">ScrollView</span>(<span class="H">const</span>&nbsp;<a href="Rect"><u>Rect</u></a><span class="H">&amp;</span>&nbsp;<span class="J">r</span>, <span class="H">int</span>&nbsp;<span class="J">dx</span>, <span class="H">int</span>&nbsp;<span class="J">dy</span>)</p>
<p class="X">Marks requested view rectangle for repainting, indicating that part of this repaint can be done by scrolling current content of rectangle. Note that actual scroll is deferred to repaint and that U++ is still allowed to solve the situation by repainting rather than scrolling.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">r</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Area for repainting.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">dx</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Horizontal scroll.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">dy</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Vertical scroll.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::ScrollView(int,int,int,int,int,int)" class="W"><span class="H">void</span>&nbsp;<span class="I">ScrollView</span>(<span class="H">int</span>&nbsp;<span class="J">x</span>, <span class="H">int</span>&nbsp;<span class="J">y</span>, <span class="H">int</span>&nbsp;<span class="J">cx</span>, <span class="H">int</span>&nbsp;<span class="J">cy</span>, <span class="H">int</span>&nbsp;<span class="J">dx</span>, <span class="H">int</span>&nbsp;<span class="J">dy</span>)</p>
<p class="P">Marks requested view rectangle for repainting, indicating that part of this repaint can be done by scrolling current content of rectangle. Note that actual scroll is deferred to repaint and that U++ is still allowed to solve the situation by repainting rather than scrolling.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">r</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Area for repainting.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">x</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Left position of rectangle.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">y</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Top position of rectangle.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">cx</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Width.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">cy</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Height.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">dx</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Horizontal scroll.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">dy</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Vertical scroll.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::ScrollView(int,int)" class="W"><span class="H">void</span>&nbsp;<span class="I">ScrollView</span>(<span class="H">int</span>&nbsp;<span class="J">dx</span>, <span class="H">int</span>&nbsp;<span class="J">dy</span>)</p>
<p class="P">Marks while view area for repainting, indicating that part of this repaint can be done by scrolling current content of rectangle. Note that actual scroll is deferred to repaint and that U++ is still allowed to solve the situation by repainting rather than scrolling.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">dx</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Horizontal scroll.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">dy</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Vertical scroll.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::ScrollView(const Rect&,Size)" class="W"><span class="H">void</span>&nbsp;<span class="I">ScrollView</span>(<span class="H">const</span>&nbsp;<u>Rect</u><span class="H">&amp;</span>&nbsp;<span class="J">r</span>, <u>Size</u>&nbsp;<span class="J">delta</span>)</p>
<p class="P">Same as ScrollView(r, delta.cx, delta.cy).</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::ScrollView(Size)" class="W"><span class="H">void</span>&nbsp;<span class="I">ScrollView</span>(<u>Size</u>&nbsp;<span class="J">delta</span>)</p>
<p class="P">Same as ScrollView(delta.cx, delta.cy).</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::Sync()" class="W"><span class="H">void</span>&nbsp;<span class="I">Sync</span>()</p>
<p class="P">Forces immediate repainting of areas marked using Refresh, RefreshFrame or ScrollView methods.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::Sync(const Rect&)" class="W"><span class="H">void</span>&nbsp;<span class="I">Sync</span>(<span class="H">const</span>&nbsp;<a href="Rect"><u>Rect</u></a><span class="H">&amp;</span>&nbsp;<span class="J">r</span>)</p>
<p class="X">Forces immediate repainting of areas marked using Refresh, RefreshFrame or ScrollView methods, limited with intersection of given rectangle.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">r</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Rectangle.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::OverrideCursor(const Image&)" class="W"><span class="H">static</span> <a href="Image"><u>Image</u></a>&nbsp;<span class="I">OverrideCursor</span>(<span class="H">const</span>&nbsp;<a href="Image"><u>Image</u></a><span class="H">&amp;</span>&nbsp;<span class="J">m</span>)</p>
<p class="X">Overrides mouse cursor to <span class="J">m</span>. To end the override, call it again with the Image returned by the override call.</p>
<p class="X">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::DrawCtrl(Draw&,int,int)" class="W"><span class="H">void</span>&nbsp;<span class="I">DrawCtrl</span>(<a href="Draw"><u>Draw</u></a><span class="H">&amp;</span>&nbsp;<span class="J">w</span>, <span class="H">int</span>&nbsp;<span class="J">x</span>&nbsp;=&nbsp;<span class="AC">0</span>, <span class="H">int</span>&nbsp;<span class="J">y</span>&nbsp;=&nbsp;<span class="AC">0</span>)</p>
<p class="X">Draws Ctrl at specified position. This is intended for utility purposes like taking screen-shots. This version Draws Ctrl <span class="AA">without</span> background (supplied by parent).</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">w</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Target Draw.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">x, </span><span class="Q">y</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Position.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::DrawCtrlWithParent(Draw&,int,int)" class="W"><span class="H">void</span>&nbsp;<span class="I">DrawCtrlWithParent</span>(<a href="Draw"><u>Draw</u></a><span class="H">&amp;</span>&nbsp;<span class="J">w</span>, <span class="H">int</span>&nbsp;<span class="J">x</span>&nbsp;=&nbsp;<span class="AC">0</span>, <span class="H">int</span>&nbsp;<span class="J">y</span>&nbsp;=&nbsp;<span class="AC">0</span>)</p>
<p class="X">Draws Ctrl at specified position. This is intended for utility purposes like taking screen-shots. This version Draws Ctrl <span class="AA">with</span> background (supplied by parent).</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">w</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Target Draw.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">x, </span><span class="Q">y</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Position.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::HasChild(Ctrl*)const" class="Y">bool<span class="V">&nbsp;</span><span class="Z">HasChild</span><span class="V">(</span><span class="V"><u>Ctrl</u></span><span class="V">&nbsp;*</span><span class="J">ctrl</span><span class="V">)&nbsp;</span>const</p>
<p class="P">Tests whether Ctrl has specified <span class="AA">direct</span> child.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">ctrl</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Child.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">true if ctrl is child.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::HasChildDeep(Ctrl*)const" class="Y">bool<span class="V">&nbsp;</span><span class="Z">HasChildDeep</span><span class="V">(</span><span class="V"><u>Ctrl</u></span><span class="V">&nbsp;*</span><span class="J">ctrl</span><span class="V">)&nbsp;</span>const</p>
<p class="P">Tests whether Ctrl has specified ctrl in its child tree (direct or indirect).</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">ctrl</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Child.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">true if ctrl is in child tree.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::IgnoreMouse(bool)" class="W"><u>Ctrl</u><span class="H">&amp;</span>&nbsp;<span class="I">IgnoreMouse</span>(<span class="H">bool</span>&nbsp;<span class="J">b</span>&nbsp;=&nbsp;<span class="H">true</span>)</p>
<p class="P">Sets ignore-mouse flag. When active, Ctrl is ignored for mouse input. That is important for static Ctrls that cover other Ctrls, like LabelBox - this flag ensures, that mouse input is not consumed by LabelBox, but is distributed to Ctrls that lay inside it.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">b</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Value of flag.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">*this for method chaining.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::NoIgnoreMouse()" class="W"><u>Ctrl</u><span class="H">&amp;</span>&nbsp;<span class="I">NoIgnoreMouse</span>()</p>
<p class="P">Same as IgnoreMouse(false).</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">*this for method chaining.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::IsIgnoreMouse()const" class="Y">bool<span class="V">&nbsp;</span><span class="Z">IsIgnoreMouse</span><span class="V">()&nbsp;</span>const</p>
<p class="X">Returns the ignore-mouse flag (see IgnoreMouse).</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::HasMouse()const" class="Y">bool<span class="V">&nbsp;</span><span class="Z">HasMouse</span><span class="V">()&nbsp;</span>const</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">true when Ctrl is target for mouse events.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::HasMouseDeep()const" class="Y">bool<span class="V">&nbsp;</span><span class="Z">HasMouseDeep</span><span class="V">()&nbsp;</span>const</p>
<p class="X">Returns true if Ctrl or any of its descendants is target for mouse events.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::HasMouseInFrame(const Rect&)const" class="Y">bool<span class="V">&nbsp;</span><span class="Z">HasMouseInFrame</span><span class="V">(</span>const<span class="V">&nbsp;</span><a href="Rect"><span class="V"><u>Rect</u></span></a>&amp;<span class="V">&nbsp;</span><span class="J">r</span><span class="V">)&nbsp;</span>const</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">r</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">rectangle in frame area.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">true when Ctrl is target for mouse events and mouse pointer is inside specified frame area rectangle.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::HasMouseIn(const Rect&)const" class="Y">bool<span class="V">&nbsp;</span><span class="Z">HasMouseIn</span><span class="V">(</span>const<span class="V">&nbsp;</span><a href="Rect"><span class="V"><u>Rect</u></span></a>&amp;<span class="V">&nbsp;</span><span class="J">r</span><span class="V">)&nbsp;</span>const</p>
<p class="X">Returns true when Ctrl is target for mouse events and mouse pointer is inside specified view area rectangle.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::GetMouseViewPos()const" class="Y"><a href="Point"><span class="V"><u>Point</u></span></a><span class="V">&nbsp;</span><span class="Z">GetMouseViewPos</span><span class="V">()&nbsp;</span>const</p>
<p class="X">Returns the position of mouse relative to the view area. Note that the result can negative point or point outside </p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::GetMouseCtrl()" class="W"><span class="H">static</span> <u>Ctrl</u>&nbsp;*<span class="I">GetMouseCtrl</span>()</p>
<p class="P">Returns current target for mouse events.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::IgnoreMouseClick()" class="W"><span class="H">static</span> <span class="H">void</span>&nbsp;<span class="I">IgnoreMouseClick</span>()</p>
<p class="P">Forces framework to ignore all mouse events till next button-up event. This is good tool to solve some corner cases, like popup window closed by button click when mouse pointer is over its owner as well (TopWindow::Close calls this function).</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::IgnoreMouseUp()" class="W"><span class="H">static</span> <span class="H">void</span>&nbsp;<span class="I">IgnoreMouseUp</span>()</p>
<p class="P">Invokes IgnoreMouseClick if some of mouse buttons is pressed.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::UnIgnoreMouse()" class="W"><span class="H">static</span> <span class="H">void</span>&nbsp;<span class="I">UnIgnoreMouse</span>()</p>
<p class="X">Cancels the effect or IgnoreMouseClick and IgnoreMouseUp (clicks are not ignored anymore).</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::SetCapture()" class="W"><span class="H">bool</span>&nbsp;<span class="I">SetCapture</span>()</p>
<p class="P">Sets mouse capture for Ctrl. This method should be called in MouseLeft or MouseRight methods only. Ctrl will receive all mouse input until ReleaseCapture is called or mouse button is released.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">True when SetCapture was successful (usually you can ignore this return value).</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::ReleaseCapture()" class="W"><span class="H">bool</span>&nbsp;<span class="I">ReleaseCapture</span>()</p>
<p class="P">Release Ctrl's mouse capture.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">True when mouse capture was released.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::HasCapture()const" class="Y">bool<span class="V">&nbsp;</span><span class="Z">HasCapture</span><span class="V">()&nbsp;</span>const</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">True if Ctrl has mouse capture.</p></td></tr></table>
<p class="F">&nbsp;</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::GetCaptureCtrl()" class="W"><span class="H">static</span> <a href="Ctrl"><u>Ctrl</u></a>&nbsp;*<span class="I">GetCaptureCtrl</span>()</p>
<p class="X">Returns a pointer to the Ctrl that is currently capturing the mouse.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::ReleaseCtrlCapture()" class="W"><span class="H">static</span> <span class="H">bool</span>&nbsp;<span class="I">ReleaseCtrlCapture</span>()</p>
<p class="P">If any of application's Ctrls has mouse capture, it is released.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">True if mouse capture was released.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::SetFocus()" class="W"><span class="H">bool</span>&nbsp;<span class="I">SetFocus</span>()</p>
<p class="P">Sets keyboard input focus to the Ctrl. Ctrl is first to receive keyboard events via Key method as long as it has keyboard input focus. When Ctrl denies keyboard event (by returning false from Key method), it is passed to its parent's Key method and so on.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">True if setting focus was successful.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::HasFocus()const" class="Y">bool<span class="V">&nbsp;</span><span class="Z">HasFocus</span><span class="V">()&nbsp;</span>const</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">True if Ctrl has keyboard input focus.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::HasFocusDeep()const" class="Y">bool<span class="V">&nbsp;</span><span class="Z">HasFocusDeep</span><span class="V">()&nbsp;</span>const</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">True if Ctrl or any of its descendants has focus or is equal to GetOwnerCtrl of any active popup.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::WantFocus(bool)" class="W"><u>Ctrl</u><span class="H">&amp;</span>&nbsp;<span class="I">WantFocus</span>(<span class="H">bool</span>&nbsp;<span class="J">ft</span>&nbsp;=&nbsp;<span class="H">true</span>)</p>
<p class="P">Indicates whether Ctrl wants focus to be passed to it by U++, when navigating through the dialog using Tab (or Shift+Tab) key.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">ft</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">true to indicate that Ctrl wants focus.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Same Ctrl for method chaining.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::NoWantFocus()" class="W"><u>Ctrl</u><span class="H">&amp;</span>&nbsp;<span class="I">NoWantFocus</span>()</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Same Ctrl for method chaining.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::IsWantFocus()const" class="Y">bool<span class="V">&nbsp;</span><span class="Z">IsWantFocus</span><span class="V">()&nbsp;</span>const</p>
<p class="P">Checks whether Ctrl has WantFocus acti.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">true, when Ctrl wants focus.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::InitFocus(bool)" class="W"><u>Ctrl</u><span class="H">&amp;</span>&nbsp;<span class="I">InitFocus</span>(<span class="H">bool</span>&nbsp;<span class="J">ft</span>&nbsp;=&nbsp;<span class="H">true</span>)</p>
<p class="P">Indicates that Ctrl is eligible to obtain focus upon opening of dialog or in other similar situations.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">ft</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">true to indicate Ctrl is eligible.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Same Ctrl for method chaining.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::NoInitFocus()" class="W"><u>Ctrl</u><span class="H">&amp;</span>&nbsp;<span class="I">NoInitFocus</span>()</p>
<p class="P">Same as InitFocus(false).</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Same Ctrl for method chaining.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::IsInitFocus()" class="W"><span class="H">bool</span>&nbsp;<span class="I">IsInitFocus</span>()</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">true when Ctrl wants init focus.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::SetWantFocus()" class="W"><span class="H">bool</span>&nbsp;<span class="I">SetWantFocus</span>()</p>
<p class="P">If Ctrl wants focus (WantFocus(true) was called for it), set focus to Ctrl, otherwise nothing happens.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">true if focus was set.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::GetFocusChild()const" class="Y"><span class="V"><u>Ctrl</u></span><span class="V">&nbsp;*</span><span class="Z">GetFocusChild</span><span class="V">()&nbsp;</span>const</p>
<p class="P">If any immediate child of Ctrl has focus, returns pointer to it.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Pointer to child with focus or NULL if no such exists.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::GetFocusChildDeep()const" class="Y"><span class="V"><u>Ctrl</u></span><span class="V">&nbsp;*</span><span class="Z">GetFocusChildDeep</span><span class="V">()&nbsp;</span>const</p>
<p class="P">If any child of Ctrl's child tree has focus, returns pointer to it.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A"></p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::CancelModeDeep()" class="W"><span class="H">void</span>&nbsp;<span class="I">CancelModeDeep</span>()</p>
<p class="P">Calls CancelMode virtual method for Ctrl and all of its descendants.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Upp::Ctrl::CancelPreedit()" class="W"><span class="H">void</span>&nbsp;<span class="I">CancelPreedit</span>()</p>
<p class="X">Terminates any input method composition in progress, if possible. Text input widgets typically call this on status change, like new cursor position or new text through SetData.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Upp::Ctrl::CancelMyPreedit()" class="W"><span class="H">void</span>&nbsp;<span class="I">CancelMyPreedit</span>()</p>
<p class="X">Calls CancelPreedit if this widget has keyboard focus.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::GetFocusCtrl()" class="W"><span class="H">static</span> <u>Ctrl</u>&nbsp;*<span class="I">GetFocusCtrl</span>()</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Ctrl that has focus or NULL if no Ctrl of application has it.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::IterateFocusForward(Ctrl*,Ctrl*,bool,bool,bool)" class="W"><span class="H">static</span> <span class="H">bool</span>&nbsp;<span class="I">IterateFocusForward</span>(<a href="Ctrl"><u>Ctrl</u></a>&nbsp;*<span class="J">ctrl</span>, <a href="Ctrl"><u>Ctrl</u></a>&nbsp;*<span class="J">top</span>, <span class="H">bool</span>&nbsp;<span class="J">noframe</span>&nbsp;=&nbsp;<span class="H">false</span>, <span class="H">bool</span>&nbsp;<span class="J">init</span>&nbsp;=&nbsp;<span class="H">false</span>, <span class="H">bool</span>&nbsp;<span class="J">all</span>&nbsp;=&nbsp;<span class="H">false</span>)</p>
<p class="X">Tries to move focus to next &quot;appropriate&quot; Ctrl, like when Tab key is pressed in the dialog. Appropriate Ctrl needs to have WantFocus flag, be visible and enabled.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">ctrl</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Ctrl with focus.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">top</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Top Ctrl - function cycles only between this Ctrl subtree.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">noframe</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Indicates that frame Ctrls are to be excluded.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">true when focus was successfully moved.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::IterateFocusBackward(Ctrl*,Ctrl*,bool,bool)" class="W"><span class="H">static</span> <span class="H">bool</span>&nbsp;<span class="I">IterateFocusBackward</span>(<a href="Ctrl"><u>Ctrl</u></a>&nbsp;*<span class="J">ctrl</span>, <a href="Ctrl"><u>Ctrl</u></a>&nbsp;*<span class="J">top</span>, <span class="H">bool</span>&nbsp;<span class="J">noframe</span>&nbsp;=&nbsp;<span class="H">false</span>, <span class="H">bool</span>&nbsp;<span class="J">all</span>&nbsp;=&nbsp;<span class="H">false</span>)</p>
<p class="X">Tries to move focus to previous appropriate Ctrl, like when Tab key is pressed in the dialog. &quot;Appropriate&quot; Ctrl needs to have WantFocus flag, be visible and enabled.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">ctrl</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Ctrl with focus.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">top</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Top Ctrl - function cycles only between this Ctrl subtree.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">noframe</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Indicates that frame Ctrls are to be excluded.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">init</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Ctrl must have InitFocus flag.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">true when focus was successfully moved.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::AccessKeyBit(byte)" class="W"><span class="H">static</span> <u>dword</u>&nbsp;<span class="I">AccessKeyBit</span>(<u>byte</u>&nbsp;<span class="J">accesskey</span>)</p>
<p class="P">Returns bit-mask for specified access-key.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">accesskey</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Access-key. It should be plain ASCII value of access-key.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Access-key bitmask. Note that only 'A' - 'Z' have distinct bit-masks as those are only access-keys distributed automatically.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::GetAccessKeysDeep()const" class="Y"><span class="V"><u>dword</u></span><span class="V">&nbsp;</span><span class="Z">GetAccessKeysDeep</span><span class="V">()&nbsp;</span>const</p>
<p id="Ctrl::GetAccessKeysDeep()const" class="Y"><span class="V"><u>dword</u></span><span class="V">&nbsp;</span><span class="Z">GetAccessKeysDeep</span><span class="V">()&nbsp;</span>const</p>
<p class="P">Returns binary or of Ctrl's GetAccessKey method results with the result of calling GetAccessKeyDeep for all children. In other words, returns key coverage for the whole Ctrl tree.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Access-keys used by Ctrl and its descendants.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::DistributeAccessKeys()" class="W"><span class="H">void</span>&nbsp;<span class="I">DistributeAccessKeys</span>()</p>
<p class="P">Triggers automatic distribution of access keys. This is implemented as gathering all already used access keys using GetAccessKeys method and then using AssignAccessKeys method with this value to distribute rest of keys (in other words, it is equivalent of AssignAccessKeys(GetAccessKeys())).</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::RefreshAccessKeys()" class="W"><span class="H">void</span>&nbsp;<span class="I">RefreshAccessKeys</span>()</p>
<p class="P">Invokes Refresh for this Ctrl or any descendant with any access-key assigned.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::VisibleAccessKeys()" class="W"><span class="H">bool</span>&nbsp;<span class="I">VisibleAccessKeys</span>()</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">True if according to current access-key model there should be visible graphical representation (usually underline) of access-keys.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::Show(bool)" class="W"><span class="H">void</span>&nbsp;<span class="I">Show</span>(<span class="H">bool</span>&nbsp;<span class="J">show</span>&nbsp;=&nbsp;<span class="H">true</span>)</p>
<p class="P">Sets visibility flag for Ctrl.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">show</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">true indicates that Ctrl should be visible.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::Hide()" class="W"><span class="H">void</span>&nbsp;<span class="I">Hide</span>()</p>
<p class="P">Same as Show(false).</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::IsShown()const" class="Y">bool<span class="V">&nbsp;</span><span class="Z">IsShown</span><span class="V">()&nbsp;</span>const</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">visibility flag for Ctrl.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::IsVisible()const" class="Y">bool<span class="V">&nbsp;</span><span class="Z">IsVisible</span><span class="V">()&nbsp;</span>const</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">true if Ctrl is currently visible on the screen. Ctrl is visible if it has visibility flag set, its parent is visible and its top-level Ctrl is open.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::Enable(bool)" class="W"><span class="H">void</span>&nbsp;<span class="I">Enable</span>(<span class="H">bool</span>&nbsp;<span class="J">enable</span>&nbsp;=&nbsp;<span class="H">true</span>)</p>
<p class="P">Enables or disables Ctrl.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">enable</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">true indicates that Ctrl should be enabled.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::Disable()" class="W"><span class="H">void</span>&nbsp;<span class="I">Disable</span>()</p>
<p class="P">Same as Enable(false).</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::IsEnabled()const" class="Y">bool<span class="V">&nbsp;</span><span class="Z">IsEnabled</span><span class="V">()&nbsp;</span>const</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">true if Ctrl is enabled.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::SetEditable(bool)" class="W"><u>Ctrl</u><span class="H">&amp;</span>&nbsp;<span class="I">SetEditable</span>(<span class="H">bool</span>&nbsp;<span class="J">editable</span>&nbsp;=&nbsp;<span class="H">true</span>)</p>
<p class="P">Sets editable or read-only mode of Ctrl. Specific Ctrls can check this flag using IsEditable method and behave accordingly.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">editable</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">true indicates that Ctrl is editable.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">*this for method chaining.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::SetReadOnly()" class="W"><u>Ctrl</u><span class="H">&amp;</span>&nbsp;<span class="I">SetReadOnly</span>()</p>
<p class="P">Same as SetEditable(false).</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::IsEditable()const" class="Y">bool<span class="V">&nbsp;</span><span class="Z">IsEditable</span><span class="V">()&nbsp;</span>const</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">true if Ctrl is editable.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::IsReadOnly()const" class="Y">bool<span class="V">&nbsp;</span><span class="Z">IsReadOnly</span><span class="V">()&nbsp;</span>const</p>
<p class="P">Same as !IsEditable().</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Upp::Ctrl::ClearModifyDeep()" class="W"><span class="H">void</span>&nbsp;<span class="I">ClearModifyDeep</span>()</p>
<p class="X">Clear modify flag (by calling ClearModify) for the widgets and all its descendants.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Upp::Ctrl::IsModifiedDeep()const" class="Y">bool<span class="V">&nbsp;</span><span class="Z">IsModifiedDeep</span><span class="V">()&nbsp;</span>const</p>
<p class="X">Returns true if widget or any of its descendants have modify flag active.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::UpdateRefresh()" class="W"><span class="H">void</span>&nbsp;<span class="I">UpdateRefresh</span>()</p>
<p class="P">Calls both Update and Refresh methods.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::Update()" class="W"><span class="H">void</span>&nbsp;<span class="I">Update</span>()</p>
<p class="P">Same as SetModify().</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::Action()" class="W"><span class="H">void</span>&nbsp;<span class="I">Action</span>()</p>
<p class="P">Invokes default Ctrl callback - WhenAction. Action actually makes a copy of WhenAction - this ensures that the Event&lt;&gt; object is not destroyed during the call.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::UpdateAction()" class="W"><span class="H">void</span>&nbsp;<span class="I">UpdateAction</span>()</p>
<p class="P">Calls Update and then Action.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::UpdateActionRefresh()" class="W"><span class="H">void</span>&nbsp;<span class="I">UpdateActionRefresh</span>()</p>
<p class="P">Calls Update, then Action, then Refresh. Typically called after user changes values of Ctrl.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::Transparent(bool)" class="W"><u>Ctrl</u><span class="H">&amp;</span>&nbsp;<span class="I">Transparent</span>(<span class="H">bool</span>&nbsp;<span class="J">bp</span>&nbsp;=&nbsp;<span class="H">true</span>)</p>
<p class="P">Sets transparency flag of Ctrl. If transparency flag is disabled, U++ can paint Ctrl in more effective way.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">bp</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Transparency flag.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">*this for method chaining.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::NoTransparent()" class="W"><u>Ctrl</u><span class="H">&amp;</span>&nbsp;<span class="I">NoTransparent</span>()</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Transparent(false).</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::IsTransparent()const" class="Y">bool<span class="V">&nbsp;</span><span class="Z">IsTransparent</span><span class="V">()&nbsp;</span>const</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Value of transparency flag.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::ActiveX(bool)" class="W"><u>Ctrl</u><span class="H">&amp;</span>&nbsp;<span class="I">ActiveX</span>(<span class="H">bool</span>&nbsp;<span class="J">ax</span>&nbsp;=&nbsp;<span class="H">true</span>)</p>
<p class="P">Special flag used for ActiveX Ctrls implementation.</p>
<p class="AG">Windows specific.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">ax</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">true - Ctrl is ActiveX control</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">*this for method chaining.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::NoActiveX()" class="W"><u>Ctrl</u><span class="H">&amp;</span>&nbsp;<span class="I">NoActiveX</span>()</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">ActiveX(false).</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::IsActiveX()const" class="Y">bool<span class="V">&nbsp;</span><span class="Z">IsActiveX</span><span class="V">()&nbsp;</span>const</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Value of ActiveX flag.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::HelpLine(const char*)" class="W"><u>Ctrl</u><span class="H">&amp;</span>&nbsp;<span class="I">HelpLine</span>(<span class="H">const</span>&nbsp;<span class="H">char</span>&nbsp;*<span class="J">txt</span>)</p>
<p class="P">Sets help topic link for Ctrl.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">txt</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Link.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">*this for method chaining.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::GetTip()const" class="Y"><span class="V"><u>String</u></span><span class="V">&nbsp;</span><span class="Z">GetTip</span><span class="V">()&nbsp;</span>const</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Current Tip text.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::GetHelpLine()const" class="Y"><span class="V"><u>String</u></span><span class="V">&nbsp;</span><span class="Z">GetHelpLine</span><span class="V">()&nbsp;</span>const</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Current HelpTopic link.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::operator<<(Ctrl&)" class="W"><u>Ctrl</u><span class="H">&amp;</span>&nbsp;<span class="I">operator&lt;&lt;</span>(<u>Ctrl</u><span class="H">&amp;</span>&nbsp;<span class="J">ctrl</span>)</p>
<p id="Ctrl::Add(Ctrl&)" class="W"><span class="H">void</span>&nbsp;<span class="I">Add</span>(<u>Ctrl</u><span class="H">&amp;</span>&nbsp;<span class="J">ctrl</span>)</p>
<p class="P">Adds ctrl as the last child.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">ctrl</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Ctrl to add.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::Remove()" class="W"><span class="H">void</span>&nbsp;<span class="I">Remove</span>()</p>
<p class="P">Removes Ctrl from its parent.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::operator<<=(const Value&)" class="W"><span class="H">const</span>&nbsp;<u>Value</u><span class="H">&amp;</span>&nbsp;<span class="I">operator&lt;&lt;=</span>(<span class="H">const</span>&nbsp;<u>Value</u><span class="H">&amp;</span>&nbsp;<span class="J">v</span>)</p>
<p class="P">Same as SetData(v).</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">v</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">New Value of Ctrl.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Reference to v.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Upp::Ctrl::operator<<(Upp::Function<void()>)" class="W"><a href="Upp::Callback"><u>Callback</u></a><span class="H">&amp;</span>&nbsp;<span class="I">operator&lt;&lt;</span>(<a href="Upp::Function"><u>Upp::Function</u></a>&lt;<span class="H">void</span>&nbsp;()&gt;&nbsp;<span class="J">action</span>)</p>
<p class="X">Same as WhenAction &lt;&lt; action, can be used both with lambdas and Events (former Callbacks)..</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Upp::Ctrl::SetTimeCallback(int,Function,int)" class="W"><span class="H">void</span>&nbsp;<span class="I">SetTimeCallback</span>(<span class="H">int</span>&nbsp;<span class="J">delay_ms</span>, <a href="Upp::Function"><u>Function</u></a>&lt;<span class="H">void</span>&nbsp;()&gt;&nbsp;<span class="J">cb</span>, <span class="H">int</span>&nbsp;<span class="J">id</span>&nbsp;=&nbsp;<span class="AC">0</span>)</p>
<p class="P">Puts delayed callback to the timer queue. As an identifier of callback, which is void * in timer queue, <span class="I">this</span> + <span class="I">id</span> is used. When Ctrl is destroyed, all callbacks with <span class="I">id</span> in range 0 ... sizeof(Ctrl) are removed from timer callback queue - this ensures that no dangling callbacks are left there.</p>
<p class="X"><span class="J">delay_ms</span> is delay of callback in ms. If this is 0, callback is called immediately after all pending input GUI events are processed. Negative value means the event is periodic - it is triggered after -delay_ms and after being performed, it is rescheduled with the same delay_ms.</p>
<p class="X">Identifier <span class="J">id</span> should be in range 0..80. U++ defines compile-time protocol for distributing these ids. If Ctrl wants to use non-zero time callback id, it should define it using</p>
<p class="X">&nbsp;</p>
<p class="AH"><span class="V">&nbsp;&nbsp;&nbsp;&nbsp;enum { TIMEID_PERIODIC = </span><span class="AI">baseclass</span><span class="V">::TIMEID_COUNT, TIMEID_COUNT</span> };</p>
<p class="X">&nbsp;</p>
<p class="X">&nbsp;&nbsp;&nbsp;&nbsp;Using zero as <span class="I">id</span> is OK as long as you do not intend to remove time callbacks using <span class="I">KillTimeCallback. </span>Alternative to using id is class TimeCallback that represents whole issue as member variable of Ctrl.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::KillTimeCallback(int)" class="W"><span class="H">void</span>&nbsp;<span class="I">KillTimeCallback</span>(<span class="H">int</span>&nbsp;<span class="J">id</span>&nbsp;=&nbsp;<span class="AC">0</span>)</p>
<p class="P">Removes time callback associated with Ctrl.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">id</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Id of callback.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Upp::Ctrl::KillSetTimeCallback(int,Function,int)" class="W"><span class="H">void</span>&nbsp;<span class="I">KillSetTimeCallback</span>(<span class="H">int</span>&nbsp;<span class="J">delay_ms</span>, <a href="Upp::Function"><u>Function</u></a>&lt;<span class="H">void</span>&nbsp;()&gt;&nbsp;<span class="J">cb</span>, <span class="H">int</span>&nbsp;<span class="J">id</span>)</p>
<p class="X">Removes callback with <span class="J">id</span> and sets it again.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::ExistsTimeCallback(int)const" class="Y">bool<span class="V">&nbsp;</span><span class="Z">ExistsTimeCallback</span><span class="V">(</span>int<span class="V">&nbsp;</span><span class="J">id</span><span class="V">&nbsp;=&nbsp;</span><span class="AC">0</span><span class="V">)&nbsp;</span>const</p>
<p class="P">Tests whether Ctrl has associated callback in timer queue.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">id</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Id of callback.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">true when id is found in timer queue.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Upp::Ctrl::PostCallback(Function,int)" class="W"><span class="H">void</span>&nbsp;<span class="I">PostCallback</span>(<a href="Upp::Function"><u>Function</u></a>&lt;<span class="H">void</span>&nbsp;()&gt;&nbsp;<span class="J">cb</span>, <span class="H">int</span>&nbsp;<span class="J">id</span>&nbsp;=&nbsp;<span class="AC">0</span>)</p>
<p class="X">Posts callback to be executed immediately (but in the main loop after all current GUI events).</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Upp::Ctrl::KillPostCallback(Function,int)" class="W"><span class="H">void</span>&nbsp;<span class="I">KillPostCallback</span>(<a href="Upp::Function"><u>Function</u></a>&lt;<span class="H">void</span>&nbsp;()&gt;&nbsp;<span class="J">cb</span>, <span class="H">int</span>&nbsp;<span class="J">id</span>)</p>
<p class="X">Similar to PostCallback, but removes callback(s) with the same id from the queue first.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::GetActiveCtrl()" class="W"><span class="H">static</span> <u>Ctrl</u>&nbsp;*<span class="I">GetActiveCtrl</span>()</p>
<p class="P">Returns pointer to active Ctrl. Active Ctrl is top-level Ctrl of Ctrl with keyboard focus.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Pointer to active Ctrl.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::GetActiveWindow()" class="W"><span class="H">static</span> <u>Ctrl</u>&nbsp;*<span class="I">GetActiveWindow</span>()</p>
<p class="P">Returns pointer to active TopWindow that is either active or owns active Ctrl. Difference between GetActiveWindow and GetActiveCtrl is that GetActiveCtrl can return pop-up Ctrl, while GetActiveWindow returns always TopWindow - if active Ctrl is pop-up, owner of pop-up is returned.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Pointer to active window.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::GetVisibleChild(Ctrl*,Point,bool)" class="W"><span class="H">static</span> <u>Ctrl</u>&nbsp;*<span class="I">GetVisibleChild</span>(<u>Ctrl</u>&nbsp;*<span class="J">ctrl</span>, <u>Point</u>&nbsp;<span class="J">p</span>, <span class="H">bool</span>&nbsp;<span class="J">pointinframe</span>)</p>
<p class="P">Finds deepest descendant of Ctrl that is visible and contains given point. If not such Ctrl exists, returns this.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">ctrl</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Parent ctrl.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">p</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Point.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">pointinframe</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Determines whether point is in view or frame coordinates.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Pointer to Ctrl.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::PopUpHWND(HWND,bool,bool,bool,bool)" class="W"><span class="H">void</span>&nbsp;<span class="I">PopUpHWND</span>(HWND&nbsp;<span class="J">hwnd</span>, <span class="H">bool</span>&nbsp;<span class="J">savebits</span>&nbsp;=&nbsp;<span class="H">true</span>, <span class="H">bool</span>&nbsp;<span class="J">activate</span>&nbsp;=&nbsp;<span class="H">true</span>, <span class="H">bool</span>&nbsp;<span class="J">dropshadow</span>&nbsp;=&nbsp;<span class="H">false</span>, <span class="H">bool</span>&nbsp;<span class="J">topmost</span>&nbsp;=&nbsp;<span class="H">false</span>)</p>
<p class="AJ"><span class="AK">Opens top-level Ctrl as pop-up window. </span>This method can only be invoked in the main thread.</p>
<p class="AL">Win32 specific.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">hwnd</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Win32 handle of owner window.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">savebits</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Indicates that system should try to preserve background bits.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">activate</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Pop-up should be activated.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">dropshadow</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Pop-up should have drop-shadow (if supported).</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">topmost</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Pop-up should be top-most window.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::PopUp(Ctrl*,bool,bool,bool,bool)" class="W"><span class="H">void</span>&nbsp;<span class="I">PopUp</span>(<u>Ctrl</u>&nbsp;*<span class="J">owner</span>&nbsp;=&nbsp;NULL, <span class="H">bool</span>&nbsp;<span class="J">savebits</span>&nbsp;=&nbsp;<span class="H">true</span>, <span class="H">bool</span>&nbsp;<span class="J">activate</span>&nbsp;=&nbsp;<span class="H">true</span>, <span class="H">bool</span>&nbsp;<span class="J">dropshadow</span>&nbsp;=&nbsp;<span class="H">false</span>, <span class="H">bool</span>&nbsp;<span class="J">topmost</span>&nbsp;=&nbsp;<span class="H">false</span>)</p>
<p class="AJ"><span class="AK">Opens top-level Ctrl as pop-up window. </span>This method can only be invoked in the main thread.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">owner</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Owner.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">savebits</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Indicates that system should try to preserve background bits.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">activate</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Pop-up should be activated.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">dropshadow</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Pop-up should have drop-shadow (if supported).</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">topmost</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Pop-up should be top-most window.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::SetAlpha(::byte)" class="W"><span class="H">void</span>&nbsp;<span class="I">SetAlpha</span>(<u>byte</u>&nbsp;<span class="J">alpha</span>)</p>
<p class="P">Sets top-level Ctrl alpha blending if supported by system. Ctrl must be open.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">alpha</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Value of alpha.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::IsWaitingEvent()" class="W"><span class="H">static</span> <span class="H">bool</span>&nbsp;<span class="I">IsWaitingEvent</span>()</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">True when there is waiting unprocessed event in input queue.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::ProcessEvents(bool*)" class="W"><span class="H">static</span> <span class="H">bool</span>&nbsp;<span class="I">ProcessEvents</span>(<span class="H">bool</span>&nbsp;*<span class="J">quit</span>&nbsp;=&nbsp;NULL)</p>
<p class="P">Processes all events from input queue. When there is no pending event, returns immediately. (Processing event involves usually involves dispatching it via virtual methods to proper Ctrls). Additionally, after all input events are processed, all pending timer events are processed and all Refreshed areas of windows are repainted.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">quit</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Assigned true when WM_QUIT message is intercepted (Win32 specific).</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">True indicates that one or more events were processed, false that queue was empty.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Upp::Ctrl::GetEventLevel()" class="W"><span class="H">static</span> <span class="H">int</span>&nbsp;<span class="I">GetEventLevel</span>()</p>
<p class="X">Returns the level of input event. This is basically a reentrancy level of ProcessEvent(s) routine - it starts zero but increments each time the input event is generated by ProcessEvent(s). This information can be useful for background threads or in timer events (where this is zero when application is in the &quot;base&quot; state).</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::IsPopUp()const" class="Y">bool<span class="V">&nbsp;</span><span class="Z">IsPopUp</span><span class="V">()&nbsp;</span>const</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">True if Ctrl is pop-up window.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::EventLoop(Ctrl*)" class="W"><span class="H">static</span> <span class="H">void</span>&nbsp;<span class="I">EventLoop</span>(<u>Ctrl</u>&nbsp;*<span class="J">loopctrl</span>&nbsp;=&nbsp;NULL)</p>
<p class="AJ"><span class="AK">Executes event-loop. If </span><span class="AM">loopctrl </span><span class="AK">is not NULL, it must be opened top-level Ctrl and loop is executed until EndLoop method for </span><span class="AM">loopctrl </span><span class="AK">is invoked. If </span><span class="AM">loopctrl</span><span class="AK"> is NULL, loop is executed as long as any top-level Ctrl exists or application is terminated by OS specific &quot;shutdown&quot; event. </span>This method can only be invoked in the main thread.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">loopctrl</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Looping Ctrl.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::GetLoopLevel()" class="W"><span class="H">static</span> <span class="H">int</span>&nbsp;<span class="I">GetLoopLevel</span>()</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Level of even-loop (even-loops a reentrant).</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::GetLoopCtrl()" class="W"><span class="H">static</span> <u>Ctrl</u>&nbsp;*<span class="I">GetLoopCtrl</span>()</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Current looping Ctrl.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::EndLoop()" class="W"><span class="H">void</span>&nbsp;<span class="I">EndLoop</span>()</p>
<p class="P">Terminates loop for looping Ctrl. Note that this terminates only loop for looping Ctrl. If there is another loop above such loop, nothing is terminated until this additional loop is active.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::EndLoop(int)" class="W"><span class="H">void</span>&nbsp;<span class="I">EndLoop</span>(<span class="H">int</span>&nbsp;<span class="J">code</span>)</p>
<p class="X">Same as EndLoop(), but also defines loop exit code.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">code</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Loop exit code.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::InLoop()const" class="Y">bool<span class="V">&nbsp;</span><span class="Z">InLoop</span><span class="V">()&nbsp;</span>const</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">true if Ctrl is looping Ctrl.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::GetExitCode()const" class="Y">int<span class="V">&nbsp;</span><span class="Z">GetExitCode</span><span class="V">()&nbsp;</span>const</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Exit code of last loop performed with this Ctrl.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::Clipboard()" class="W"><span class="H">static</span> <a href="PasteClip"><u>PasteClip</u></a><span class="H">&amp;</span>&nbsp;<span class="I">Clipboard</span>()</p>
<p class="X">Represents the clipboard as PasteClip. This allows unification of drag&amp;drop and clipboard operations as there can be single method handling with Clipboard and Drag&amp;Drop (and X11 selection) operations.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::Selection()" class="W"><span class="H">static</span> <a href="PasteClip"><u>PasteClip</u></a><span class="H">&amp;</span>&nbsp;<span class="I">Selection</span>()</p>
<p class="X">Represents X11 selection as PasteClip. This allows unification of drag&amp;drop and selection operations as there can be single method handling with Clipboard and Drag&amp;Drop (and X11 selection) operations.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::SetSelectionSource(const char*)" class="W"><span class="H">void</span>&nbsp;<span class="I">SetSelectionSource</span>(<span class="H">const</span>&nbsp;<span class="H">char</span>&nbsp;*<span class="J">fmts</span>)</p>
<p class="X">Tells X11 system that this Ctrl is current selection source, with <span class="J">fmts</span> available (semicolon separated list).</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::DoDragAndDrop(const char*,const Image&,dword,const VectorMap<String,ClipData>&)" class="W"><span class="H">int</span>&nbsp;<span class="I">DoDragAndDrop</span>(<span class="H">const</span>&nbsp;<span class="H">char</span>&nbsp;*<span class="J">fmts</span>, <span class="H">const</span>&nbsp;<a href="Image"><u>Image</u></a><span class="H">&amp;</span>&nbsp;<span class="J">sample</span>, <a href="dword"><u>dword</u></a>&nbsp;<span class="J">actions</span>, <span class="H">const</span>&nbsp;<a href="VectorMap"><u>VectorMap</u></a>&lt;<a href="String"><u>String</u></a>, <a href="ClipData"><u>ClipData</u></a>&gt;&amp;&nbsp;<span class="J">data</span>)</p>
<p class="X">Performs drag&amp;drop operation, with this Ctrl as source. <span class="J">fmts</span> is a semicolon separated list of formats available using GetDropData method, <span class="J">sample</span> is an image representation of data, <span class="J">actions</span> are allowed drag and drop operations - a binary or DND_NONE, DND_COPY, DND_MOVE (or DND_ALL as combination of all of them). Special unrelated flag DND_EXACTIMAGE can be add to actions to indicate that Drag&amp;Drop should not alter <span class="J">sample</span> image (otherwise it can be adjusted to look consistent). <span class="J">data</span> is data directly provided for the operation as map of individual formats to ClipData.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::DoDragAndDrop(const char*,const Image&,dword)" class="W"><span class="H">int</span>&nbsp;<span class="I">DoDragAndDrop</span>(<span class="H">const</span>&nbsp;<span class="H">char</span>&nbsp;*<span class="J">fmts</span>, <span class="H">const</span>&nbsp;<a href="Image"><u>Image</u></a><span class="H">&amp;</span>&nbsp;<span class="J">sample</span>&nbsp;=&nbsp;Null, <a href="dword"><u>dword</u></a>&nbsp;<span class="J">actions</span>&nbsp;=&nbsp;DND_ALL)</p>
<p class="X">DoDragAndDrop with empty data (all formats are provided by GetDropData).</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::DoDragAndDrop(const VectorMap<String,ClipData>&,const Image&,dword)" class="W"><span class="H">int</span>&nbsp;<span class="I">DoDragAndDrop</span>(<span class="H">const</span>&nbsp;<a href="VectorMap"><u>VectorMap</u></a>&lt;<a href="String"><u>String</u></a>, <a href="ClipData"><u>ClipData</u></a>&gt;&amp;&nbsp;<span class="J">data</span>, <span class="H">const</span>&nbsp;<a href="Image"><u>Image</u></a><span class="H">&amp;</span>&nbsp;<span class="J">sample</span>&nbsp;=&nbsp;Null, <a href="dword"><u>dword</u></a>&nbsp;<span class="J">actions</span>&nbsp;=&nbsp;DND_ALL)</p>
<p class="X">DoDragAndDrop with empty fmts (all formats are provided by <span class="J">data</span>).</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::GetDragAndDropSource()" class="W"><span class="H">static</span> <a href="Ctrl"><u>Ctrl</u></a>&nbsp;*<span class="I">GetDragAndDropSource</span>()</p>
<p class="X">Returns current source of Drag and Drop, is such source exists in this process and it is U++ widget (otherwise returns NULL).</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::GetDragAndDropTarget()" class="W"><span class="H">static</span> <a href="Ctrl"><u>Ctrl</u></a>&nbsp;*<span class="I">GetDragAndDropTarget</span>()</p>
<p class="X">Returns current target of Drag and Drop, is such target exists in this process and it is U++ widget (otherwise returns NULL).</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::IsDragAndDropSource()" class="W"><span class="H">bool</span>&nbsp;<span class="I">IsDragAndDropSource</span>()</p>
<p class="X">Same as this == GetDragAndDropSource().</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::IsDragAndDropTarget()" class="W"><span class="H">bool</span>&nbsp;<span class="I">IsDragAndDropTarget</span>()</p>
<p class="X">Same as this == GetDragAndDropTarget().</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::StdSampleSize()" class="W"><span class="H">static</span> <a href="Size"><u>Size</u></a>&nbsp;<span class="I">StdSampleSize</span>()</p>
<p class="X">Returns the best size of DoDragAndDrop sample parameter.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::SetMinSize(Size)" class="W"><span class="H">void</span>&nbsp;<span class="I">SetMinSize</span>(<u>Size</u>&nbsp;<span class="J">sz</span>)</p>
<p class="P">This method does nothing. It is a interface placeholder to get Layout templates working - in derived classes this can be statically overloaded to receive minimal size of layout.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">sz</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Minimal size of layout.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::Csizeinit()" class="W"><span class="H">static</span> <span class="H">void</span>&nbsp;<span class="I">Csizeinit</span>()</p>
<p class="P">Sets zoom factor used to scale layouts (to scale zoomed positioning methods like LeftPosZ). Horizontal distances are scaled by sz.cx / bsz.cx, vertical by sz.cy / bsz.cy. If bsz is Size(0, 0), default base size (based on standard Win32 GUI font) is used. Note that U++ sets scaling factor automatically upon startup based on actual standard GUI font size.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">sz</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Numerator of scaling factor.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">bsz</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Denominator of scaling factor.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::HorzLayoutZoom(int)" class="W"><span class="H">static</span> <span class="H">int</span>&nbsp;<span class="I">HorzLayoutZoom</span>(<span class="H">int</span>&nbsp;<span class="J">cx</span>)</p>
<p class="P">Performs horizontal scaling by actual scaling factor.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">cx</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Distance to scale.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Scaled distance.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Upp::Ctrl::HorzLayoutZoomf(double)" class="W"><span class="H">double</span>&nbsp;<span class="I">HorzLayoutZoomf</span>(<span class="H">double</span>&nbsp;<span class="J">cx</span>)</p>
<p class="X">Similar to HorzLayoutZoom, but with double precision.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::VertLayoutZoom(int)" class="W"><span class="H">static</span> <span class="H">int</span>&nbsp;<span class="I">VertLayoutZoom</span>(<span class="H">int</span>&nbsp;<span class="J">cy</span>)</p>
<p class="P">Performs vertical scaling by actual scaling factor.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">cy</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Distance to scale.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Scaled distance.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::LayoutZoom(int,int)" class="W"><span class="H">static</span> <u>Size</u>&nbsp;<span class="I">LayoutZoom</span>(<span class="H">int</span>&nbsp;<span class="J">cx</span>, <span class="H">int</span>&nbsp;<span class="J">cy</span>)</p>
<p class="P">Performs scaling by actual scaling factor.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">cx</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Horizontal distance.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">cy</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Vertical distance.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Scaled size.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::LayoutZoom(Size)" class="W"><span class="H">static</span> <u>Size</u>&nbsp;<span class="I">LayoutZoom</span>(<u>Size</u>&nbsp;<span class="J">sz</span>)</p>
<p class="P">Performs scaling by actual scaling factor.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">sz</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Size to scale.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Scaled size.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::NoLayoutZoom()" class="W"><span class="H">static</span> <span class="H">void</span>&nbsp;<span class="I">NoLayoutZoom</span>()</p>
<p class="P">Sets scaling factor to (1, 1). Same as SetZoomSize(Size(1, 1), Size(1, 1)).</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Upp::Ctrl::SetUHDEnabled(bool)" class="W"><span class="H">void</span>&nbsp;<span class="I">SetUHDEnabled</span>(<span class="H">bool</span>&nbsp;<span class="J">set</span>)</p>
<p class="X">Informs host platform that application is UHD ready. Default is true. Disabling UHD mode has to be done before GUI_APP_MAIN, e.g. in INITBLOCK.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Upp::Ctrl::IsUHDEnabled()" class="W"><span class="H">bool</span>&nbsp;<span class="I">IsUHDEnabled</span>()</p>
<p class="X">Returns the value set by SetUHDEnabled.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Upp::Ctrl::SetDarkThemeEnabled(bool)" class="W"><span class="H">static</span> <span class="H">void</span>&nbsp;<span class="I">SetDarkThemeEnabled</span>(<span class="H">bool</span>&nbsp;<span class="J">set</span>&nbsp;=&nbsp;<span class="H">true</span>)</p>
<p class="X">Hints coloring and skinning algorithms that the application is ready to work in dark theme mode. Currently this enables dark theme in Windows (with other platforms dark theme is enabled by default). Default value is true. Disabling dark theme has to be done before GUI_APP_MAIN, e.g. in INITBLOCK.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Upp::Ctrl::IsDarkThemeEnabled()" class="W"><span class="H">static</span> <span class="H">bool</span>&nbsp;<span class="I">IsDarkThemeEnabled</span>()</p>
<p class="X">Returns the value set by SetDarkThemeEnabled.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::GetWorkArea()" class="U">Rect&nbsp;<span class="V">GetWorkArea</span>()</p>
<p class="X">Returns OS specific working area for the widget - this is rectangle in screen coordinates where application top-level windows can be placed - the size of screen minus the size of any border entities like the task-bar. If widget is not associated with the open window, returns the size of primary work area.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Work area rectangle.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::GetVirtualWorkArea()" class="W"><span class="H">static</span> <u>Rect</u>&nbsp;<span class="I">GetVirtualWorkArea</span>()</p>
<p class="P">Returns the total size of all displays minus any border entities.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::GetVirtualScreenArea()" class="W"><span class="H">static</span> <u>Rect</u>&nbsp;<span class="I">GetVirtualScreenArea</span>()</p>
<p class="P">Returns the total size of all displays.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::GetPrimaryWorkArea()" class="W"><span class="H">static</span> <u>Rect</u>&nbsp;<span class="I">GetPrimaryWorkArea</span>()</p>
<p class="P">Returns the size of primary work area - primary screen in Windows is the display with start menu.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::GetPrimaryScreenArea()" class="W"><span class="H">static</span> <u>Rect</u>&nbsp;<span class="I">GetPrimaryScreenArea</span>()</p>
<p class="P">Returns the size of primary screen - primary screen in Windows is the display with start menu.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::GetWorkArea(Point)" class="W"><span class="H">static</span> <a href="Rect"><u>Rect</u></a>&nbsp;<span class="I">GetWorkArea</span>(<a href="Point"><u>Point</u></a>&nbsp;<span class="J">pt</span>)</p>
<p class="X">Returns the recangle of work area which contains <span class="J">pt</span>. If <span class="J">pt</span> does not belong to any area, returns the primary work area.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::GetMouseWorkArea()" class="W"><span class="H">static</span> <a href="Rect"><u>Rect</u></a>&nbsp;<span class="I">GetMouseWorkArea</span>()</p>
<p class="X">Returns the work are which contains mouse cursor. Same as GetWorkArea(GetMousePos()).</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::GetKbdDelay()" class="W"><span class="H">static</span> <span class="H">int</span>&nbsp;<span class="I">GetKbdDelay</span>()</p>
<p class="P">Returns delay of keyboard before autorepeat starts when key is pressed.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Time in ms.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::GetKbdSpeed()" class="W"><span class="H">static</span> <span class="H">int</span>&nbsp;<span class="I">GetKbdSpeed</span>()</p>
<p class="P">Returns speed of autorepeat.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Speed of autorepeat.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::GetDefaultWindowRect()" class="W"><span class="H">static</span> <u>Rect</u>&nbsp;<span class="I">GetDefaultWindowRect</span>()</p>
<p class="P">Returns OS suggested rectangle of newly open window.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Default window rectangle.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::GetAppName()" class="W"><span class="H">static</span> <u>String</u>&nbsp;<span class="I">GetAppName</span>()</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Name of application. Used by U++ in several places like Prompts.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::SetAppName(const String&)" class="W"><span class="H">static</span> <span class="H">void</span>&nbsp;<span class="I">SetAppName</span>(<span class="H">const</span>&nbsp;<u>String</u><span class="H">&amp;</span>&nbsp;<span class="J">appname</span>)</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">appname</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Adjusts application name.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::Name()const" class="Y"><span class="V"><u>String</u></span><span class="V">&nbsp;</span><span class="Z">Name</span><span class="V">()&nbsp;</span>const</p>
<p class="P">Dumps diagnostic informations to standard log.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::Dump(Stream&)const" class="Y">virtual<span class="V"> </span>void<span class="V">&nbsp;</span><span class="Z">Dump</span><span class="V">(</span><span class="V"><u>Stream</u></span>&amp;<span class="V">&nbsp;</span><span class="J">s</span><span class="V">)&nbsp;</span>const</p>
<p class="P">Dumps diagnostic informations to specified output stream.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">s</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Stream.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::GuiSleep(int)" class="W"><span class="H">static</span> <span class="H">void</span>&nbsp;<span class="I">GuiSleep</span>(<span class="H">int</span>&nbsp;<span class="J">ms</span>)</p>
<p class="AJ"><span class="AK">Sleeps (while allowing other applications or threads to run) for at least </span><span class="AM">ms</span><span class="AK"> milliseconds or until new input event is available. </span>This method can only be invoked in the main thread.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="49"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="J">ms</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Time to sleep.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Upp::Ctrl::Call(Upp::Function<void()>)" class="W"><span class="H">static</span> <span class="H">void</span>&nbsp;<span class="I">Call</span>(<a href="Upp::Function"><u>Function</u></a>&lt;<span class="H">void</span>&nbsp;()&gt;&nbsp;<span class="J">cb</span>)</p>
<p class="X">Executes a callback in the main thread (the one responsible for GUI). It works by posting callback into timer queue (with zero delay), then waits its completion using Semaphore. Main GUI thread has to run timer queue management for callback to be executed (by running event-loop (TopWindow::Run) or ProcessEvents). Warning: Call temporarily unlocks GuiLock (if locked) so that the main thread can run on GUI, this is possible source of race-conditions (GuiLock is relocked after call completes). Be prepared that some other code can run on GUI between call to Call and cb being executed!</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::IsShutdownThreads()" class="W"><span class="H">static</span> <span class="H">bool</span>&nbsp;<span class="I">IsShutdownThreads</span>()</p>
<p class="X">Same as Thread::IsShutdownThreads. Used to signal non-main threads that the program is about to end, so that non-main threads should terminate.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::ShutdownThreads()" class="W"><span class="H">static</span> <span class="H">void</span>&nbsp;<span class="I">ShutdownThreads</span>()</p>
<p class="X">Similiar to Thread::ShutdownThreads, but as part of waiting for threads to finish calls ProcessEvents so that any Call methods can finish and also periodically unlocks GuiLock so that threads waiting on it can finish.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::GetEventId()" class="W"><span class="H">static</span> <a href="int64"><u>int64</u></a>&nbsp;<span class="I">GetEventId</span>()</p>
<p class="X">This function is guaranteed to return the same number while single input event (mouse event or keyboard event) is processed. This is helpful in certain caching situations - e.g. if you want to lazy fetch some data, but only once per input event.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Upp::Ctrl::begin()const" class="Y"><a href="Upp::Ctrl::CtrlConstIterator"><span class="V"><u>CtrlConstIterator</u></span></a><span class="V">&nbsp;</span><span class="Z">begin</span><span class="V">()&nbsp;</span>const</p>
<p id="Upp::Ctrl::begin()" class="W"><a href="Upp::Ctrl::CtrlIterator"><u>CtrlIterator</u></a>&nbsp;<span class="I">begin</span>()</p>
<p id="Upp::Ctrl::end()const" class="Y"><a href="Upp::Ctrl::CtrlConstIterator"><span class="V"><u>CtrlConstIterator</u></span></a><span class="V">&nbsp;</span><span class="Z">end</span><span class="V">()&nbsp;</span>const</p>
<p id="Upp::Ctrl::end()" class="W"><a href="Upp::Ctrl::CtrlIterator"><u>CtrlIterator</u></a>&nbsp;<span class="I">end</span>()</p>
<p class="X">Adds rudimentary iterators over child widgets. Allows range-based for loops: for(Ctrl&amp; q : widget).</p>
<p class="A">&nbsp;</p>
<p class="A">&nbsp;</p>
<table width="100%" border="0" cellpadding="0" cellspacing="0"><tr><td width="100%"><table width="100%" class="C"><colgroup><col width="100%"></colgroup>
<tr><td class="D"><p class="E">Ctrl::Logc</p>
</td>
</tr>
</table></td>
</tr></table>
<p class="F">&nbsp;</p>
<p id="Ctrl::Logc::class" class="AN"><span class="AO">class</span><span class="O">&nbsp;</span>Logc</p>
<p class="K">This nested class serves as either vertical or horizontal part of logical position.</p>
<p class="F">&nbsp;</p>
<p class="A">&nbsp;</p>
<table width="100%" border="0" cellpadding="0" cellspacing="0"><tr><td width="100%"><table width="100%" class="L"><colgroup><col width="100%"></colgroup>
<tr><td class="M"><p class="N">Constructor Detail</p>
</td>
</tr>
</table></td>
</tr></table>
<p class="F">&nbsp;</p>
<p id="Ctrl::Logc::Logc(int,int,int)" class="W"><span class="I">Logc</span>(<span class="H">int</span>&nbsp;<span class="J">al</span>, <span class="H">int</span>&nbsp;<span class="J">a</span>, <span class="H">int</span>&nbsp;<span class="J">b</span>)</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="62"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">al</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Alignment type. Determines what other parameters mean. </p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="62"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">a</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">First value.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="62"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">b</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Second value.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::Logc::Logc()" class="W"><span class="I">Logc</span>()</p>
<p class="X">Default constructor. Sets Logc to the empty state.</p>
<p class="F">&nbsp;</p>
<p class="A">&nbsp;</p>
<table width="100%" border="0" cellpadding="0" cellspacing="0"><tr><td width="100%"><table width="100%" class="L"><colgroup><col width="100%"></colgroup>
<tr><td class="M"><p class="N">Public Member List</p>
</td>
</tr>
</table></td>
</tr></table>
<p class="F">&nbsp;</p>
<p id="Ctrl::Logc::LSGN(dword)" class="W"><span class="H">static</span> <span class="H">int</span>&nbsp;<span class="I">LSGN</span>(<a href="dword"><u>dword</u></a>&nbsp;<span class="J">d</span>)</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="62"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">q</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Logc to compare with.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="62"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">True when equal.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::Logc::operator!=(Ctrl::Logc)const" class="Y">bool<span class="V">&nbsp;</span><span class="Z">operator!=</span><span class="V">(</span><a href="Ctrl::Logc"><span class="V"><u>Logc</u></span></a><span class="V">&nbsp;</span><span class="J">q</span><span class="V">)&nbsp;</span>const</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="62"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">q</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Logc to compare with.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="62"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">True when not equal.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::Logc::GetAlign()const" class="Y">int<span class="V">&nbsp;</span><span class="Z">GetAlign</span><span class="V">()&nbsp;</span>const</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="62"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Alignment type.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::Logc::GetA()const" class="Y">int<span class="V">&nbsp;</span><span class="Z">GetA</span><span class="V">()&nbsp;</span>const</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="62"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">First value.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::Logc::GetB()const" class="Y">int<span class="V">&nbsp;</span><span class="Z">GetB</span><span class="V">()&nbsp;</span>const</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="62"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Second value.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::Logc::SetAlign(int)" class="W"><span class="H">void</span>&nbsp;<span class="I">SetAlign</span>(<span class="H">int</span>&nbsp;<span class="J">align</span>)</p>
<p class="AP">Sets alignment type.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="62"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">align</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Alignment type.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::Logc::SetA(int)" class="W"><span class="H">void</span>&nbsp;<span class="I">SetA</span>(<span class="H">int</span>&nbsp;<span class="J">a</span>)</p>
<p class="AP">Sets first value.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="62"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">a</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Value.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::Logc::SetB(int)" class="W"><span class="H">void</span>&nbsp;<span class="I">SetB</span>(<span class="H">int</span>&nbsp;<span class="J">b</span>)</p>
<p class="AP">Sets second value.</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="62"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">b</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Value.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::Logc::IsEmpty()const" class="Y">bool<span class="V">&nbsp;</span><span class="Z">IsEmpty</span><span class="V">()&nbsp;</span>const</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="62"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">True if Logc is empty.</p></td></tr></table>
<p class="F">&nbsp;</p>
<p class="A">&nbsp;</p>
<p class="A">&nbsp;</p>
<p class="A">&nbsp;</p>
<table width="100%" border="0" cellpadding="0" cellspacing="0"><tr><td width="100%"><table width="100%" class="C"><colgroup><col width="100%"></colgroup>
<tr><td class="D"><p class="E">Ctrl::LogPos</p>
</td>
</tr>
</table></td>
</tr></table>
<p class="F">&nbsp;</p>
<p id="::Ctrl::LogPos::struct" class="AB"><span class="H">struct</span><span class="AF">&nbsp;</span>LogPos</p>
<p class="K">This nested class combines two Logc value into complete logical position.</p>
<p class="F">&nbsp;</p>
<p class="A">&nbsp;</p>
<table width="100%" border="0" cellpadding="0" cellspacing="0"><tr><td width="100%"><table width="100%" class="L"><colgroup><col width="100%"></colgroup>
<tr><td class="M"><p class="N">Constructor Detail</p>
</td>
</tr>
</table></td>
</tr></table>
<p class="F">&nbsp;</p>
<p id="Ctrl::LogPos::LogPos(Ctrl::Logc,Ctrl::Logc)" class="W"><span class="I">LogPos</span>(<a href="Ctrl::Logc"><u>Logc</u></a>&nbsp;<span class="J">x</span>, <a href="Ctrl::Logc"><u>Logc</u></a>&nbsp;<span class="J">y</span>)</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="62"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">x</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Horizontal Logc.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="62"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">y</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">Vertical Logc.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::LogPos::LogPos()" class="W"><span class="I">LogPos</span>()</p>
<p class="X">Default constructor. Sets both Logc empty.</p>
<p class="F">&nbsp;</p>
<p class="A">&nbsp;</p>
<table width="100%" border="0" cellpadding="0" cellspacing="0"><tr><td width="100%"><table width="100%" class="L"><colgroup><col width="100%"></colgroup>
<tr><td class="M"><p class="N">Public Member List</p>
</td>
</tr>
</table></td>
</tr></table>
<p class="F">&nbsp;</p>
<p id="Ctrl::LogPos::operator==(Ctrl::LogPos)const" class="Y">bool<span class="V">&nbsp;</span><span class="Z">operator==</span><span class="V">(</span><a href="Ctrl::LogPos"><span class="V"><u>LogPos</u></span></a><span class="V">&nbsp;</span><span class="J">b</span><span class="V">)&nbsp;</span>const</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="62"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">b</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">LogPos to compare with.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="62"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">True when equal.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::LogPos::operator!=(Ctrl::LogPos)const" class="Y">bool<span class="V">&nbsp;</span><span class="Z">operator!=</span><span class="V">(</span><a href="Ctrl::LogPos"><span class="V"><u>LogPos</u></span></a><span class="V">&nbsp;</span><span class="J">b</span><span class="V">)&nbsp;</span>const</p>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="62"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="Q">b</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">LogPos to compare with.</p></td></tr></table>
<table width="100%" border="0" cellpadding="2" cellspacing="2"><tr><td width="62"></td><td valign="top" width="224" bgcolor="#F0F0F0">
<p class="A"><span class="R">Return value</span></p></td>
<td valign="top" bgcolor="#F0F0F0">
<p class="A">True when equal.</p></td></tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::LogPos::x" class="AB"><a href="Ctrl::Logc"><span class="O"><u>Logc</u></span></a><span class="O">&nbsp;</span>x</p>
<p class="X">Horizontal Logc.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Ctrl::LogPos::y" class="AB"><a href="Ctrl::Logc"><span class="O"><u>Logc</u></span></a><span class="O">&nbsp;</span>y</p>
<p class="X">Vertical Logc.</p>
<p class="F">&nbsp;</p>
<p class="A">&nbsp;</p>
</TD>
</TR>
</TABLE>
</TD>
</TR>
</TABLE>
<TABLE BORDER="0" WIDTH="100%"><TR><TD></TD>
</TR>
</TABLE>
<TABLE BORDER="0" CELLSPACING="0" CELLPADDING="0" BGCOLOR="#FFFFFF" WIDTH="100%" style="border-style: solid; border-width: 1px; border-color: #6E89AE;padding: 10px;;"><TR><TD><TABLE BORDER="0" CELLSPACING="0" CELLPADDING="0" WIDTH="100%"><TR><TD><p class="A"><span class="B"> </span><a href="www$uppweb$contribweb$en-us.html">Do you want to contribute?</a></p>
</TD>
</TR>
</TABLE>
</TD>
</TR>
</TABLE>
</TD>
</TR>
</TABLE>
<script type="text/javascript">var a={};var p=window.location.pathname.split("/");p=p[p.length-1];var s='<select id="lang" onchange="window.location=document.getElementById(\'lang\').value;">';for(l in a){if(p==l){d=" selected=1"}else{d=""}s+='<option value="'+l+'"'+d+'>'+a[l]+'</option>'}s+='</select>';var d=document.createElement('div');d.innerHTML=s;var c=document.getElementById('langs');c.replaceChild(d,c.firstChild);document.getElementById('langbox').style.display='block';</script></BODY>
