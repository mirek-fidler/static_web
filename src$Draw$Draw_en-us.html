<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML lang="en-us">
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="Generator" CONTENT="U++ HTML Package">
<TITLE>Draw :: U++</TITLE>
<STYLE TYPE="text/css"><!--
.A{margin:0px 0px 0px 0px;text-indent:0px;text-align:left;color:#000000;font-family:sans-serif;font-size:10pt;font-weight:normal;font-style:normal;}
.B{font-size:12pt;}
.C{border-collapse:collapse;table-layout:auto;border: 2px solid #000000;}
.D{padding: 5px 5px 5px 5px;border-left: 1px solid #000000;border-top: 1px solid #000000;border-right: 1px solid #000000;border-bottom: 1px solid #000000;background-color:#800000;vertical-align:middle;}
.E{margin:0px 0px 0px 0px;text-indent:0px;text-align:left;color:#e5e5e5;font-family:sans-serif;font-size:16pt;font-weight:bold;font-style:normal;}
.F{margin:0px 0px 0px 0px;text-indent:0px;text-align:left;color:#000000;font-family:sans-serif;font-size:6pt;font-weight:normal;font-style:normal;}
.G{margin:0px 0px 5px 0px;text-indent:0px;text-align:left;color:#800000;font-family:sans-serif;font-size:12pt;font-weight:bold;font-style:normal;}
.H{color:#0000ff;font-weight:normal;}
.I{color:#000000;font-weight:normal;}
.J{color:#000000;}
.K{margin:8px 0px 0px 0px;text-indent:0px;text-align:left;color:#000000;font-family:sans-serif;font-size:10pt;font-weight:normal;font-style:normal;}
.L{border-collapse:collapse;table-layout:auto;border: 2px solid #808080;}
.M{padding: 3px 5px 3px 5px;border-left: 1px solid #808080;border-top: 1px solid #808080;border-right: 1px solid #808080;border-bottom: 1px solid #808080;background-color:#C0C0C0;vertical-align:middle;}
.N{margin:0px 0px 0px 0px;text-indent:0px;text-align:left;color:#000000;font-family:sans-serif;font-size:10pt;font-weight:bold;font-style:normal;}
.O{margin:0px 0px 5px 0px;text-indent:0px;text-align:left;color:#800000;font-family:sans-serif;font-size:10pt;font-weight:normal;font-style:normal;}
.P{color:#0000ff;}
.Q{color:#000000;font-weight:bold;}
.R{margin:0px 0px 0px 57px;text-indent:0px;text-align:left;color:#000000;font-family:sans-serif;font-size:10pt;font-weight:normal;font-style:normal;}
.S{padding: 3px 5px 3px 5px;border-left: 1px solid #000000;border-top: 1px solid #000000;border-right: 1px solid #000000;border-bottom: 1px solid #000000;background-color:#FFFFFF;vertical-align:top;}
.T{margin:0px 0px 0px 12px;text-indent:0px;text-align:left;color:#000000;font-family:sans-serif;font-size:10pt;font-weight:bold;font-style:normal;}
.U{margin:0px 0px 0px 19px;text-indent:0px;text-align:left;color:#000000;font-family:sans-serif;font-size:10pt;font-weight:normal;font-style:normal;}
.V{margin:0px 0px 5px 0px;text-indent:0px;text-align:left;color:#0000ff;font-family:sans-serif;font-size:10pt;font-weight:normal;font-style:normal;}
.W{margin:0px 0px 5px 0px;text-indent:0px;text-align:left;color:#000000;font-family:sans-serif;font-size:10pt;font-weight:normal;font-style:normal;}
.X{font-weight:bold;}
.Y{color:#800000;font-weight:bold;}
.Z{padding: 3px 5px 3px 5px;border-left: 1px solid #000000;border-top: 1px solid #000000;border-right: 1px solid #000000;border-bottom: 1px solid #000000;background-color:#FFFFFF;vertical-align:middle;}
.AA{margin:0px 0px 0px 12px;text-indent:0px;text-align:left;color:#000000;font-family:sans-serif;font-size:10pt;font-weight:normal;font-style:normal;}
.AB{font-weight:normal;}
.AC{color:#800000;}
a.l1         { text-decoration:none; font-size: 8pt; font-family: sans-serif; font-weight: normal; }
a.l1:link    { color:#000000; }
a.l1:visited { color:#000080; }
a.l1:hover   { color:#9933CC; }
a.l1:active  { color:#000000; }
a.l2         { text-decoration:none; font-size: 12pt; font-family: sans-serif; font-variant: small-caps; }
a.l2:link    { color:#0066FF; }
a.l2:visited { color:#FF6600; }
a.l2:hover   { color:#BC0624; }
a.l2:active  { color:#BC0024; }

-->
</STYLE>
<META NAME="keywords" CONTENT="framework, toolkit, widget, c++, visual, studio, dev-cpp, builder, ide, class, component,wxwidgets, qt, rapid, application, development, rad, mfc, linux, macos, gui, sdl, directx, desktop"><META name="robots" content="index,follow">
<LINK rel="alternate" type="application/rss+xml" title="SVN changes" href="svnchanges.xml">
<LINK rel="shortcut icon" type="image/png" href="favicon.png">
</HEAD><BODY BGCOLOR="#D2D9D2" ALINK="#800000" LINK="#000000" VLINK="#000080"><TABLE BORDER="0" CELLSPACING="0" CELLPADDING="0" WIDTH="100%"><TR><TD COLSPAN="3"><TABLE BORDER="0" CELLSPACING="0" CELLPADDING="0" WIDTH="100%" BGCOLOR="#FFFFFF" style="border: 1px solid #6E89AE;padding-left: 10px;padding-right: 0px;padding-top: 0px;padding-bottom: 0px;"><TR><TD><A HREF="index.html"><IMG SRC="0i.png" ALT="" BORDER="0"></A>
</TD>
<TD ALIGN="RIGHT" VALIGN="BOTTOM" STYLE="padding-bottom: 5px; background-image: url('1i.png')"><span style="font-size: 14pt; font-family: sans-serif;"><script type="text/javascript"><!--
google_ad_client = "pub-1082147624384270";
google_ad_width = 468;
google_ad_height = 60;
google_ad_format = "468x60_as";
google_ad_type = "text_image";
google_ad_channel = "";
google_color_border = "336699";
google_color_bg = "FFFFFF";
google_color_link = "0000FF";
google_color_text = "000000";
google_color_url = "008000";
//--></script>
<script type="text/javascript"
  src="https://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
&nbsp;&nbsp;</span>
</TD>
</TR>
</TABLE>
</TD>
</TR>
</TABLE>
<TABLE BORDER="0" CELLSPACING="0" CELLPADDING="0" WIDTH="100%"><TR><TD COLSPAN="3" BGCOLOR="#D2D9D2" HEIGHT="6"></TD>
</TR>
<TR><TD VALIGN="TOP" ALIGN="CENTER"><TABLE BORDER="0" CELLSPACING="0" CELLPADDING="0" WIDTH="160"><TR><TD ALIGN="CENTER"><TABLE BORDER="0" CELLSPACING="0" CELLPADDING="0" WIDTH="100%" BGCOLOR="#FFFFFF" style="border-style: solid; border-width: 1px; border-color: #6E89AE;padding: 0px"><TR><TD WIDTH="100%" VALIGN="MIDDLE" STYLE="background-image: url('2i.png'); border: 0px solid black; padding-left:12px; padding-right:0px; padding-top:6px; padding-bottom:6px;"><A HREF="www$uppweb$overview$en-us.html" CLASS="l1">Overview</A>
</TD>
</TR>
<TR><TD WIDTH="100%" VALIGN="MIDDLE" STYLE="background-image: url('2i.png'); border: 0px solid black; padding-left:12px; padding-right:0px; padding-top:6px; padding-bottom:6px; border-top: 1px solid #6E89AE;"><A HREF="www$uppweb$examples$en-us.html" CLASS="l1">Examples</A>
</TD>
</TR>
<TR><TD WIDTH="100%" VALIGN="MIDDLE" STYLE="background-image: url('2i.png'); border: 0px solid black; padding-left:12px; padding-right:0px; padding-top:6px; padding-bottom:6px; border-top: 1px solid #6E89AE;"><A HREF="www$uppweb$ss$en-us.html" CLASS="l1">Screenshots</A>
</TD>
</TR>
<TR><TD WIDTH="100%" VALIGN="MIDDLE" STYLE="background-image: url('2i.png'); border: 0px solid black; padding-left:12px; padding-right:0px; padding-top:6px; padding-bottom:6px; border-top: 1px solid #6E89AE;"><A HREF="www$uppweb$comparison$en-us.html" CLASS="l1">Comparisons</A>
</TD>
</TR>
<TR><TD WIDTH="100%" VALIGN="MIDDLE" STYLE="background-image: url('2i.png'); border: 0px solid black; padding-left:12px; padding-right:0px; padding-top:6px; padding-bottom:6px; border-top: 1px solid #6E89AE;"><A HREF="www$uppweb$apps$en-us.html" CLASS="l1">Applications</A>
</TD>
</TR>
<TR><TD WIDTH="100%" VALIGN="MIDDLE" STYLE="background-image: url('2i.png'); border: 0px solid black; padding-left:12px; padding-right:0px; padding-top:6px; padding-bottom:6px; border-top: 1px solid #6E89AE;"><A HREF="www$uppweb$download$en-us.html" CLASS="l1">Download</A>
</TD>
</TR>
<TR><TD WIDTH="100%" VALIGN="MIDDLE" STYLE="background-image: url('2i.png'); border: 0px solid black; padding-left:12px; padding-right:0px; padding-top:6px; padding-bottom:6px; border-top: 1px solid #6E89AE;"><A HREF="www$uppweb$documentation$en-us.html" CLASS="l1">Documentation</A>
</TD>
</TR>
<TR><TD WIDTH="100%" VALIGN="MIDDLE" STYLE="background-image: url('2i.png'); border: 0px solid black; padding-left:12px; padding-right:0px; padding-top:6px; padding-bottom:6px; border-top: 1px solid #6E89AE;"><A HREF="www$uppweb$Tutorials$en-us.html" CLASS="l1">Tutorials</A>
</TD>
</TR>
<TR><TD WIDTH="100%" VALIGN="MIDDLE" STYLE="background-image: url('2i.png'); border: 0px solid black; padding-left:12px; padding-right:0px; padding-top:6px; padding-bottom:6px; border-top: 1px solid #6E89AE;"><A HREF="app$ide$UppHub$en-us.html" CLASS="l1">UppHub</A>
</TD>
</TR>
<TR><TD WIDTH="100%" VALIGN="MIDDLE" STYLE="background-image: url('2i.png'); border: 0px solid black; padding-left:12px; padding-right:0px; padding-top:6px; padding-bottom:6px; border-top: 1px solid #6E89AE;"><A HREF="www$uppweb$Roadmap$en-us.html" CLASS="l1">Status & Roadmap</A>
</TD>
</TR>
<TR><TD WIDTH="100%" VALIGN="MIDDLE" STYLE="background-image: url('2i.png'); border: 0px solid black; padding-left:12px; padding-right:0px; padding-top:6px; padding-bottom:6px; border-top: 1px solid #6E89AE;"><A HREF="www$uppweb$FAQ$en-us.html" CLASS="l1">FAQ</A>
</TD>
</TR>
<TR><TD WIDTH="100%" VALIGN="MIDDLE" STYLE="background-image: url('2i.png'); border: 0px solid black; padding-left:12px; padding-right:0px; padding-top:6px; padding-bottom:6px; border-top: 1px solid #6E89AE;"><A HREF="app$ide$About$en-us.html" CLASS="l1">Authors & License</A>
</TD>
</TR>
<TR><TD WIDTH="100%" VALIGN="MIDDLE" STYLE="background-image: url('2i.png'); border: 0px solid black; padding-left:12px; padding-right:0px; padding-top:6px; padding-bottom:6px; border-top: 1px solid #6E89AE;"><A HREF="https://www.ultimatepp.org/forums" CLASS="l1">Forums</A>
</TD>
</TR>
<TR><TD WIDTH="100%" VALIGN="MIDDLE" STYLE="background-image: url('2i.png'); border: 0px solid black; padding-left:12px; padding-right:0px; padding-top:6px; padding-bottom:6px; border-top: 1px solid #6E89AE;"><A HREF="www$uppweb$Funding$en-us.html" CLASS="l1">Funding U++</A>
</TD>
</TR>
</TABLE>
<TABLE BORDER="0" WIDTH="100%"><TR><TD></TD>
</TR>
</TABLE>
<TABLE BORDER="0" CELLSPACING="0" CELLPADDING="0" WIDTH="100%" BGCOLOR="#FFFFFF" style="border-style: solid; border-width: 1px; border-color: #6E89AE;padding: 0px"><TR><TD WIDTH="100%" VALIGN="MIDDLE" STYLE="background-image: url('3i.png'); border: 0px solid black;padding-left:12px; padding-right:0px; padding-top:1px; padding-bottom:1px;color:#FFFFFF;"><B><span style="font-size: 8pt; font-family: sans-serif;">Search on this site</span>
</B>
</TD>
</TR>
<TR><TD WIDTH="100%" VALIGN="MIDDLE" STYLE="background-image: url('2i.png'); border: 0px solid black; padding-left:6px; padding-right:0px; padding-top:4px; padding-bottom:4px;border-top: 1px solid #6E89AE;"><TABLE BORDER="0" CELLSPACING="0" CELLPADDING="0" WIDTH="100%"><TR><TD><IMG SRC="4i.png" ALT="" BORDER="0"></TD>
<TD><FORM ACTION="https://www.google.com/search" METHOD="GET" STYLE="margin:0px;padding:0px;"><INPUT TYPE="HIDDEN" NAME="ie" VALUE="UTF-8"><INPUT TYPE="HIDDEN" NAME="oe" VALUE="UTF-8"><INPUT TYPE="TEXT" NAME="q" SIZE="15" MAXLENGTH="256" placeholder="Site search"><INPUT TYPE="HIDDEN" NAME="sitesearch" VALUE="ultimatepp.org"></FORM>
</TD>
</TR>
</TABLE>
</TD>
</TR>
</TABLE>
<TABLE BORDER="0" WIDTH="100%"><TR><TD></TD>
</TR>
</TABLE>
<br><div id="fb-root"></div>
<script type="text/javascript">(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) {return;}
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/en_US/all.js#xfbml=1";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>

<div class="fb-like" data-href="https://www.facebook.com/pages/Upp-Framework/262346610476027?sk=wall" data-send="false" data-layout="button_count" data-width="160" data-show-faces="false" data-font="arial"></div>
<br><br><script type="text/javascript"><!--
google_ad_client = "pub-1082147624384270";
google_ad_width = 160;
google_ad_height = 600;
google_ad_format = "160x600_as";
google_ad_type = "text_image";
google_ad_channel = "";
google_color_border = "336699";
google_color_bg = "FFFFFF";
google_color_link = "0000FF";
google_color_text = "000000";
google_color_url = "008000";
//--></script>
<script type="text/javascript"
  src="https://pagead2.googlesyndication.com/pagead/show_ads.js">
</script><br><br><script type="text/javascript"><!--
google_ad_client = "pub-1082147624384270";
google_ad_width = 160;
google_ad_height = 90;
google_ad_format = "160x90_0ads_al_s";
google_ad_channel = "";
google_color_border = "336699";
google_color_bg = "FFFFFF";
google_color_link = "0000FF";
google_color_text = "000000";
google_color_url = "008000";
//--></script>
<script type="text/javascript"
  src="https://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
<br><br><br><br><br><br><A HREF="https://sourceforge.net/projects/upp/"><IMG SRC="https://sourceforge.net/sflogo.php?group_id=93970&amp;type=2" ALT="SourceForge.net Logo" BORDER="0" WIDTH="125" HEIGHT="37"></A>
<br><br><A HREF="https://flathub.org/en/apps/org.ultimatepp.TheIDE"><IMG SRC="5i.png" ALT="SourceForge.net Logo" BORDER="0" WIDTH="125" HEIGHT="37"></A>
<br><br><div style="background-color:#ffffff;width:125;height:35"><A HREF="https://github.com/ultimatepp"><IMG SRC="6i.png" ALT="GitHub Logo" BORDER="0" WIDTH="125" HEIGHT="35"></A>
</div><br><div style="background-color:#ffffff;width:125;height:35"><div style="height:5"></div><A HREF="https://discord.gg/8XzqQzXZzb"><IMG SRC="https://assets-global.website-files.com/6257adef93867e50d84d30e2/636e0b5061df29d55a92d945_full_logo_blurple_RGB.svg" ALT="Discord Logo" BORDER="0" WIDTH="125" HEIGHT="25"></A>
</div><br></TD>
</TR>
</TABLE>
</TD>
<TD VALIGN="TOP" BGCOLOR="#D2D9D2"><TABLE BORDER="0" CELLSPACING="0" CELLPADDING="0" WIDTH="6"><TR><TD></TD>
</TR>
</TABLE>
</TD>
<TD VALIGN="TOP" WIDTH="100%" BGCOLOR="#D2D9D2"><TABLE BORDER="0" CELLSPACING="0" CELLPADDING="0" BGCOLOR="#FFFFFF" WIDTH="100%" style="border-style: solid; border-width: 1px; border-color: #6E89AE;padding: 10px;;"><TR><TD><TABLE BORDER="0" CELLSPACING="0" CELLPADDING="0" WIDTH="100%"><TR><TD><table width="100%" border="0" cellpadding="0" cellspacing="0"><tr><td width="100%"><table width="100%" class="C"><colgroup><col width="100%"></colgroup>
<tr><td class="D"><p class="E">Draw</p>
</td>
</tr>
</table></td>
</tr></table>
<p class="F">&nbsp;</p>
<p id="Draw::class" class="G"><span class="H">class</span><span class="I">&nbsp;</span><span class="J">Draw</span><span class="I">&nbsp;:&nbsp;</span><span class="H">private</span><span class="I">&nbsp;</span>NoCopy</p>
<p class="K">The class provides an abstract interface to basic graphical output, possibly HW accelerated. Whenever you need to paint something in a window, you need a Draw object for it. The standard Paint method of the Ctrl class takes a Draw&amp; parameter as well. In that case the underlying mechanism passes a derived SystemDraw which is already initialized for output into the respective control, knows about the current clipping, resolution etc. In a similar manner you can create your own Draw objects to draw onto Images, Drawings (vector metafiles used for serialization of graphical operations) or to perform printer output. You can also use a Draw to query some graphics-related properties, like the size of output area or native resolution.</p>
<p class="K">When Draw represents screen output, all metrics are always in pixels. If Draw represents any physical device (like printer), it uses artificial unit, &quot;dot&quot;, by default, which is equivalent to 1/600 of inch. In other words, it is the same as pixels size of 600dpi printer (standard printer resolution).</p>
<p class="K">However, it is also possible to switch to &quot;Native&quot; mode in some cases. In that case, Draw works in &quot;native&quot; pixels, for example 1/720 inch for some printers. Draw provides necessary metrics information to adjust graphic output.</p>
<p class="K">Some methods have several overloaded variants, for example DrawRect has variants that specify the rectangle using Rect type or x, y, cx, cy coordinates. In that case, implementation is provided by single abstract virtual backend method ending with Op (DrawRectOp) and non-virtual frontend methods are then used to provide overloading (via parameter translation to backend method parameters).</p>
<p class="K">Painting outside the output size is always legal - necessary clipping is performed in that case.</p>
<p class="F">&nbsp;</p>
<p class="A">&nbsp;</p>
<table width="100%" border="0" cellpadding="0" cellspacing="0"><tr><td width="100%"><table width="100%" class="L"><colgroup><col width="100%"></colgroup>
<tr><td class="M"><p class="N">Public Member List</p>
</td>
</tr>
</table></td>
</tr></table>
<p class="F">&nbsp;</p>
<p id="Draw::GetInfo()const" class="O"><span class="P">virtual</span><span class="J"> </span><a href="dword"><span class="J"><u>dword</u></span></a><span class="J">&nbsp;</span><span class="Q">GetInfo</span><span class="J">()&nbsp;</span><span class="P">const</span><span class="J">&nbsp;=&nbsp;</span>0</p>
<p class="R">Returns some basic information about Draw as combination of flags:</p>
<p class="R">&nbsp;</p>
<table width="100%" border="0" cellpadding="0" cellspacing="0"><tr><td><table border="0" width= 51px><tr><td></td></tr></table></td>
<td width="100%"><table width="100%" class="C"><colgroup><col width="37%"><col width="62%"></colgroup>
<tr><td class="S"><p class="T">Draw::DOTS&nbsp;=&nbsp;0x001</p>
</td>
<td class="S"><p class="U">Draw possibly represent physical device (printer, PDF output etc...).</p>
</td>
</tr>
<tr><td class="S"><p class="T">Draw::GUI&nbsp;=&nbsp;0x002</p>
</td>
<td class="S"><p class="U">Draw encapsulates main host platform GUI graphical output (e.g. GDI in Win32).</p>
</td>
</tr>
<tr><td class="S"><p class="T">Draw::PRINTER&nbsp;=&nbsp;0x004</p>
</td>
<td class="S"><p class="U">Draw represents printer.</p>
</td>
</tr>
<tr><td class="S"><p class="T">Draw::NATIVE&nbsp;=&nbsp;0x008</p>
</td>
<td class="S"><p class="U">Draw is in native mode.</p>
</td>
</tr>
<tr><td class="S"><p class="T">Draw::DATABANDS&nbsp;=&nbsp;0x010</p>
</td>
<td class="S"><p class="U">Draw can use banding to rescale images or for DrawData operation to reduce memory consumption.</p>
</td>
</tr>
</table></td>
</tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Draw::GetPageSize()const" class="V">virtual<span class="J"> </span><a href="Size"><span class="J"><u>Size</u></span></a><span class="J">&nbsp;</span><span class="Q">GetPageSize</span><span class="J">()&nbsp;</span>const</p>
<p class="R">Returns the size of actual output (size of window in pixels, size of printable area). If native mode is active and has different dpi, value is adjusted accordingly.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Draw::StartPage()" class="W"><span class="P">virtual</span> <span class="P">void</span>&nbsp;<span class="X">StartPage</span>()</p>
<p class="R">For printer output, starts a new page.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Draw::EndPage()" class="W"><span class="P">virtual</span> <span class="P">void</span>&nbsp;<span class="X">EndPage</span>()</p>
<p class="R">For printer output, ends page.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Draw::BeginOp()" class="O"><span class="P">virtual</span><span class="J"> </span><span class="P">void</span><span class="J">&nbsp;</span><span class="Q">BeginOp</span><span class="J">()&nbsp;=&nbsp;</span>0</p>
<p class="R">Implements Begin operation: Pushes current offset and clipping settings on Draw's internal stack.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Draw::EndOp()" class="O"><span class="P">virtual</span><span class="J"> </span><span class="P">void</span><span class="J">&nbsp;</span><span class="Q">EndOp</span><span class="J">()&nbsp;=&nbsp;</span>0</p>
<p class="R">Implements End operation: Pops offset and clipping settings, restoring the status before pairing BeginOp, OffsetOp, ClipOp, ExcludeClipOp or IntersectClipOp.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Draw::OffsetOp(Point)" class="O"><span class="P">virtual</span><span class="J"> </span><span class="P">void</span><span class="J">&nbsp;</span><span class="Q">OffsetOp</span><span class="J">(</span><a href="Point"><span class="J"><u>Point</u></span></a><span class="J">&nbsp;</span><span class="X">p</span><span class="J">)&nbsp;=&nbsp;</span>0</p>
<p class="R">Implements Offset operation: Calls Begin and then offsets coordinates so that <span class="Y">p</span> becomes Point(0, 0).</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Draw::ClipOp(const Rect&)" class="O"><span class="P">virtual</span><span class="J"> </span><span class="P">bool</span><span class="J">&nbsp;</span><span class="Q">ClipOp</span><span class="J">(</span><span class="P">const</span><span class="J">&nbsp;</span><a href="Rect"><span class="J"><u>Rect</u></span></a><span class="P">&amp;</span><span class="J">&nbsp;</span><span class="X">r</span><span class="J">)&nbsp;=&nbsp;</span>0</p>
<p class="R">Implements Clip operation: Calls Begin and then restricts all painting operations to <span class="Y">r</span> - nothing is painted outside this rectangle.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Draw::ClipoffOp(const Rect&)" class="O"><span class="P">virtual</span><span class="J"> </span><span class="P">bool</span><span class="J">&nbsp;</span><span class="Q">ClipoffOp</span><span class="J">(</span><span class="P">const</span><span class="J">&nbsp;</span><a href="Rect"><span class="J"><u>Rect</u></span></a><span class="P">&amp;</span><span class="J">&nbsp;</span><span class="X">r</span><span class="J">)&nbsp;=&nbsp;</span>0</p>
<p class="R">Implements ClipOff operation: Calls begin, then restricts all painting operations to <span class="Y">r</span> and offsets coordinates so that to left point of <span class="Y">r</span> becomes Point(0, 0).</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Draw::ExcludeClipOp(const Rect&)" class="O"><span class="P">virtual</span><span class="J"> </span><span class="P">bool</span><span class="J">&nbsp;</span><span class="Q">ExcludeClipOp</span><span class="J">(</span><span class="P">const</span><span class="J">&nbsp;</span><a href="Rect"><span class="J"><u>Rect</u></span></a><span class="P">&amp;</span><span class="J">&nbsp;</span><span class="X">r</span><span class="J">)&nbsp;=&nbsp;</span>0</p>
<p class="R">Implements ExcludeClip operation: Excludes <span class="Y">r</span> from the output - nothing is painted in this area. Does not affect the offset/clipping stack. This operation is only guaranteed to work in SystemDraw.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Draw::IntersectClipOp(const Rect&)" class="O"><span class="P">virtual</span><span class="J"> </span><span class="P">bool</span><span class="J">&nbsp;</span><span class="Q">IntersectClipOp</span><span class="J">(</span><span class="P">const</span><span class="J">&nbsp;</span><a href="Rect"><span class="J"><u>Rect</u></span></a><span class="P">&amp;</span><span class="J">&nbsp;</span><span class="X">r</span><span class="J">)&nbsp;=&nbsp;</span>0</p>
<p class="R">Implements IntersectClip operation: Intersects current clipping area with <span class="Y">r</span>. Does not affect the offset/clipping stack. This operation is only guaranteed to work in SystemDraw.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Draw::IsPaintingOp(const Rect&)const" class="O"><span class="P">virtual</span><span class="J"> </span><span class="P">bool</span><span class="J">&nbsp;</span><span class="Q">IsPaintingOp</span><span class="J">(</span><span class="P">const</span><span class="J">&nbsp;</span><a href="Rect"><span class="J"><u>Rect</u></span></a><span class="P">&amp;</span><span class="J">&nbsp;</span><span class="X">r</span><span class="J">)&nbsp;</span><span class="P">const</span><span class="J">&nbsp;=&nbsp;</span>0</p>
<p class="R">Implements IsPainting operation: Tests whether that should any painting happen in <span class="Y">r</span>. For example, if Draw represents graphics output to window in Ctrl::Paint, not all areas are always required to be repainted.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Draw::GetPaintRect()const" class="V">virtual<span class="J"> </span><a href="Rect"><span class="J"><u>Rect</u></span></a><span class="J">&nbsp;</span><span class="Q">GetPaintRect</span><span class="J">()&nbsp;</span>const</p>
<p class="R">Provides bounding rectangle for painted areas (areas where IsPaintingOp returns true). Default implementation returns very rectangle.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Draw::DrawRectOp(int,int,int,int,Color)" class="O"><span class="P">virtual</span><span class="J"> </span><span class="P">void</span><span class="J">&nbsp;</span><span class="Q">DrawRectOp</span><span class="J">(</span><span class="P">int</span><span class="J">&nbsp;</span><span class="X">x</span><span class="J">, </span><span class="P">int</span><span class="J">&nbsp;</span><span class="X">y</span><span class="J">, </span><span class="P">int</span><span class="J">&nbsp;</span><span class="X">cx</span><span class="J">, </span><span class="P">int</span><span class="J">&nbsp;</span><span class="X">cy</span><span class="J">, </span><a href="Color"><span class="J"><u>Color</u></span></a><span class="J">&nbsp;</span><span class="X">color</span><span class="J">)&nbsp;=&nbsp;</span>0</p>
<p class="R">Implements DrawRect operation: Fills rectangle <span class="Y">x</span>,<span class="Y">y</span>,<span class="Y">cx</span>,<span class="Y">cy</span> using <span class="Y">color</span>. As special addition, if Draw represents screen output in Ctrl::Paint, <span class="Y">color</span> can be assigned special value InvertColor() causing invertion of all pixels in target area. Note: On some platform, using InvertColor might results in suboptimal performance.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Draw::SysDrawImageOp(int,int,const Image&,Color)" class="W"><span class="P">virtual</span> <span class="P">void</span>&nbsp;<span class="X">SysDrawImageOp</span>(<span class="P">int</span>&nbsp;<span class="Y">x</span>, <span class="P">int</span>&nbsp;<span class="Y">y</span>, <span class="P">const</span>&nbsp;<a href="Image"><u>Image</u></a><span class="P">&amp;</span>&nbsp;<span class="Y">img</span>, <a href="Color"><u>Color</u></a>&nbsp;<span class="Y">color</span>)</p>
<p class="R">Low-level draw of Image. It depends on second variant of SysDrawImageOp to support <span class="Y">src</span> parameter using Offset and Clip.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Draw::SysDrawImageOp(int,int,const Image&,const Rect&,Color)" class="W"><span class="P">virtual</span> <span class="P">void</span>&nbsp;<span class="X">SysDrawImageOp</span>(<span class="P">int</span>&nbsp;<span class="Y">x</span>, <span class="P">int</span>&nbsp;<span class="Y">y</span>, <span class="P">const</span>&nbsp;<a href="Image"><u>Image</u></a><span class="P">&amp;</span>&nbsp;<span class="Y">img</span>, <span class="P">const</span>&nbsp;<a href="Rect"><u>Rect</u></a><span class="P">&amp;</span>&nbsp;<span class="Y">src</span>, <a href="Color"><u>Color</u></a>&nbsp;<span class="Y">color</span>)</p>
<p class="R">Low(er)-level draw of Image, called by DrawImageOp. Draw derived class can either override this method and depend on DrawImageOp to do rescaling and printer banding or override DrawImageOp directly. Default implementation uses Offset and Clip to provide support for <span class="Y">src</span> parameter.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Draw::DrawImageOp(int,int,int,int,const Image&,const Rect&,Color)" class="O"><span class="P">virtual</span><span class="J"> </span><span class="P">void</span><span class="J">&nbsp;</span><span class="Q">DrawImageOp</span><span class="J">(</span><span class="P">int</span><span class="J">&nbsp;</span><span class="X">x</span><span class="J">, </span><span class="P">int</span><span class="J">&nbsp;</span><span class="X">y</span><span class="J">, </span><span class="P">int</span><span class="J">&nbsp;</span><span class="X">cx</span><span class="J">, </span><span class="P">int</span><span class="J">&nbsp;</span><span class="X">cy</span><span class="J">, </span><span class="P">const</span><span class="J">&nbsp;</span><a href="Image"><span class="J"><u>Image</u></span></a><span class="P">&amp;</span><span class="J">&nbsp;</span><span class="X">img</span><span class="J">, </span><span class="P">const</span><span class="J">&nbsp;</span><a href="Rect"><span class="J"><u>Rect</u></span></a><span class="P">&amp;</span><span class="J">&nbsp;</span><span class="X">src</span><span class="J">, </span><a href="Color"><span class="J"><u>Color</u></span></a><span class="J">&nbsp;</span><span class="X">color</span><span class="J">)&nbsp;=&nbsp;</span>0</p>
<p class="R">Implements DrawImageOp: Draws <span class="Y">src</span> part of Image <span class="Y">img</span> at <span class="Y">x</span>, <span class="Y">y</span> rescaling it to <span class="Y">cx</span>, <span class="Y">cy</span> (if they are equal to original Image size, no rescaling is performed). If <span class="Y">color</span> is not null, only alpha information of Image is used and color pixels are painted using <span class="Y">color</span>. Default implementation performs rescaling operation in software, including banding support for printer, then calls SysDrawImageOp.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Draw::DrawDataOp(int,int,int,int,const String&,const char*)" class="W"><span class="P">virtual</span> <span class="P">void</span>&nbsp;<span class="X">DrawDataOp</span>(<span class="P">int</span>&nbsp;<span class="Y">x</span>, <span class="P">int</span>&nbsp;<span class="Y">y</span>, <span class="P">int</span>&nbsp;<span class="Y">cx</span>, <span class="P">int</span>&nbsp;<span class="Y">cy</span>, <span class="P">const</span>&nbsp;<a href="String"><u>String</u></a><span class="P">&amp;</span>&nbsp;<span class="Y">data</span>, <span class="P">const</span>&nbsp;<span class="P">char</span>&nbsp;*<span class="Y">id</span>)</p>
<p class="R">Implements DrawData operation. Draws arbitrary <span class="Y">data</span> of type <span class="Y">id</span> to rectangular area <span class="Y">x</span>,<span class="Y">y</span>,<span class="Y">cx</span>,<span class="Y">cy</span>. This can be used for example to print compressed bitmaps (e.g. in png format) directly, without the need of loading them to Image, this possibly saving memory requirements, as banding can be used to send the image to printer part by part. Actual painting process is implemented in <a href="DataDrawer">DataDrawer</a> and <span class="Y">id</span> has to be registered using DataDrawer::Register.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Draw::DrawLineOp(int,int,int,int,int,Color)" class="O"><span class="P">virtual</span><span class="J"> </span><span class="P">void</span><span class="J">&nbsp;</span><span class="Q">DrawLineOp</span><span class="J">(</span><span class="P">int</span><span class="J">&nbsp;</span><span class="X">x1</span><span class="J">, </span><span class="P">int</span><span class="J">&nbsp;</span><span class="X">y1</span><span class="J">, </span><span class="P">int</span><span class="J">&nbsp;</span><span class="X">x2</span><span class="J">, </span><span class="P">int</span><span class="J">&nbsp;</span><span class="X">y2</span><span class="J">, </span><span class="P">int</span><span class="J">&nbsp;</span><span class="X">width</span><span class="J">, </span><a href="Color"><span class="J"><u>Color</u></span></a><span class="J">&nbsp;</span><span class="X">color</span><span class="J">)&nbsp;=&nbsp;</span>0</p>
<p class="R">Implements DrawLine operation. Draws line from <span class="Y">x1</span>,<span class="Y">y1</span> to <span class="Y">x2</span>,<span class="Y">y2</span> (included) <span class="Y">width</span> pixels wide, with <span class="Y">color</span>. Width can contain special values, in that case line with width 1 is drawn and special dash pattern is applied:</p>
<p class="R">&nbsp;</p>
<table width="100%" border="0" cellpadding="0" cellspacing="0"><tr><td><table border="0" width= 57px><tr><td></td></tr></table></td>
<td width="100%"><table width="100%" class="C"><colgroup><col width="30%"><col width="69%"></colgroup>
<tr><td class="Z"><p class="T">PEN_NULL</p>
</td>
<td class="Z"><p class="AA">empty pen (nothing is drawn)</p>
</td>
</tr>
<tr><td class="Z"><p class="T">PEN_SOLID</p>
</td>
<td class="Z"><p class="AA">solid pen</p>
</td>
</tr>
<tr><td class="Z"><p class="T">PEN_DASH</p>
</td>
<td class="Z"><p class="AA">dashed pen &nbsp;_ _ _</p>
</td>
</tr>
<tr><td class="Z"><p class="T">PEN_DOT</p>
</td>
<td class="Z"><p class="T"><span class="AB">dotted pen (dashes are shorter) </span>. . .</p>
</td>
</tr>
<tr><td class="Z"><p class="T">PEN_DASHDOT</p>
</td>
<td class="Z"><p class="AA">dash - dot - dash - dot pattern _._._.</p>
</td>
</tr>
<tr><td class="Z"><p class="T">PEN_DASHDOTDOT</p>
</td>
<td class="Z"><p class="AA">dash - dot - dot - dash - dot - dot pattern _.._.._..</p>
</td>
</tr>
</table></td>
</tr></table>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Draw::DrawPolyPolylineOp(const Point*,int,const int*,int,int,Color,Color)" class="O"><span class="P">virtual</span><span class="J"> </span><span class="P">void</span><span class="J">&nbsp;</span><span class="Q">DrawPolyPolylineOp</span><span class="J">(</span><span class="P">const</span><span class="J">&nbsp;</span><a href="Point"><span class="J"><u>Point</u></span></a><span class="J">&nbsp;*</span><span class="X">vertices</span><span class="J">, </span><span class="P">int</span><span class="J">&nbsp;</span><span class="X">vertex_count</span><span class="J">, </span><span class="P">const</span><span class="J">&nbsp;</span><span class="P">int</span><span class="J">&nbsp;*</span><span class="X">counts</span><span class="J">, </span><span class="P">int</span><span class="J">&nbsp;</span><span class="X">count_count</span><span class="J">, </span><span class="P">int</span><span class="J">&nbsp;</span><span class="X">width</span><span class="J">, </span><a href="Color"><span class="J"><u>Color</u></span></a><span class="J">&nbsp;</span><span class="X">color</span><span class="J">, </span><a href="Color"><span class="J"><u>Color</u></span></a><span class="J">&nbsp;</span><span class="X">doxor</span><span class="J">)&nbsp;=&nbsp;</span>0</p>
<p class="R">Implements DrawPolyPolyline operation: Draws a series of polylines. Polyline vertices are kept in the array <span class="Y">vertices</span>. The parameter <span class="Y">vertex_count</span> gives the total number of vertices of all polylines in the array. The array <span class="Y">counts </span>gives numbers of points defining the individual polylines and <span class="Y">count_count </span>gives number of entries in this array (i.e. the number of connected polylines). The first polyline comprises vertices <span class="Y">vertices</span>[0], <span class="Y">vertices</span>[1] ... <span class="Y">vertices</span>[<span class="Y">counts</span>[0] - 1], the second polyline <span class="Y">vertices</span>[<span class="Y">counts</span>[0]], <span class="Y">vertices</span>[<span class="Y">counts</span>[0] + 1] ... <span class="Y">vertices</span>[<span class="Y">counts</span>[0] + <span class="Y">counts</span>[1] - 1], etc. The width parameter can be equal to the same <span class="X">PEN_</span>* special values as width in DrawLineOp. Line is drawn with <span class="Y">color</span>, if <span class="Y">doxor</span> is not null, such color in the background gets inverted.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Draw::DrawPolyPolyPolygonOp(const Point*,int,const int*,int,const int*,int,Color,int,Color,uint64,Color)" class="O"><span class="P">virtual</span><span class="J"> </span><span class="P">void</span><span class="J">&nbsp;</span><span class="Q">DrawPolyPolyPolygonOp</span><span class="J">(</span><span class="P">const</span><span class="J">&nbsp;</span><a href="Point"><span class="J"><u>Point</u></span></a><span class="J">&nbsp;*</span><span class="X">vertices</span><span class="J">, </span><span class="P">int</span><span class="J">&nbsp;</span><span class="X">vertex_count</span><span class="J">, </span><span class="P">const</span><span class="J">&nbsp;</span><span class="P">int</span><span class="J">&nbsp;*</span><span class="X">subpolygon_counts</span><span class="J">, </span><span class="P">int</span><span class="J">&nbsp;</span><span class="X">scc</span><span class="J">, </span><span class="P">const</span><span class="J">&nbsp;</span><span class="P">int</span><span class="J">&nbsp;*</span><span class="X">disjunct_polygon_counts</span><span class="J">, </span><span class="P">int</span><span class="J">&nbsp;</span><span class="X">dpcc</span><span class="J">, </span><a href="Color"><span class="J"><u>Color</u></span></a><span class="J">&nbsp;</span><span class="X">color</span><span class="J">, </span><span class="P">int</span><span class="J">&nbsp;</span><span class="X">width</span><span class="J">, </span><a href="Color"><span class="J"><u>Color</u></span></a><span class="J">&nbsp;</span><span class="X">outline</span><span class="J">, </span><a href="uint64"><span class="J"><u>uint64</u></span></a><span class="J">&nbsp;</span><span class="X">pattern</span><span class="J">, </span><a href="Color"><span class="J"><u>Color</u></span></a><span class="J">&nbsp;</span><span class="X">doxor</span><span class="J">)&nbsp;=&nbsp;</span>0</p>
<p class="R">Implements DrawPolyPolyPolygon operation: Draws a series of complex polygons. The <span class="Y">vertices</span> array holds all polygon defining vertices. The array is divided into sections corresponding to the whole complex polygons (parameters <span class="Y">disjunct_polygon_counts</span>) and these sections are further divided into the individual polygons defining one complex polygon (i.e. outer boundary and holes). Numbers of vertices in the individual polygons are held in the array <span class="Y">subpolygon_counts </span>(total number of simple polygons = subpolygon_count_count).</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Draw::DrawArcOp(const Rect&,Point,Point,int,Color)" class="O"><span class="P">virtual</span><span class="J"> </span><span class="P">void</span><span class="J">&nbsp;</span><span class="Q">DrawArcOp</span><span class="J">(</span><span class="P">const</span><span class="J">&nbsp;</span><a href="Rect"><span class="J"><u>Rect</u></span></a><span class="P">&amp;</span><span class="J">&nbsp;</span><span class="X">rc</span><span class="J">, </span><a href="Point"><span class="J"><u>Point</u></span></a><span class="J">&nbsp;</span><span class="X">start</span><span class="J">, </span><a href="Point"><span class="J"><u>Point</u></span></a><span class="J">&nbsp;</span><span class="X">end</span><span class="J">, </span><span class="P">int</span><span class="J">&nbsp;</span><span class="X">width</span><span class="J">, </span><a href="Color"><span class="J"><u>Color</u></span></a><span class="J">&nbsp;</span><span class="X">color</span><span class="J">)&nbsp;=&nbsp;</span>0</p>
<p class="R">Implements DrawArc operation: Draws elliptic arc corresponding to the largest ellipse fully within the rectangle <span class="Y">rc</span> and running counterclockwise from the direction corresponding to the line connecting the centre of the ellipse (<span class="Y">rc</span>.CenterPoint()) with the point <span class="Y">start </span>and ending at direction of the point <span class="Y">end </span>from the ellipse centre. When start == end, the full ellipse is drawn. <span class="Y">width</span> is the width of line, painted in <span class="Y">color</span>.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Draw::DrawEllipseOp(const Rect&,Color,int,Color)" class="O"><span class="P">virtual</span><span class="J"> </span><span class="P">void</span><span class="J">&nbsp;</span><span class="Q">DrawEllipseOp</span><span class="J">(</span><span class="P">const</span><span class="J">&nbsp;</span><a href="Rect"><span class="J"><u>Rect</u></span></a><span class="P">&amp;</span><span class="J">&nbsp;</span><span class="X">r</span><span class="J">, </span><a href="Color"><span class="J"><u>Color</u></span></a><span class="J">&nbsp;</span><span class="X">color</span><span class="J">, </span><span class="P">int</span><span class="J">&nbsp;</span><span class="X">pen</span><span class="J">, </span><a href="Color"><span class="J"><u>Color</u></span></a><span class="J">&nbsp;</span><span class="X">pencolor</span><span class="J">)&nbsp;=&nbsp;</span>0</p>
<p class="R">Implements DrawEllipse operation: Draws the largest ellipse with both axes parallel to coordinate axes fully within rectangle <span class="Y">r</span>, i.e. with center point at r.CenterPoint(), semi major axis and semi minor axis equal to r.Width() / 2 and r.Height() / 2. If <span class="Y">pen</span> is not 0, Ellipse will be have border line of width <span class="Y">pen</span> and color <span class="Y">pencolor</span>.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Draw::DrawTextOp(int,int,int,const wchar*,Font,Color,int,const int*)" class="O"><span class="P">virtual</span><span class="J"> </span><span class="P">void</span><span class="J">&nbsp;</span><span class="Q">DrawTextOp</span><span class="J">(</span><span class="P">int</span><span class="J">&nbsp;</span><span class="X">x</span><span class="J">, </span><span class="P">int</span><span class="J">&nbsp;</span><span class="X">y</span><span class="J">, </span><span class="P">int</span><span class="J">&nbsp;</span><span class="X">angle</span><span class="J">, </span><span class="P">const</span><span class="J">&nbsp;</span><a href="wchar"><span class="J"><u>wchar</u></span></a><span class="J">&nbsp;*</span><span class="X">text</span><span class="J">, </span><a href="Font"><span class="J"><u>Font</u></span></a><span class="J">&nbsp;</span><span class="X">font</span><span class="J">, </span><a href="Color"><span class="J"><u>Color</u></span></a><span class="J">&nbsp;</span><span class="X">ink</span><span class="J">, </span><span class="P">int</span><span class="J">&nbsp;</span><span class="X">n</span><span class="J">, </span><span class="P">const</span><span class="J">&nbsp;</span><span class="P">int</span><span class="J">&nbsp;*</span><span class="X">dx</span><span class="J">)&nbsp;=&nbsp;</span>0</p>
<p class="R">Implements DrawText operation:Draws a <span class="Y">text </span>at position starting at <span class="Y">x</span>, <span class="Y">y</span> (it represents top-left corner of text cell: for horizontal text, x identifies reference point and y is ascent above the baseline) going at <span class="Y">angle</span> using <span class="Y">font</span> and color <span class="Y">ink</span>. <span class="Y">n</span> is a number of characters to paint. If <span class="Y">dx </span>is not NULL, it specifies advancements of individual characters (it must be <span class="Y">n</span> elements in this array), otherwise advancements from font metrics are used.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Draw::DrawDrawingOp(const Rect&,const Drawing&)" class="W"><span class="P">virtual</span> <span class="P">void</span>&nbsp;<span class="X">DrawDrawingOp</span>(<span class="P">const</span>&nbsp;<a href="Rect"><u>Rect</u></a><span class="P">&amp;</span>&nbsp;<span class="Y">target</span>, <span class="P">const</span>&nbsp;<a href="Drawing"><u>Drawing</u></a><span class="P">&amp;</span>&nbsp;<span class="Y">w</span>)</p>
<p class="R">Implements DrawDrawing operation: Draws <a href="Drawing">Drawing</a> <span class="Y">w</span> scaled into <span class="Y">target</span>. Base Draw provides default implementation of this function (in fact, it could most likely be non-virtual).</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Draw::DrawPaintingOp(const Rect&,const Painting&)" class="W"><span class="P">virtual</span> <span class="P">void</span>&nbsp;<span class="X">DrawPaintingOp</span>(<span class="P">const</span>&nbsp;<a href="Rect"><u>Rect</u></a><span class="P">&amp;</span>&nbsp;<span class="Y">target</span>, <span class="P">const</span>&nbsp;<a href="Painting"><u>Painting</u></a><span class="P">&amp;</span>&nbsp;<span class="Y">w</span>)</p>
<p class="R">Implements DrawPainting operation: Draws <a href="Drawing">Drawing</a> <span class="Y">w</span> scaled into <span class="Y">target</span>. Base Draw provides default implementation, which paints Painting using DrawImage, possibly using banding technique to reduce the memory requirements. Painter package has to be included in the project for this to work.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Draw::GetNativeDpi()const" class="V">virtual<span class="J"> </span><a href="Size"><span class="J"><u>Size</u></span></a><span class="J">&nbsp;</span><span class="Q">GetNativeDpi</span><span class="J">()&nbsp;</span>const</p>
<p class="R">Returns native resolution of target device. Default implementation returns Size(600, 600) for Dots device and Size(96, 96) for screen output.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Draw::BeginNative()" class="W"><span class="P">virtual</span> <span class="P">void</span>&nbsp;<span class="X">BeginNative</span>()</p>
<p class="R">Starts native resolution mode, if available. Can be called several times (only first call is effective). If device does not have native mode, it has no effect.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Draw::EndNative()" class="W"><span class="P">virtual</span> <span class="P">void</span>&nbsp;<span class="X">EndNative</span>()</p>
<p class="R">Ends native resolution mode. If BeginNative was called several times, has to be called the same number of times to end the native mode.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Draw::GetCloffLevel()const" class="V">virtual<span class="J"> </span>int<span class="J">&nbsp;</span><span class="Q">GetCloffLevel</span><span class="J">()&nbsp;</span>const</p>
<p class="R">Returns the number of elements in clip&amp;offset stack. Mostly used for diagnostic purposes.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Upp::Draw::Escape(const Upp::String&)" class="W"><span class="P">virtual void</span>&nbsp;<span class="X">Escape</span>(<span class="P">const</span>&nbsp;<a href="Upp::String"><u>String</u></a><span class="P">&amp;</span>&nbsp;<span class="Y">data</span>)</p>
<p class="R">Passes additional information to Draw target instance. For example, PdfDraw understands &quot;url:http://link.html&quot; escapes to define text hyperlinks. Frontend to EscapeOp.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Draw::GetPixelsPerInch()const" class="V"><a href="Size"><span class="J"><u>Size</u></span></a><span class="J">&nbsp;</span><span class="Q">GetPixelsPerInch</span><span class="J">()&nbsp;</span>const</p>
<p class="R">Returns active resolution. Returns native resolution if native mode is active, or Size(600, 600) for physical output or Size(96, 96) for screen output.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Draw::GetPageMMs()const" class="V"><a href="Size"><span class="J"><u>Size</u></span></a><span class="J">&nbsp;</span><span class="Q">GetPageMMs</span><span class="J">()&nbsp;</span>const</p>
<p class="R">Recomputes GetPageSize to millimeters.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Draw::Dots()const" class="V">bool<span class="J">&nbsp;</span><span class="Q">Dots</span><span class="J">()&nbsp;</span>const</p>
<p class="R">Same as GetInfo() &amp; DOTS. True for physical device.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Draw::Pixels()const" class="V">bool<span class="J">&nbsp;</span><span class="Q">Pixels</span><span class="J">()&nbsp;</span>const</p>
<p class="R">Same as !Dots(). True for screen output.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Draw::IsPrinter()const" class="V">bool<span class="J">&nbsp;</span><span class="Q">IsPrinter</span><span class="J">()&nbsp;</span>const</p>
<p class="R">Same as GetInfo() &amp; PRINTER. True if output is printer.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Draw::IsNative()const" class="V">bool<span class="J">&nbsp;</span><span class="Q">IsNative</span><span class="J">()&nbsp;</span>const</p>
<p class="R">Same as GetInfo() &amp; NATIVE. True if native resolution mode is active.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Draw::GetNativeX(int)const" class="V">int<span class="J">&nbsp;</span><span class="Q">GetNativeX</span><span class="J">(</span>int<span class="J">&nbsp;</span><span class="Y">x</span><span class="J">)&nbsp;</span>const</p>
<p class="R">Recomputes <span class="Y">x</span> from 600 dpi dots to native horizontal resolution.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Draw::GetNativeY(int)const" class="V">int<span class="J">&nbsp;</span><span class="Q">GetNativeY</span><span class="J">(</span>int<span class="J">&nbsp;</span><span class="Y">y</span><span class="J">)&nbsp;</span>const</p>
<p class="R">Recomputes <span class="Y">y</span> from 600 dpi dots to native vertical resolution.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Draw::Native(int&,int&)const" class="V">void<span class="J">&nbsp;</span><span class="Q">Native</span><span class="J">(</span>int&amp;<span class="J">&nbsp;</span><span class="Y">x</span><span class="J">, </span>int&amp;<span class="J">&nbsp;</span><span class="Y">y</span><span class="J">)&nbsp;</span>const</p>
<p class="R">Recomputes point coordinates from 600 dpi dots to native resolution.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Draw::Native(Point&)const" class="V">void<span class="J">&nbsp;</span><span class="Q">Native</span><span class="J">(</span><a href="Point"><span class="J"><u>Point</u></span></a>&amp;<span class="J">&nbsp;</span><span class="Y">p</span><span class="J">)&nbsp;</span>const</p>
<p class="R">Recomputes point from 600 dpi dots to native resolution.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Draw::Native(Size&)const" class="V">void<span class="J">&nbsp;</span><span class="Q">Native</span><span class="J">(</span><a href="Size"><span class="J"><u>Size</u></span></a>&amp;<span class="J">&nbsp;</span><span class="Y">sz</span><span class="J">)&nbsp;</span>const</p>
<p class="R">Recomputes Size from 600 dpi dots to native resolution.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Draw::Native(Rect&)const" class="V">void<span class="J">&nbsp;</span><span class="Q">Native</span><span class="J">(</span><a href="Rect"><span class="J"><u>Rect</u></span></a>&amp;<span class="J">&nbsp;</span><span class="Y">r</span><span class="J">)&nbsp;</span>const</p>
<p class="R">Recomputes Rect from 600 dpi dots to native resolution..</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Draw::Begin()" class="W"><span class="P">void</span>&nbsp;<span class="X">Begin</span>()</p>
<p class="R">Pushes current offset and clipping settings on Draw's internal stack. Frontend to BeginOp.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Draw::End()" class="W"><span class="P">void</span>&nbsp;<span class="X">End</span>()</p>
<p class="R">Pops offset and clipping settings, restoring the status before pairing BeginOp, OffsetOp, ClipOp, ExcludeClipOp or IntersectClipOp. Frontend to EndOp.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Draw::Offset(Point)" class="W"><span class="P">void</span>&nbsp;<span class="X">Offset</span>(<a href="Point"><u>Point</u></a>&nbsp;<span class="Y">p</span>)</p>
<p id="Draw::Offset(int,int)" class="W"><span class="P">void</span>&nbsp;<span class="X">Offset</span>(<span class="P">int</span>&nbsp;<span class="Y">x</span>, <span class="P">int</span>&nbsp;<span class="Y">y</span>)</p>
<p class="R">Calls Begin and then offsets coordinates so that <span class="Y">p</span> or <span class="Y">x</span>,<span class="Y">y</span> becomes Point(0, 0). Uses OffsetOp for implementation. Frontend to OffsetOp.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Draw::Clip(const Rect&)" class="W"><span class="P">bool</span>&nbsp;<span class="X">Clip</span>(<span class="P">const</span>&nbsp;<a href="Rect"><u>Rect</u></a><span class="P">&amp;</span>&nbsp;<span class="Y">r</span>)</p>
<p id="Draw::Clip(int,int,int,int)" class="W"><span class="P">bool</span>&nbsp;<span class="X">Clip</span>(<span class="P">int</span>&nbsp;<span class="Y">x</span>, <span class="P">int</span>&nbsp;<span class="Y">y</span>, <span class="P">int</span>&nbsp;<span class="Y">cx</span>, <span class="P">int</span>&nbsp;<span class="Y">cy</span>)</p>
<p class="R">Calls Begin and then restricts all painting operations to <span class="Y">r</span> or <span class="Y">x</span>,<span class="Y">y</span>,<span class="Y">cx</span>,<span class="Y">cy</span> rectangle - nothing is painted outside this rectangle. Frontend to ClipOp.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Draw::Clipoff(const Rect&)" class="W"><span class="P">bool</span>&nbsp;<span class="X">Clipoff</span>(<span class="P">const</span>&nbsp;<a href="Rect"><u>Rect</u></a><span class="P">&amp;</span>&nbsp;<span class="Y">r</span>)</p>
<p id="Draw::Clipoff(int,int,int,int)" class="W"><span class="P">bool</span>&nbsp;<span class="X">Clipoff</span>(<span class="P">int</span>&nbsp;<span class="Y">x</span>, <span class="P">int</span>&nbsp;<span class="Y">y</span>, <span class="P">int</span>&nbsp;<span class="Y">cx</span>, <span class="P">int</span>&nbsp;<span class="Y">cy</span>)</p>
<p class="R">Implements ClipOff operation: Calls begin, then restricts all painting operations to <span class="Y">r</span> or <span class="Y">x</span>,<span class="Y">y</span>,<span class="Y">cx</span>,<span class="Y">cy</span> rectangle and offsets coordinates so that to left point of <span class="Y">r</span> or point <span class="Y">x</span>,<span class="Y">y</span> becomes Point(0, 0). Frontend to ClipoffOp.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Draw::ExcludeClip(const Rect&)" class="W"><span class="P">bool</span>&nbsp;<span class="X">ExcludeClip</span>(<span class="P">const</span>&nbsp;<a href="Rect"><u>Rect</u></a><span class="P">&amp;</span>&nbsp;<span class="Y">r</span>)</p>
<p id="Draw::ExcludeClip(int,int,int,int)" class="W"><span class="P">bool</span>&nbsp;<span class="X">ExcludeClip</span>(<span class="P">int</span>&nbsp;<span class="Y">x</span>, <span class="P">int</span>&nbsp;<span class="Y">y</span>, <span class="P">int</span>&nbsp;<span class="Y">cx</span>, <span class="P">int</span>&nbsp;<span class="Y">cy</span>)</p>
<p class="R">Excludes <span class="Y">r</span> or rectangle <span class="Y">x</span>,<span class="Y">y</span>,<span class="Y">cx</span>,<span class="Y">cy</span> from the output - nothing is painted in this area. Does not affect the offset/clipping stack. This operation is only guaranteed to work in SystemDraw. Frontend to ExcludeClipOp.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Draw::IntersectClip(const Rect&)" class="W"><span class="P">bool</span>&nbsp;<span class="X">IntersectClip</span>(<span class="P">const</span>&nbsp;<a href="Rect"><u>Rect</u></a><span class="P">&amp;</span>&nbsp;<span class="Y">r</span>)</p>
<p id="Draw::IntersectClip(int,int,int,int)" class="W"><span class="P">bool</span>&nbsp;<span class="X">IntersectClip</span>(<span class="P">int</span>&nbsp;<span class="Y">x</span>, <span class="P">int</span>&nbsp;<span class="Y">y</span>, <span class="P">int</span>&nbsp;<span class="Y">cx</span>, <span class="P">int</span>&nbsp;<span class="Y">cy</span>)</p>
<p class="R">Intersects current clipping area with <span class="Y">r</span> or rectangle <span class="Y">x</span>,<span class="Y">y</span>,<span class="Y">cx</span>,<span class="Y">cy</span>. Does not affect the offset/clipping stack. This operation is only guaranteed to work in SystemDraw. Frontend to IntersectClipOp.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Draw::IsPainting(const Rect&)const" class="V">bool<span class="J">&nbsp;</span><span class="Q">IsPainting</span><span class="J">(</span>const<span class="J">&nbsp;</span><a href="Rect"><span class="J"><u>Rect</u></span></a>&amp;<span class="J">&nbsp;</span><span class="Y">r</span><span class="J">)&nbsp;</span>const</p>
<p id="Draw::IsPainting(int,int,int,int)const" class="W"><span class="P">bool</span>&nbsp;<span class="X">IsPainting</span>(<span class="P">int</span>&nbsp;<span class="Y">x</span>, <span class="P">int</span>&nbsp;<span class="Y">y</span>, <span class="P">int</span>&nbsp;<span class="Y">cx</span>, <span class="P">int</span>&nbsp;<span class="Y">cy</span>)&nbsp;<span class="P">const</span> .</p>
<p class="R">Tests whether that should any painting happen in <span class="Y">r</span> or rectangle <span class="Y">x</span>,<span class="Y">y</span>,<span class="Y">cx</span>,<span class="Y">cy</span>. For example, if Draw represents graphics output to window in Ctrl::Paint, not all areas are always required to be repainted. Frontend to IsPaintingOp.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Draw::DrawRect(int,int,int,int,Color)" class="W"><span class="P">void</span>&nbsp;<span class="X">DrawRect</span>(<span class="P">int</span>&nbsp;<span class="Y">x</span>, <span class="P">int</span>&nbsp;<span class="Y">y</span>, <span class="P">int</span>&nbsp;<span class="Y">cx</span>, <span class="P">int</span>&nbsp;<span class="Y">cy</span>, <a href="Color"><u>Color</u></a>&nbsp;<span class="Y">color</span>)</p>
<p id="Draw::DrawRect(const Rect&,Color)" class="W"><span class="P">void</span>&nbsp;<span class="X">DrawRect</span>(<span class="P">const</span>&nbsp;<a href="Rect"><u>Rect</u></a><span class="P">&amp;</span>&nbsp;<span class="Y">rect</span>, <a href="Color"><u>Color</u></a>&nbsp;<span class="Y">color</span>)</p>
<p class="R">Fills <span class="Y">rect</span> or rectangle <span class="Y">x</span>,<span class="Y">y</span>,<span class="Y">cx</span>,<span class="Y">cy</span> using <span class="Y">color</span>. As special addition, if Draw represents screen output in Ctrl::Paint, <span class="Y">color</span> can be assigned special value InvertColor() causing invertion of all pixels in target area. Frontend to DrawRectOp. Note: On some platform, using InvertColor might results in suboptimal performance.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Draw::DrawImage(int,int,int,int,const Image&,const Rect&)" class="W"><span class="P">void</span>&nbsp;<span class="X">DrawImage</span>(<span class="P">int</span>&nbsp;<span class="Y">x</span>, <span class="P">int</span>&nbsp;<span class="Y">y</span>, <span class="P">int</span>&nbsp;<span class="Y">cx</span>, <span class="P">int</span>&nbsp;<span class="Y">cy</span>, <span class="P">const</span>&nbsp;<a href="Image"><u>Image</u></a><span class="P">&amp;</span>&nbsp;<span class="Y">img</span>, <span class="P">const</span>&nbsp;<a href="Rect"><u>Rect</u></a><span class="P">&amp;</span>&nbsp;<span class="Y">src</span>)</p>
<p id="Draw::DrawImage(int,int,int,int,const Image&)" class="W"><span class="P">void</span>&nbsp;<span class="X">DrawImage</span>(<span class="P">int</span>&nbsp;<span class="Y">x</span>, <span class="P">int</span>&nbsp;<span class="Y">y</span>, <span class="P">int</span>&nbsp;<span class="Y">cx</span>, <span class="P">int</span>&nbsp;<span class="Y">cy</span>, <span class="P">const</span>&nbsp;<a href="Image"><u>Image</u></a><span class="P">&amp;</span>&nbsp;<span class="Y">img</span>)</p>
<p id="Draw::DrawImage(int,int,int,int,const Image&,const Rect&,Color)" class="W"><span class="P">void</span>&nbsp;<span class="X">DrawImage</span>(<span class="P">int</span>&nbsp;<span class="Y">x</span>, <span class="P">int</span>&nbsp;<span class="Y">y</span>, <span class="P">int</span>&nbsp;<span class="Y">cx</span>, <span class="P">int</span>&nbsp;<span class="Y">cy</span>, <span class="P">const</span>&nbsp;<a href="Image"><u>Image</u></a><span class="P">&amp;</span>&nbsp;<span class="Y">img</span>, <span class="P">const</span>&nbsp;<a href="Rect"><u>Rect</u></a><span class="P">&amp;</span>&nbsp;<span class="Y">src</span>, <a href="Color"><u>Color</u></a>&nbsp;<span class="Y">color</span>)</p>
<p id="Draw::DrawImage(int,int,int,int,const Image&,Color)" class="W"><span class="P">void</span>&nbsp;<span class="X">DrawImage</span>(<span class="P">int</span>&nbsp;<span class="Y">x</span>, <span class="P">int</span>&nbsp;<span class="Y">y</span>, <span class="P">int</span>&nbsp;<span class="Y">cx</span>, <span class="P">int</span>&nbsp;<span class="Y">cy</span>, <span class="P">const</span>&nbsp;<a href="Image"><u>Image</u></a><span class="P">&amp;</span>&nbsp;<span class="Y">img</span>, <a href="Color"><u>Color</u></a>&nbsp;<span class="Y">color</span>)</p>
<p id="Draw::DrawImage(const Rect&,const Image&,const Rect&)" class="W"><span class="P">void</span>&nbsp;<span class="X">DrawImage</span>(<span class="P">const</span>&nbsp;<a href="Rect"><u>Rect</u></a><span class="P">&amp;</span>&nbsp;<span class="Y">r</span>, <span class="P">const</span>&nbsp;<a href="Image"><u>Image</u></a><span class="P">&amp;</span>&nbsp;<span class="Y">img</span>, <span class="P">const</span>&nbsp;<a href="Rect"><u>Rect</u></a><span class="P">&amp;</span>&nbsp;<span class="Y">src</span>)</p>
<p id="Draw::DrawImage(const Rect&,const Image&)" class="W"><span class="P">void</span>&nbsp;<span class="X">DrawImage</span>(<span class="P">const</span>&nbsp;<a href="Rect"><u>Rect</u></a><span class="P">&amp;</span>&nbsp;<span class="Y">r</span>, <span class="P">const</span>&nbsp;<a href="Image"><u>Image</u></a><span class="P">&amp;</span>&nbsp;<span class="Y">img</span>)</p>
<p id="Draw::DrawImage(const Rect&,const Image&,const Rect&,Color)" class="W"><span class="P">void</span>&nbsp;<span class="X">DrawImage</span>(<span class="P">const</span>&nbsp;<a href="Rect"><u>Rect</u></a><span class="P">&amp;</span>&nbsp;<span class="Y">r</span>, <span class="P">const</span>&nbsp;<a href="Image"><u>Image</u></a><span class="P">&amp;</span>&nbsp;<span class="Y">img</span>, <span class="P">const</span>&nbsp;<a href="Rect"><u>Rect</u></a><span class="P">&amp;</span>&nbsp;<span class="Y">src</span>, <a href="Color"><u>Color</u></a>&nbsp;<span class="Y">color</span>)</p>
<p id="Draw::DrawImage(const Rect&,const Image&,Color)" class="W"><span class="P">void</span>&nbsp;<span class="X">DrawImage</span>(<span class="P">const</span>&nbsp;<a href="Rect"><u>Rect</u></a><span class="P">&amp;</span>&nbsp;<span class="Y">r</span>, <span class="P">const</span>&nbsp;<a href="Image"><u>Image</u></a><span class="P">&amp;</span>&nbsp;<span class="Y">img</span>, <a href="Color"><u>Color</u></a>&nbsp;<span class="Y">color</span>)</p>
<p id="Draw::DrawImage(int,int,const Image&,const Rect&)" class="W"><span class="P">void</span>&nbsp;<span class="X">DrawImage</span>(<span class="P">int</span>&nbsp;<span class="Y">x</span>, <span class="P">int</span>&nbsp;<span class="Y">y</span>, <span class="P">const</span>&nbsp;<a href="Image"><u>Image</u></a><span class="P">&amp;</span>&nbsp;<span class="Y">img</span>, <span class="P">const</span>&nbsp;<a href="Rect"><u>Rect</u></a><span class="P">&amp;</span>&nbsp;<span class="Y">src</span>)</p>
<p id="Draw::DrawImage(int,int,const Image&)" class="W"><span class="P">void</span>&nbsp;<span class="X">DrawImage</span>(<span class="P">int</span>&nbsp;<span class="Y">x</span>, <span class="P">int</span>&nbsp;<span class="Y">y</span>, <span class="P">const</span>&nbsp;<a href="Image"><u>Image</u></a><span class="P">&amp;</span>&nbsp;<span class="Y">img</span>)</p>
<p id="Draw::DrawImage(int,int,const Image&,const Rect&,Color)" class="W"><span class="P">void</span>&nbsp;<span class="X">DrawImage</span>(<span class="P">int</span>&nbsp;<span class="Y">x</span>, <span class="P">int</span>&nbsp;<span class="Y">y</span>, <span class="P">const</span>&nbsp;<a href="Image"><u>Image</u></a><span class="P">&amp;</span>&nbsp;<span class="Y">img</span>, <span class="P">const</span>&nbsp;<a href="Rect"><u>Rect</u></a><span class="P">&amp;</span>&nbsp;<span class="Y">src</span>, <a href="Color"><u>Color</u></a>&nbsp;<span class="Y">color</span>)</p>
<p id="Draw::DrawImage(int,int,const Image&,Color)" class="W"><span class="P">void</span>&nbsp;<span class="X">DrawImage</span>(<span class="P">int</span>&nbsp;<span class="Y">x</span>, <span class="P">int</span>&nbsp;<span class="Y">y</span>, <span class="P">const</span>&nbsp;<a href="Image"><u>Image</u></a><span class="P">&amp;</span>&nbsp;<span class="Y">img</span>, <a href="Color"><u>Color</u></a>&nbsp;<span class="Y">color</span>)</p>
<p class="R">Paints <a href="Image">Image</a> <span class="Y">img</span>. If target rectangle is present (<span class="Y">r</span> or <span class="Y">x,y,cx,cy</span>), Image is rescaled (using high quality filter) to fit the area (banding can be used in the process to reduce memory requirements). If only target point <span class="Y">x</span>,<span class="Y">y</span> is provided, Image is not rescaled. If <span class="Y">src</span> rectangle is provided, only that portion of Image is used. If <span class="Y">color</span> is provided, only alpha information is used and the color information is replaced with it. Frontend to DrawImageOp.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Draw::DrawData(int,int,int,int,const String&,const char*)" class="W"><span class="P">void</span>&nbsp;<span class="X">DrawData</span>(<span class="P">int</span>&nbsp;<span class="Y">x</span>, <span class="P">int</span>&nbsp;<span class="Y">y</span>, <span class="P">int</span>&nbsp;<span class="Y">cx</span>, <span class="P">int</span>&nbsp;<span class="Y">cy</span>, <span class="P">const</span>&nbsp;<a href="String"><u>String</u></a><span class="P">&amp;</span>&nbsp;<span class="Y">data</span>, <span class="P">const</span>&nbsp;<span class="P">char</span>&nbsp;*<span class="Y">type</span>)</p>
<p id="Draw::DrawData(const Rect&,const String&,const char*)" class="W"><span class="P">void</span>&nbsp;<span class="X">DrawData</span>(<span class="P">const</span>&nbsp;<a href="Rect"><u>Rect</u></a><span class="P">&amp;</span>&nbsp;<span class="Y">r</span>, <span class="P">const</span>&nbsp;<a href="String"><u>String</u></a><span class="P">&amp;</span>&nbsp;<span class="Y">data</span>, <span class="P">const</span>&nbsp;<span class="P">char</span>&nbsp;*<span class="Y">type</span>)</p>
<p class="R">Draws arbitrary <span class="Y">data</span> of type <span class="Y">id</span> to rectangular area <span class="Y">r</span> or <span class="Y">x</span>,<span class="Y">y</span>,<span class="Y">cx</span>,<span class="Y">cy</span>. This can be used for example to print compressed bitmaps (e.g. in png format) directly, without the need of loading them to Image, this possibly saving memory requirements, as banding can be used to send the image to printer part by part. Actual painting process is implemented in <a href="DataDrawer">DataDrawer</a> and <span class="Y">id</span> has to be registered using DataDrawer::Register. Frontend to DrawDataOp.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Draw::DrawLine(int,int,int,int,int,Color)" class="W"><span class="P">void</span>&nbsp;<span class="X">DrawLine</span>(<span class="P">int</span>&nbsp;<span class="Y">x1</span>, <span class="P">int</span>&nbsp;<span class="Y">y1</span>, <span class="P">int</span>&nbsp;<span class="Y">x2</span>, <span class="P">int</span>&nbsp;<span class="Y">y2</span>, <span class="P">int</span>&nbsp;<span class="Y">width</span>&nbsp;=&nbsp;<span class="AC">0</span>, <a href="Color"><u>Color</u></a>&nbsp;<span class="Y">color</span>&nbsp;=&nbsp;DefaultInk)</p>
<p id="Draw::DrawLine(Point,Point,int,Color)" class="W"><span class="P">void</span>&nbsp;<span class="X">DrawLine</span>(<a href="Point"><u>Point</u></a>&nbsp;<span class="Y">p1</span>, <a href="Point"><u>Point</u></a>&nbsp;<span class="Y">p2</span>, <span class="P">int</span>&nbsp;<span class="Y">width</span>&nbsp;=&nbsp;<span class="AC">0</span>, <a href="Color"><u>Color</u></a>&nbsp;<span class="Y">color</span>&nbsp;=&nbsp;DefaultInk)</p>
<p class="R">Draws line from <span class="Y">x1</span>,<span class="Y">y1</span> or <span class="Y">p1</span> to <span class="Y">x2</span>,<span class="Y">y2</span> or <span class="Y">p2</span> (included) <span class="Y">width</span> pixels wide, with <span class="Y">color</span>. Width can contain special values, in that case line with width 1 is drawn and special dash pattern is applied - see DrawLineOp for details. Frontend to DrawLineOp.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Draw::DrawEllipse(const Rect&,Color,int,Color)" class="W"><span class="P">void</span>&nbsp;<span class="X">DrawEllipse</span>(<span class="P">const</span>&nbsp;<a href="Rect"><u>Rect</u></a><span class="P">&amp;</span>&nbsp;<span class="Y">r</span>, <a href="Color"><u>Color</u></a>&nbsp;<span class="Y">color</span>&nbsp;=&nbsp;DefaultInk, <span class="P">int</span>&nbsp;<span class="Y">pen</span>&nbsp;=&nbsp;Null, <a href="Color"><u>Color</u></a>&nbsp;<span class="Y">pencolor</span>&nbsp;=&nbsp;DefaultInk)</p>
<p id="Draw::DrawEllipse(int,int,int,int,Color,int,Color)" class="W"><span class="P">void</span>&nbsp;<span class="X">DrawEllipse</span>(<span class="P">int</span>&nbsp;<span class="Y">x</span>, <span class="P">int</span>&nbsp;<span class="Y">y</span>, <span class="P">int</span>&nbsp;<span class="Y">cx</span>, <span class="P">int</span>&nbsp;<span class="Y">cy</span>, <a href="Color"><u>Color</u></a>&nbsp;<span class="Y">color</span>&nbsp;=&nbsp;DefaultInk, <span class="P">int</span>&nbsp;<span class="Y">pen</span>&nbsp;=&nbsp;Null, <a href="Color"><u>Color</u></a>&nbsp;<span class="Y">pencolor</span>&nbsp;=&nbsp;DefaultInk)</p>
<p class="R">Draws the largest ellipse with both axes parallel to coordinate axes fully within rectangle <span class="Y">r</span> (<span class="Y">x</span>,<span class="Y">y</span>,<span class="Y">cx</span>,<span class="Y">cy</span>), i.e. with center point at r.CenterPoint(), semi major axis and semi minor axis equal to r.Width() / 2 and r.Height() / 2. If <span class="Y">pen</span> is not 0, Ellipse will be have border line of width <span class="Y">pen</span> and color <span class="Y">pencolor</span>. Frontend to DrawEllipseOp.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Draw::DrawArc(const Rect&,Point,Point,int,Color)" class="W"><span class="P">void</span>&nbsp;<span class="X">DrawArc</span>(<span class="P">const</span>&nbsp;<a href="Rect"><u>Rect</u></a><span class="P">&amp;</span>&nbsp;<span class="Y">rc</span>, <a href="Point"><u>Point</u></a>&nbsp;<span class="Y">start</span>, <a href="Point"><u>Point</u></a>&nbsp;<span class="Y">end</span>, <span class="P">int</span>&nbsp;<span class="Y">width</span>&nbsp;=&nbsp;<span class="AC">0</span>, <a href="Color"><u>Color</u></a>&nbsp;<span class="Y">color</span>&nbsp;=&nbsp;DefaultInk)</p>
<p class="R">Draws elliptic arc corresponding to the largest ellipse fully within the rectangle <span class="Y">rc</span> and running counterclockwise from the direction corresponding to the line connecting the centre of the ellipse (<span class="Y">rc</span>.CenterPoint()) with the point <span class="Y">start </span>and ending at direction of the point <span class="Y">end </span>from the ellipse centre. When start == end, the full ellipse is drawn. <span class="Y">width</span> is the width of line, painted in <span class="Y">color</span>. Frontend to DrawArcOp.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Draw::DrawPolyPolyline(const Point*,int,const int*,int,int,Color,Color)" class="W"><span class="P">void</span>&nbsp;<span class="X">DrawPolyPolyline</span>(<span class="P">const</span>&nbsp;<a href="Point"><u>Point</u></a>&nbsp;*<span class="Y">vertices</span>, <span class="P">int</span>&nbsp;<span class="Y">vertex_count</span>, <span class="P">const</span>&nbsp;<span class="P">int</span>&nbsp;*<span class="Y">counts</span>, <span class="P">int</span>&nbsp;<span class="Y">count_count</span>, <span class="P">int</span>&nbsp;<span class="Y">width</span>&nbsp;=&nbsp;<span class="AC">0</span>, <a href="Color"><u>Color</u></a>&nbsp;<span class="Y">color</span>&nbsp;=&nbsp;DefaultInk, <a href="Color"><u>Color</u></a>&nbsp;<span class="Y">doxor</span>&nbsp;=&nbsp;Null)</p>
<p id="Draw::DrawPolyPolyline(const Vector<Point>&,const Vector<int>&,int,Color,Color)" class="W"><span class="P">void</span>&nbsp;<span class="X">DrawPolyPolyline</span>(<span class="P">const</span>&nbsp;<a href="Vector"><u>Vector</u></a>&lt;<a href="Point"><u>Point</u></a>&gt;&amp;&nbsp;<span class="Y">vertices</span>, <span class="P">const</span>&nbsp;<a href="Vector"><u>Vector</u></a>&lt;<span class="P">int</span>&gt;&amp;&nbsp;<span class="Y">counts</span>, <span class="P">int</span>&nbsp;<span class="Y">width</span>&nbsp;=&nbsp;<span class="AC">0</span>, <a href="Color"><u>Color</u></a>&nbsp;<span class="Y">color</span>&nbsp;=&nbsp;DefaultInk, <a href="Color"><u>Color</u></a>&nbsp;<span class="Y">doxor</span>&nbsp;=&nbsp;Null)</p>
<p class="R">Draws multiple polylines (polygon without filling).</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Draw::DrawPolyline(const Point*,int,int,Color,Color)" class="W"><span class="P">void</span>&nbsp;<span class="X">DrawPolyline</span>(<span class="P">const</span>&nbsp;<a href="Point"><u>Point</u></a>&nbsp;*<span class="Y">vertices</span>, <span class="P">int</span>&nbsp;<span class="Y">count</span>, <span class="P">int</span>&nbsp;<span class="Y">width</span>&nbsp;=&nbsp;<span class="AC">0</span>, <a href="Color"><u>Color</u></a>&nbsp;<span class="Y">color</span>&nbsp;=&nbsp;DefaultInk, <a href="Color"><u>Color</u></a>&nbsp;<span class="Y">doxor</span>&nbsp;=&nbsp;Null)</p>
<p id="Draw::DrawPolyline(const Vector<Point>&,int,Color,Color)" class="W"><span class="P">void</span>&nbsp;<span class="X">DrawPolyline</span>(<span class="P">const</span>&nbsp;<a href="Vector"><u>Vector</u></a>&lt;<a href="Point"><u>Point</u></a>&gt;&amp;&nbsp;<span class="Y">vertices</span>, <span class="P">int</span>&nbsp;<span class="Y">width</span>&nbsp;=&nbsp;<span class="AC">0</span>, <a href="Color"><u>Color</u></a>&nbsp;<span class="Y">color</span>&nbsp;=&nbsp;DefaultInk, <a href="Color"><u>Color</u></a>&nbsp;<span class="Y">doxor</span>&nbsp;=&nbsp;Null)</p>
<p class="R">Draws a polyline (polygon without filling).</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Draw::DrawPolyPolyPolygon(const Point*,int,const int*,int,const int*,int,Color,int,Color,uint64,Color)" class="W"><span class="P">void</span>&nbsp;<span class="X">DrawPolyPolyPolygon</span>(<span class="P">const</span>&nbsp;<a href="Point"><u>Point</u></a>&nbsp;*<span class="Y">vertices</span>, <span class="P">int</span>&nbsp;<span class="Y">vertex_count</span>, <span class="P">const</span>&nbsp;<span class="P">int</span>&nbsp;*<span class="Y">subpolygon_counts</span>, <span class="P">int</span>&nbsp;<span class="Y">subpolygon_count_count</span>, <span class="P">const</span>&nbsp;<span class="P">int</span>&nbsp;*<span class="Y">disjunct_polygon_counts</span>, <span class="P">int</span>&nbsp;<span class="Y">disjunct_polygon_count_count</span>, <a href="Color"><u>Color</u></a>&nbsp;<span class="Y">color</span>&nbsp;=&nbsp;DefaultInk, <span class="P">int</span>&nbsp;<span class="Y">width</span>&nbsp;=&nbsp;<span class="AC">0</span>, <a href="Color"><u>Color</u></a>&nbsp;<span class="Y">outline</span>&nbsp;=&nbsp;Null, <a href="uint64"><u>uint64</u></a>&nbsp;<span class="Y">pattern</span>&nbsp;=&nbsp;<span class="AC">0</span>, <a href="Color"><u>Color</u></a>&nbsp;<span class="Y">doxor</span>&nbsp;=&nbsp;Null)</p>
<p id="Draw::DrawPolyPolyPolygon(const Vector<Point>&,const Vector<int>&,const Vector<int>&,Color,int,Color,uint64,Color)" class="W"><span class="P">void</span>&nbsp;<span class="X">DrawPolyPolyPolygon</span>(<span class="P">const</span>&nbsp;<a href="Vector"><u>Vector</u></a>&lt;<a href="Point"><u>Point</u></a>&gt;&amp;&nbsp;<span class="Y">vertices</span>, <span class="P">const</span>&nbsp;<a href="Vector"><u>Vector</u></a>&lt;<span class="P">int</span>&gt;&amp;&nbsp;<span class="Y">subpolygon_counts</span>, <span class="P">const</span>&nbsp;<a href="Vector"><u>Vector</u></a>&lt;<span class="P">int</span>&gt;&amp;&nbsp;<span class="Y">disjunct_polygon_counts</span>, <a href="Color"><u>Color</u></a>&nbsp;<span class="Y">color</span>&nbsp;=&nbsp;DefaultInk, <span class="P">int</span>&nbsp;<span class="Y">width</span>&nbsp;=&nbsp;<span class="AC">0</span>, <a href="Color"><u>Color</u></a>&nbsp;<span class="Y">outline</span>&nbsp;=&nbsp;Null, <a href="uint64"><u>uint64</u></a>&nbsp;<span class="Y">pattern</span>&nbsp;=&nbsp;<span class="AC">0</span>, <a href="Color"><u>Color</u></a>&nbsp;<span class="Y">doxor</span>&nbsp;=&nbsp;Null)</p>
<p class="R">Draws poly-poly-polygon.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Draw::DrawPolyPolygon(const Point*,int,const int*,int,Color,int,Color,uint64,Color)" class="W"><span class="P">void</span>&nbsp;<span class="X">DrawPolyPolygon</span>(<span class="P">const</span>&nbsp;<a href="Point"><u>Point</u></a>&nbsp;*<span class="Y">vertices</span>, <span class="P">int</span>&nbsp;<span class="Y">vertex_count</span>, <span class="P">const</span>&nbsp;<span class="P">int</span>&nbsp;*<span class="Y">subpolygon_counts</span>, <span class="P">int</span>&nbsp;<span class="Y">subpolygon_count_count</span>, <a href="Color"><u>Color</u></a>&nbsp;<span class="Y">color</span>&nbsp;=&nbsp;DefaultInk, <span class="P">int</span>&nbsp;<span class="Y">width</span>&nbsp;=&nbsp;<span class="AC">0</span>, <a href="Color"><u>Color</u></a>&nbsp;<span class="Y">outline</span>&nbsp;=&nbsp;Null, <a href="uint64"><u>uint64</u></a>&nbsp;<span class="Y">pattern</span>&nbsp;=&nbsp;<span class="AC">0</span>, <a href="Color"><u>Color</u></a>&nbsp;<span class="Y">doxor</span>&nbsp;=&nbsp;Null)</p>
<p id="Draw::DrawPolyPolygon(const Vector<Point>&,const Vector<int>&,Color,int,Color,uint64,Color)" class="W"><span class="P">void</span>&nbsp;<span class="X">DrawPolyPolygon</span>(<span class="P">const</span>&nbsp;<a href="Vector"><u>Vector</u></a>&lt;<a href="Point"><u>Point</u></a>&gt;&amp;&nbsp;<span class="Y">vertices</span>, <span class="P">const</span>&nbsp;<a href="Vector"><u>Vector</u></a>&lt;<span class="P">int</span>&gt;&amp;&nbsp;<span class="Y">subpolygon_counts</span>, <a href="Color"><u>Color</u></a>&nbsp;<span class="Y">color</span>&nbsp;=&nbsp;DefaultInk, <span class="P">int</span>&nbsp;<span class="Y">width</span>&nbsp;=&nbsp;<span class="AC">0</span>, <a href="Color"><u>Color</u></a>&nbsp;<span class="Y">outline</span>&nbsp;=&nbsp;Null, <a href="uint64"><u>uint64</u></a>&nbsp;<span class="Y">pattern</span>&nbsp;=&nbsp;<span class="AC">0</span>, <a href="Color"><u>Color</u></a>&nbsp;<span class="Y">doxor</span>&nbsp;=&nbsp;Null)</p>
<p class="R">Draws poly-polygon.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Draw::DrawPolygons(const Point*,int,const int*,int,Color,int,Color,uint64,Color)" class="W"><span class="P">void</span>&nbsp;<span class="X">DrawPolygons</span>(<span class="P">const</span>&nbsp;<a href="Point"><u>Point</u></a>&nbsp;*<span class="Y">vertices</span>, <span class="P">int</span>&nbsp;<span class="Y">vertex_count</span>, <span class="P">const</span>&nbsp;<span class="P">int</span>&nbsp;*<span class="Y">polygon_counts</span>, <span class="P">int</span>&nbsp;<span class="Y">polygon_count_count</span>, <a href="Color"><u>Color</u></a>&nbsp;<span class="Y">color</span>&nbsp;=&nbsp;DefaultInk, <span class="P">int</span>&nbsp;<span class="Y">width</span>&nbsp;=&nbsp;<span class="AC">0</span>, <a href="Color"><u>Color</u></a>&nbsp;<span class="Y">outline</span>&nbsp;=&nbsp;Null, <a href="uint64"><u>uint64</u></a>&nbsp;<span class="Y">pattern</span>&nbsp;=&nbsp;<span class="AC">0</span>, <a href="Color"><u>Color</u></a>&nbsp;<span class="Y">doxor</span>&nbsp;=&nbsp;Null)</p>
<p id="Draw::DrawPolygons(const Vector<Point>&,const Vector<int>&,Color,int,Color,uint64,Color)" class="W"><span class="P">void</span>&nbsp;<span class="X">DrawPolygons</span>(<span class="P">const</span>&nbsp;<a href="Vector"><u>Vector</u></a>&lt;<a href="Point"><u>Point</u></a>&gt;&amp;&nbsp;<span class="Y">vertices</span>, <span class="P">const</span>&nbsp;<a href="Vector"><u>Vector</u></a>&lt;<span class="P">int</span>&gt;&amp;&nbsp;<span class="Y">polygon_counts</span>, <a href="Color"><u>Color</u></a>&nbsp;<span class="Y">color</span>&nbsp;=&nbsp;DefaultInk, <span class="P">int</span>&nbsp;<span class="Y">width</span>&nbsp;=&nbsp;<span class="AC">0</span>, <a href="Color"><u>Color</u></a>&nbsp;<span class="Y">outline</span>&nbsp;=&nbsp;Null, <a href="uint64"><u>uint64</u></a>&nbsp;<span class="Y">pattern</span>&nbsp;=&nbsp;<span class="AC">0</span>, <a href="Color"><u>Color</u></a>&nbsp;<span class="Y">doxor</span>&nbsp;=&nbsp;Null)</p>
<p class="R">Draws multiple polygons.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Draw::DrawPolygon(const Point*,int,Color,int,Color,uint64,Color)" class="W"><span class="P">void</span>&nbsp;<span class="X">DrawPolygon</span>(<span class="P">const</span>&nbsp;<a href="Point"><u>Point</u></a>&nbsp;*<span class="Y">vertices</span>, <span class="P">int</span>&nbsp;<span class="Y">vertex_count</span>, <a href="Color"><u>Color</u></a>&nbsp;<span class="Y">color</span>&nbsp;=&nbsp;DefaultInk, <span class="P">int</span>&nbsp;<span class="Y">width</span>&nbsp;=&nbsp;<span class="AC">0</span>, <a href="Color"><u>Color</u></a>&nbsp;<span class="Y">outline</span>&nbsp;=&nbsp;Null, <a href="uint64"><u>uint64</u></a>&nbsp;<span class="Y">pattern</span>&nbsp;=&nbsp;<span class="AC">0</span>, <a href="Color"><u>Color</u></a>&nbsp;<span class="Y">doxor</span>&nbsp;=&nbsp;Null)</p>
<p id="Draw::DrawPolygon(const Vector<Point>&,Color,int,Color,uint64,Color)" class="W"><span class="P">void</span>&nbsp;<span class="X">DrawPolygon</span>(<span class="P">const</span>&nbsp;<a href="Vector"><u>Vector</u></a>&lt;<a href="Point"><u>Point</u></a>&gt;&amp;&nbsp;<span class="Y">vertices</span>, <a href="Color"><u>Color</u></a>&nbsp;<span class="Y">color</span>&nbsp;=&nbsp;DefaultInk, <span class="P">int</span>&nbsp;<span class="Y">width</span>&nbsp;=&nbsp;<span class="AC">0</span>, <a href="Color"><u>Color</u></a>&nbsp;<span class="Y">outline</span>&nbsp;=&nbsp;Null, <a href="uint64"><u>uint64</u></a>&nbsp;<span class="Y">pattern</span>&nbsp;=&nbsp;<span class="AC">0</span>, <a href="Color"><u>Color</u></a>&nbsp;<span class="Y">doxor</span>&nbsp;=&nbsp;Null)</p>
<p class="R">Draws a polygon.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Draw::DrawDrawing(const Rect&,const Drawing&)" class="W"><span class="P">void</span>&nbsp;<span class="X">DrawDrawing</span>(<span class="P">const</span>&nbsp;<a href="Rect"><u>Rect</u></a><span class="P">&amp;</span>&nbsp;<span class="Y">r</span>, <span class="P">const</span>&nbsp;<a href="Drawing"><u>Drawing</u></a><span class="P">&amp;</span>&nbsp;<span class="Y">iw</span>)</p>
<p id="Draw::DrawDrawing(int,int,int,int,const Drawing&)" class="W"><span class="P">void</span>&nbsp;<span class="X">DrawDrawing</span>(<span class="P">int</span>&nbsp;<span class="Y">x</span>, <span class="P">int</span>&nbsp;<span class="Y">y</span>, <span class="P">int</span>&nbsp;<span class="Y">cx</span>, <span class="P">int</span>&nbsp;<span class="Y">cy</span>, <span class="P">const</span>&nbsp;<a href="Drawing"><u>Drawing</u></a><span class="P">&amp;</span>&nbsp;<span class="Y">iw</span>)</p>
<p class="R">Draws <a href="Drawing">Drawing</a> <span class="Y">iw</span> scaled to rectangle <span class="Y">r</span> respectively <span class="Y">x</span>,<span class="Y">y</span>,<span class="Y">cx</span>,<span class="Y">cy</span>. Frontend to DrawDrawing op.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Draw::DrawDrawing(int,int,const Drawing&)" class="W"><span class="P">void</span>&nbsp;<span class="X">DrawDrawing</span>(<span class="P">int</span>&nbsp;<span class="Y">x</span>, <span class="P">int</span>&nbsp;<span class="Y">y</span>, <span class="P">const</span>&nbsp;<a href="Drawing"><u>Drawing</u></a><span class="P">&amp;</span>&nbsp;<span class="Y">iw</span>)</p>
<p class="R">Draws <a href="Drawing">Drawing</a> <span class="Y">iw</span> at <span class="Y">x</span>,<span class="Y">y</span>, using its original size. Frontend to DrawDrawing op.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Draw::DrawPainting(int,int,const Painting&)" class="W"><span class="P">void</span>&nbsp;<span class="X">DrawPainting</span>(<span class="P">const</span>&nbsp;<a href="Rect"><u>Rect</u></a><span class="P">&amp;</span>&nbsp;<span class="Y">r</span>, <span class="P">const</span>&nbsp;<a href="Painting"><u>Painting</u></a><span class="P">&amp;</span>&nbsp;<span class="Y">iw</span>)</p>
<p id="Draw::DrawPainting(int,int,int,int,const Painting&)" class="W"><span class="P">void</span>&nbsp;<span class="X">DrawPainting</span>(<span class="P">int</span>&nbsp;<span class="Y">x</span>, <span class="P">int</span>&nbsp;<span class="Y">y</span>, <span class="P">int</span>&nbsp;<span class="Y">cx</span>, <span class="P">int</span>&nbsp;<span class="Y">cy</span>, <span class="P">const</span>&nbsp;<a href="Painting"><u>Painting</u></a><span class="P">&amp;</span>&nbsp;<span class="Y">iw</span>)</p>
<p id="Draw::DrawPainting(int,int,const Painting&)" class="W"><span class="P">void</span>&nbsp;<span class="X">DrawPainting</span>(<span class="P">int</span>&nbsp;<span class="Y">x</span>, <span class="P">int</span>&nbsp;<span class="Y">y</span>, <span class="P">const</span>&nbsp;<a href="Painting"><u>Painting</u></a><span class="P">&amp;</span>&nbsp;<span class="Y">iw</span>)</p>
<p class="R">Draws <a href="Painting">Painting</a> <span class="Y">iw</span> scaled to rectangle <span class="Y">r</span> respectively <span class="Y">x</span>,<span class="Y">y</span>,<span class="Y">cx</span>,<span class="Y">cy</span>. Painter package has to be included in the project for this to work. Variant without <span class="Y">cx</span>,<span class="Y">cy</span> paints Painting in its original size. Frontend to DrawPaintingOp.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Draw::DrawText(int,int,int,const wchar*,Font,Color,int,const int*)" class="W"><span class="P">void</span>&nbsp;<span class="X">DrawText</span>(<span class="P">int</span>&nbsp;<span class="Y">x</span>, <span class="P">int</span>&nbsp;<span class="Y">y</span>, <span class="P">int</span>&nbsp;<span class="Y">angle</span>, <span class="P">const</span>&nbsp;<a href="wchar"><u>wchar</u></a>&nbsp;*<span class="Y">text</span>, <a href="Font"><u>Font</u></a>&nbsp;<span class="Y">font</span>&nbsp;=&nbsp;StdFont(), <a href="Color"><u>Color</u></a>&nbsp;<span class="Y">ink</span>&nbsp;=&nbsp;DefaultInk, <span class="P">int</span>&nbsp;<span class="Y">n</span>&nbsp;=&nbsp;-<span class="AC">1</span>, <span class="P">const</span>&nbsp;<span class="P">int</span>&nbsp;*<span class="Y">dx</span>&nbsp;=&nbsp;NULL)</p>
<p id="Draw::DrawText(int,int,const wchar*,Font,Color,int,const int*)" class="W"><span class="P">void</span>&nbsp;<span class="X">DrawText</span>(<span class="P">int</span>&nbsp;<span class="Y">x</span>, <span class="P">int</span>&nbsp;<span class="Y">y</span>, <span class="P">const</span>&nbsp;<a href="wchar"><u>wchar</u></a>&nbsp;*<span class="Y">text</span>, <a href="Font"><u>Font</u></a>&nbsp;<span class="Y">font</span>&nbsp;=&nbsp;StdFont(), <a href="Color"><u>Color</u></a>&nbsp;<span class="Y">ink</span>&nbsp;=&nbsp;DefaultInk, <span class="P">int</span>&nbsp;<span class="Y">n</span>&nbsp;=&nbsp;-<span class="AC">1</span>, <span class="P">const</span>&nbsp;<span class="P">int</span>&nbsp;*<span class="Y">dx</span>&nbsp;=&nbsp;NULL)</p>
<p id="Draw::DrawText(int,int,const WString&,Font,Color,const int*)" class="W"><span class="P">void</span>&nbsp;<span class="X">DrawText</span>(<span class="P">int</span>&nbsp;<span class="Y">x</span>, <span class="P">int</span>&nbsp;<span class="Y">y</span>, <span class="P">const</span>&nbsp;<a href="WString"><u>WString</u></a><span class="P">&amp;</span>&nbsp;<span class="Y">text</span>, <a href="Font"><u>Font</u></a>&nbsp;<span class="Y">font</span>&nbsp;=&nbsp;StdFont(), <a href="Color"><u>Color</u></a>&nbsp;<span class="Y">ink</span>&nbsp;=&nbsp;DefaultInk, <span class="P">const</span>&nbsp;<span class="P">int</span>&nbsp;*<span class="Y">dx</span>&nbsp;=&nbsp;NULL)</p>
<p id="Draw::DrawText(int,int,int,const WString&,Font,Color,const int*)" class="W"><span class="P">void</span>&nbsp;<span class="X">DrawText</span>(<span class="P">int</span>&nbsp;<span class="Y">x</span>, <span class="P">int</span>&nbsp;<span class="Y">y</span>, <span class="P">int</span>&nbsp;<span class="Y">angle</span>, <span class="P">const</span>&nbsp;<a href="WString"><u>WString</u></a><span class="P">&amp;</span>&nbsp;<span class="Y">text</span>, <a href="Font"><u>Font</u></a>&nbsp;<span class="Y">font</span>&nbsp;=&nbsp;StdFont(), <a href="Color"><u>Color</u></a>&nbsp;<span class="Y">ink</span>&nbsp;=&nbsp;DefaultInk, <span class="P">const</span>&nbsp;<span class="P">int</span>&nbsp;*<span class="Y">dx</span>&nbsp;=&nbsp;NULL)</p>
<p id="Draw::DrawText(int,int,int,const char*,byte,Font,Color,int,const int*)" class="W"><span class="P">void</span>&nbsp;<span class="X">DrawText</span>(<span class="P">int</span>&nbsp;<span class="Y">x</span>, <span class="P">int</span>&nbsp;<span class="Y">y</span>, <span class="P">int</span>&nbsp;<span class="Y">angle</span>, <span class="P">const</span>&nbsp;<span class="P">char</span>&nbsp;*<span class="Y">text</span>, <a href="byte"><u>byte</u></a>&nbsp;<span class="Y">charset</span>, <a href="Font"><u>Font</u></a>&nbsp;<span class="Y">font</span>&nbsp;=&nbsp;StdFont(), <a href="Color"><u>Color</u></a>&nbsp;<span class="Y">ink</span>&nbsp;=&nbsp;DefaultInk, <span class="P">int</span>&nbsp;<span class="Y">n</span>&nbsp;=&nbsp;-<span class="AC">1</span>, <span class="P">const</span>&nbsp;<span class="P">int</span>&nbsp;*<span class="Y">dx</span>&nbsp;=&nbsp;NULL)</p>
<p id="Draw::DrawText(int,int,const char*,byte,Font,Color,int,const int*)" class="W"><span class="P">void</span>&nbsp;<span class="X">DrawText</span>(<span class="P">int</span>&nbsp;<span class="Y">x</span>, <span class="P">int</span>&nbsp;<span class="Y">y</span>, <span class="P">const</span>&nbsp;<span class="P">char</span>&nbsp;*<span class="Y">text</span>, <a href="byte"><u>byte</u></a>&nbsp;<span class="Y">charset</span>, <a href="Font"><u>Font</u></a>&nbsp;<span class="Y">font</span>&nbsp;=&nbsp;StdFont(), <a href="Color"><u>Color</u></a>&nbsp;<span class="Y">ink</span>&nbsp;=&nbsp;DefaultInk, <span class="P">int</span>&nbsp;<span class="Y">n</span>&nbsp;=&nbsp;-<span class="AC">1</span>, <span class="P">const</span>&nbsp;<span class="P">int</span>&nbsp;*<span class="Y">dx</span>&nbsp;=&nbsp;NULL)</p>
<p id="Draw::DrawText(int,int,int,const char*,Font,Color,int,const int*)" class="W"><span class="P">void</span>&nbsp;<span class="X">DrawText</span>(<span class="P">int</span>&nbsp;<span class="Y">x</span>, <span class="P">int</span>&nbsp;<span class="Y">y</span>, <span class="P">int</span>&nbsp;<span class="Y">angle</span>, <span class="P">const</span>&nbsp;<span class="P">char</span>&nbsp;*<span class="Y">text</span>, <a href="Font"><u>Font</u></a>&nbsp;<span class="Y">font</span>&nbsp;=&nbsp;StdFont(), <a href="Color"><u>Color</u></a>&nbsp;<span class="Y">ink</span>&nbsp;=&nbsp;DefaultInk, <span class="P">int</span>&nbsp;<span class="Y">n</span>&nbsp;=&nbsp;-<span class="AC">1</span>, <span class="P">const</span>&nbsp;<span class="P">int</span>&nbsp;*<span class="Y">dx</span>&nbsp;=&nbsp;NULL)</p>
<p id="Draw::DrawText(int,int,const char*,Font,Color,int,const int*)" class="W"><span class="P">void</span>&nbsp;<span class="X">DrawText</span>(<span class="P">int</span>&nbsp;<span class="Y">x</span>, <span class="P">int</span>&nbsp;<span class="Y">y</span>, <span class="P">const</span>&nbsp;<span class="P">char</span>&nbsp;*<span class="Y">text</span>, <a href="Font"><u>Font</u></a>&nbsp;<span class="Y">font</span>&nbsp;=&nbsp;StdFont(), <a href="Color"><u>Color</u></a>&nbsp;<span class="Y">ink</span>&nbsp;=&nbsp;DefaultInk, <span class="P">int</span>&nbsp;<span class="Y">n</span>&nbsp;=&nbsp;-<span class="AC">1</span>, <span class="P">const</span>&nbsp;<span class="P">int</span>&nbsp;*<span class="Y">dx</span>&nbsp;=&nbsp;NULL)</p>
<p id="Draw::DrawText(int,int,const String&,Font,Color,const int*)" class="W"><span class="P">void</span>&nbsp;<span class="X">DrawText</span>(<span class="P">int</span>&nbsp;<span class="Y">x</span>, <span class="P">int</span>&nbsp;<span class="Y">y</span>, <span class="P">const</span>&nbsp;<a href="String"><u>String</u></a><span class="P">&amp;</span>&nbsp;<span class="Y">text</span>, <a href="Font"><u>Font</u></a>&nbsp;<span class="Y">font</span>&nbsp;=&nbsp;StdFont(), <a href="Color"><u>Color</u></a>&nbsp;<span class="Y">ink</span>&nbsp;=&nbsp;DefaultInk, <span class="P">const</span>&nbsp;<span class="P">int</span>&nbsp;*<span class="Y">dx</span>&nbsp;=&nbsp;NULL)</p>
<p id="Draw::DrawText(int,int,int,const String&,Font,Color,const int*)" class="W"><span class="P">void</span>&nbsp;<span class="X">DrawText</span>(<span class="P">int</span>&nbsp;<span class="Y">x</span>, <span class="P">int</span>&nbsp;<span class="Y">y</span>, <span class="P">int</span>&nbsp;<span class="Y">angle</span>, <span class="P">const</span>&nbsp;<a href="String"><u>String</u></a><span class="P">&amp;</span>&nbsp;<span class="Y">text</span>, <a href="Font"><u>Font</u></a>&nbsp;<span class="Y">font</span>&nbsp;=&nbsp;StdFont(), <a href="Color"><u>Color</u></a>&nbsp;<span class="Y">ink</span>&nbsp;=&nbsp;DefaultInk, <span class="P">const</span>&nbsp;<span class="P">int</span>&nbsp;*<span class="Y">dx</span>&nbsp;=&nbsp;NULL)</p>
<p class="R">Draws a <span class="Y">text </span>at position starting at <span class="Y">x</span>,<span class="Y">y</span> (it represents top-left corner of text cell: for horizontal text, x identifies reference point and y is ascent above the baseline) going at <span class="Y">angle</span> using <span class="Y">font</span> and color <span class="Y">ink</span>. <span class="Y">n</span> is a number of characters to paint, if negative, it is retrieved using [w]strlen. If <span class="Y">dx </span>is not NULL, it specifies advancements of individual characters (it must be <span class="Y">n</span> elements in this array), otherwise advancements from font metrics are used. For 8-bit texts (<span class="Y">text</span> is <a href="String">String</a> or <span class="P">const char *</span>), if <span class="Y">charset</span> is present, text is converted from this charset before printing, if no <span class="Y">charset</span> is specified, default charset is used. DrawText also performs missing glyph replacement and composition. If Draw::GetInfo() returns DRAWTEXTLINES, DrawText uses DrawLine to provide support for Undeline and Strikeout Font styles. DrawText calls DrawTextOp for low-level glyph rendering.</p>
<p class="F">&nbsp;</p>
<hr><p class="F">&nbsp;</p>
<p id="Draw::SinCos(int,double&,double&)" class="W"><span class="P">static</span> <span class="P">void</span>&nbsp;<span class="X">SinCos</span>(<span class="P">int</span>&nbsp;<span class="Y">angle</span>, <span class="P">double&amp;</span>&nbsp;<span class="Y">sina</span>, <span class="P">double&amp;</span>&nbsp;<span class="Y">cosa</span>)</p>
<p class="R">This simple utility function computes sin(angle) and cos(angle), where the full angle (2π) is 3600.</p>
<p class="F">&nbsp;</p>
<p class="A">&nbsp;</p>
</TD>
</TR>
</TABLE>
</TD>
</TR>
</TABLE>
<TABLE BORDER="0" WIDTH="100%"><TR><TD></TD>
</TR>
</TABLE>
<TABLE BORDER="0" CELLSPACING="0" CELLPADDING="0" BGCOLOR="#FFFFFF" WIDTH="100%" style="border-style: solid; border-width: 1px; border-color: #6E89AE;padding: 10px;;"><TR><TD><TABLE BORDER="0" CELLSPACING="0" CELLPADDING="0" WIDTH="100%"><TR><TD><p class="A"><span class="B"> </span><a href="www$uppweb$contribweb$en-us.html">Do you want to contribute?</a></p>
</TD>
</TR>
</TABLE>
</TD>
</TR>
</TABLE>
</TD>
</TR>
</TABLE>
<script type="text/javascript">var a={};var p=window.location.pathname.split("/");p=p[p.length-1];var s='<select id="lang" onchange="window.location=document.getElementById(\'lang\').value;">';for(l in a){if(p==l){d=" selected=1"}else{d=""}s+='<option value="'+l+'"'+d+'>'+a[l]+'</option>'}s+='</select>';var d=document.createElement('div');d.innerHTML=s;var c=document.getElementById('langs');c.replaceChild(d,c.firstChild);document.getElementById('langbox').style.display='block';</script></BODY>
