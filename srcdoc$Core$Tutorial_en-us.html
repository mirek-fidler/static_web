<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML lang="en-us">
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="Generator" CONTENT="U++ HTML Package">
<META NAME="Description" CONTENT="Logging is a useful technique to trace the flow of the code and examine results.">
<TITLE>U++ Core Tutorial :: U++</TITLE>
<STYLE TYPE="text/css"><!--
.A{margin:0px 0px 0px 0px;text-indent:0px;text-align:left;color:#000000;font-family:sans-serif;font-size:10pt;font-weight:normal;font-style:normal;}
.B{font-size:12pt;}
.C{margin:0px 0px 16px 0px;text-indent:0px;text-align:left;color:#000000;font-family:serif;font-size:24pt;font-weight:bold;font-style:normal;}
.D{margin:14px 0px 0px 0px;text-indent:0px;text-align:left;color:#000000;font-family:sans-serif;font-size:18pt;font-weight:bold;font-style:normal;}
.E{margin:16px 0px 0px 0px;text-indent:0px;text-align:left;color:#000000;font-family:sans-serif;font-size:16pt;font-weight:bold;font-style:normal;}
.F{margin:8px 0px 8px 0px;text-indent:0px;text-align:left;color:#000000;font-family:sans-serif;font-size:10pt;font-weight:normal;font-style:normal;line-height:150%}
.G{color:#000080;font-family:monospace;font-weight:bold;}
.H{margin:0px 0px 0px 64px;text-indent:0px;text-align:left;color:#000080;font-family:monospace;font-size:8pt;font-weight:normal;font-style:normal;}
.I{margin:0px 0px 0px 64px;text-indent:0px;text-align:left;color:#000000;font-family:monospace;font-size:10pt;font-weight:bold;font-style:normal;background-color:#e0e0e0;}
.J{margin:8px 0px 8px 0px;text-indent:0px;text-align:left;color:#000080;font-family:monospace;font-size:10pt;font-weight:bold;font-style:normal;line-height:150%}
.K{color:#000000;font-family:sans-serif;font-weight:normal;}
.L{margin:16px 0px 0px 0px;text-indent:0px;text-align:left;color:#000080;font-family:monospace;font-size:16pt;font-weight:bold;font-style:normal;}
.M{color:#000000;font-family:sans-serif;}
.N{color:#000080;font-family:monospace;}
.O{font-style:italic;}
a.l1         { text-decoration:none; font-size: 8pt; font-family: sans-serif; font-weight: normal; }
a.l1:link    { color:#000000; }
a.l1:visited { color:#000080; }
a.l1:hover   { color:#9933CC; }
a.l1:active  { color:#000000; }
a.l2         { text-decoration:none; font-size: 12pt; font-family: sans-serif; font-variant: small-caps; }
a.l2:link    { color:#0066FF; }
a.l2:visited { color:#FF6600; }
a.l2:hover   { color:#BC0624; }
a.l2:active  { color:#BC0024; }

-->
</STYLE>
<META NAME="keywords" CONTENT="framework, toolkit, widget, c++, visual, studio, dev-cpp, builder, ide, class, component,wxwidgets, qt, rapid, application, development, rad, mfc, linux, macos, gui, sdl, directx, desktop"><META name="robots" content="index,follow">
<LINK rel="alternate" type="application/rss+xml" title="SVN changes" href="svnchanges.xml">
<LINK rel="shortcut icon" type="image/png" href="favicon.png">
</HEAD><BODY BGCOLOR="#D2D9D2" ALINK="#800000" LINK="#000000" VLINK="#000080"><TABLE BORDER="0" CELLSPACING="0" CELLPADDING="0" WIDTH="100%"><TR><TD COLSPAN="3"><TABLE BORDER="0" CELLSPACING="0" CELLPADDING="0" WIDTH="100%" BGCOLOR="#FFFFFF" style="border: 1px solid #6E89AE;padding-left: 10px;padding-right: 0px;padding-top: 0px;padding-bottom: 0px;"><TR><TD><A HREF="index.html"><IMG SRC="0i.png" ALT="" BORDER="0"></A>
</TD>
<TD ALIGN="RIGHT" VALIGN="BOTTOM" STYLE="padding-bottom: 5px; background-image: url('1i.png')"><span style="font-size: 14pt; font-family: sans-serif;"><script type="text/javascript"><!--
google_ad_client = "pub-1082147624384270";
google_ad_width = 468;
google_ad_height = 60;
google_ad_format = "468x60_as";
google_ad_type = "text_image";
google_ad_channel = "";
google_color_border = "336699";
google_color_bg = "FFFFFF";
google_color_link = "0000FF";
google_color_text = "000000";
google_color_url = "008000";
//--></script>
<script type="text/javascript"
  src="https://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
&nbsp;&nbsp;</span>
</TD>
</TR>
</TABLE>
</TD>
</TR>
</TABLE>
<TABLE BORDER="0" CELLSPACING="0" CELLPADDING="0" WIDTH="100%"><TR><TD COLSPAN="3" BGCOLOR="#D2D9D2" HEIGHT="6"></TD>
</TR>
<TR><TD VALIGN="TOP" ALIGN="CENTER"><TABLE BORDER="0" CELLSPACING="0" CELLPADDING="0" WIDTH="160"><TR><TD ALIGN="CENTER"><TABLE BORDER="0" CELLSPACING="0" CELLPADDING="0" WIDTH="100%" BGCOLOR="#FFFFFF" style="border-style: solid; border-width: 1px; border-color: #6E89AE;padding: 0px"><TR><TD WIDTH="100%" VALIGN="MIDDLE" STYLE="background-image: url('2i.png'); border: 0px solid black; padding-left:12px; padding-right:0px; padding-top:6px; padding-bottom:6px;"><A HREF="www$uppweb$overview$en-us.html" CLASS="l1">Overview</A>
</TD>
</TR>
<TR><TD WIDTH="100%" VALIGN="MIDDLE" STYLE="background-image: url('2i.png'); border: 0px solid black; padding-left:12px; padding-right:0px; padding-top:6px; padding-bottom:6px; border-top: 1px solid #6E89AE;"><A HREF="www$uppweb$examples$en-us.html" CLASS="l1">Examples</A>
</TD>
</TR>
<TR><TD WIDTH="100%" VALIGN="MIDDLE" STYLE="background-image: url('2i.png'); border: 0px solid black; padding-left:12px; padding-right:0px; padding-top:6px; padding-bottom:6px; border-top: 1px solid #6E89AE;"><A HREF="www$uppweb$ss$en-us.html" CLASS="l1">Screenshots</A>
</TD>
</TR>
<TR><TD WIDTH="100%" VALIGN="MIDDLE" STYLE="background-image: url('2i.png'); border: 0px solid black; padding-left:12px; padding-right:0px; padding-top:6px; padding-bottom:6px; border-top: 1px solid #6E89AE;"><A HREF="www$uppweb$comparison$en-us.html" CLASS="l1">Comparisons</A>
</TD>
</TR>
<TR><TD WIDTH="100%" VALIGN="MIDDLE" STYLE="background-image: url('2i.png'); border: 0px solid black; padding-left:12px; padding-right:0px; padding-top:6px; padding-bottom:6px; border-top: 1px solid #6E89AE;"><A HREF="www$uppweb$apps$en-us.html" CLASS="l1">Applications</A>
</TD>
</TR>
<TR><TD WIDTH="100%" VALIGN="MIDDLE" STYLE="background-image: url('2i.png'); border: 0px solid black; padding-left:12px; padding-right:0px; padding-top:6px; padding-bottom:6px; border-top: 1px solid #6E89AE;"><A HREF="www$uppweb$download$en-us.html" CLASS="l1">Download</A>
</TD>
</TR>
<TR><TD WIDTH="100%" VALIGN="MIDDLE" STYLE="background-image: url('2i.png'); border: 0px solid black; padding-left:12px; padding-right:0px; padding-top:6px; padding-bottom:6px; border-top: 1px solid #6E89AE;"><A HREF="www$uppweb$documentation$en-us.html" CLASS="l1">Documentation</A>
</TD>
</TR>
<TR><TD WIDTH="100%" VALIGN="MIDDLE" STYLE="background-image: url('2i.png'); border: 0px solid black; padding-left:12px; padding-right:0px; padding-top:6px; padding-bottom:6px; border-top: 1px solid #6E89AE;"><A HREF="www$uppweb$Tutorials$en-us.html" CLASS="l1">Tutorials</A>
</TD>
</TR>
<TR><TD WIDTH="100%" VALIGN="MIDDLE" STYLE="background-image: url('2i.png'); border: 0px solid black; padding-left:12px; padding-right:0px; padding-top:6px; padding-bottom:6px; border-top: 1px solid #6E89AE;"><A HREF="app$ide$UppHub$en-us.html" CLASS="l1">UppHub</A>
</TD>
</TR>
<TR><TD WIDTH="100%" VALIGN="MIDDLE" STYLE="background-image: url('2i.png'); border: 0px solid black; padding-left:12px; padding-right:0px; padding-top:6px; padding-bottom:6px; border-top: 1px solid #6E89AE;"><A HREF="www$uppweb$Roadmap$en-us.html" CLASS="l1">Status & Roadmap</A>
</TD>
</TR>
<TR><TD WIDTH="100%" VALIGN="MIDDLE" STYLE="background-image: url('2i.png'); border: 0px solid black; padding-left:12px; padding-right:0px; padding-top:6px; padding-bottom:6px; border-top: 1px solid #6E89AE;"><A HREF="www$uppweb$FAQ$en-us.html" CLASS="l1">FAQ</A>
</TD>
</TR>
<TR><TD WIDTH="100%" VALIGN="MIDDLE" STYLE="background-image: url('2i.png'); border: 0px solid black; padding-left:12px; padding-right:0px; padding-top:6px; padding-bottom:6px; border-top: 1px solid #6E89AE;"><A HREF="app$ide$About$en-us.html" CLASS="l1">Authors & License</A>
</TD>
</TR>
<TR><TD WIDTH="100%" VALIGN="MIDDLE" STYLE="background-image: url('2i.png'); border: 0px solid black; padding-left:12px; padding-right:0px; padding-top:6px; padding-bottom:6px; border-top: 1px solid #6E89AE;"><A HREF="https://www.ultimatepp.org/forums" CLASS="l1">Forums</A>
</TD>
</TR>
<TR><TD WIDTH="100%" VALIGN="MIDDLE" STYLE="background-image: url('2i.png'); border: 0px solid black; padding-left:12px; padding-right:0px; padding-top:6px; padding-bottom:6px; border-top: 1px solid #6E89AE;"><A HREF="www$uppweb$Funding$en-us.html" CLASS="l1">Funding U++</A>
</TD>
</TR>
</TABLE>
<TABLE BORDER="0" WIDTH="100%"><TR><TD></TD>
</TR>
</TABLE>
<TABLE BORDER="0" CELLSPACING="0" CELLPADDING="0" WIDTH="100%" BGCOLOR="#FFFFFF" style="border-style: solid; border-width: 1px; border-color: #6E89AE;padding: 0px"><TR><TD WIDTH="100%" VALIGN="MIDDLE" STYLE="background-image: url('3i.png'); border: 0px solid black;padding-left:12px; padding-right:0px; padding-top:1px; padding-bottom:1px;color:#FFFFFF;"><B><span style="font-size: 8pt; font-family: sans-serif;">Search on this site</span>
</B>
</TD>
</TR>
<TR><TD WIDTH="100%" VALIGN="MIDDLE" STYLE="background-image: url('2i.png'); border: 0px solid black; padding-left:6px; padding-right:0px; padding-top:4px; padding-bottom:4px;border-top: 1px solid #6E89AE;"><TABLE BORDER="0" CELLSPACING="0" CELLPADDING="0" WIDTH="100%"><TR><TD><IMG SRC="4i.png" ALT="" BORDER="0"></TD>
<TD><FORM ACTION="https://www.google.com/search" METHOD="GET" STYLE="margin:0px;padding:0px;"><INPUT TYPE="HIDDEN" NAME="ie" VALUE="UTF-8"><INPUT TYPE="HIDDEN" NAME="oe" VALUE="UTF-8"><INPUT TYPE="TEXT" NAME="q" SIZE="15" MAXLENGTH="256" placeholder="Site search"><INPUT TYPE="HIDDEN" NAME="sitesearch" VALUE="ultimatepp.org"></FORM>
</TD>
</TR>
</TABLE>
</TD>
</TR>
</TABLE>
<TABLE BORDER="0" WIDTH="100%"><TR><TD></TD>
</TR>
</TABLE>
<br><div id="fb-root"></div>
<script type="text/javascript">(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) {return;}
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/en_US/all.js#xfbml=1";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>

<div class="fb-like" data-href="https://www.facebook.com/pages/Upp-Framework/262346610476027?sk=wall" data-send="false" data-layout="button_count" data-width="160" data-show-faces="false" data-font="arial"></div>
<br><br><script type="text/javascript"><!--
google_ad_client = "pub-1082147624384270";
google_ad_width = 160;
google_ad_height = 600;
google_ad_format = "160x600_as";
google_ad_type = "text_image";
google_ad_channel = "";
google_color_border = "336699";
google_color_bg = "FFFFFF";
google_color_link = "0000FF";
google_color_text = "000000";
google_color_url = "008000";
//--></script>
<script type="text/javascript"
  src="https://pagead2.googlesyndication.com/pagead/show_ads.js">
</script><br><br><script type="text/javascript"><!--
google_ad_client = "pub-1082147624384270";
google_ad_width = 160;
google_ad_height = 90;
google_ad_format = "160x90_0ads_al_s";
google_ad_channel = "";
google_color_border = "336699";
google_color_bg = "FFFFFF";
google_color_link = "0000FF";
google_color_text = "000000";
google_color_url = "008000";
//--></script>
<script type="text/javascript"
  src="https://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
<br><br><script type="text/javascript"><!--
google_ad_client = "pub-1082147624384270";
google_ad_width = 160;
google_ad_height = 600;
google_ad_format = "160x600_as";
google_ad_type = "text_image";
google_ad_channel = "";
google_color_border = "336699";
google_color_bg = "FFFFFF";
google_color_link = "0000FF";
google_color_text = "000000";
google_color_url = "008000";
//--></script>
<script type="text/javascript"
  src="https://pagead2.googlesyndication.com/pagead/show_ads.js">
</script><br><br><br><br><br><br><A HREF="https://sourceforge.net/projects/upp/"><IMG SRC="https://sourceforge.net/sflogo.php?group_id=93970&amp;type=2" ALT="SourceForge.net Logo" BORDER="0" WIDTH="125" HEIGHT="37"></A>
<br><br><A HREF="https://flathub.org/en/apps/org.ultimatepp.TheIDE"><IMG SRC="5i.png" ALT="SourceForge.net Logo" BORDER="0" WIDTH="125" HEIGHT="37"></A>
<br><br><div style="background-color:#ffffff;width:125;height:35"><A HREF="https://github.com/ultimatepp"><IMG SRC="6i.png" ALT="GitHub Logo" BORDER="0" WIDTH="125" HEIGHT="35"></A>
</div><br><div style="background-color:#ffffff;width:125;height:35"><div style="height:5"></div><A HREF="https://discord.gg/8XzqQzXZzb"><IMG SRC="https://assets-global.website-files.com/6257adef93867e50d84d30e2/636e0b5061df29d55a92d945_full_logo_blurple_RGB.svg" ALT="Discord Logo" BORDER="0" WIDTH="125" HEIGHT="25"></A>
</div><br></TD>
</TR>
</TABLE>
</TD>
<TD VALIGN="TOP" BGCOLOR="#D2D9D2"><TABLE BORDER="0" CELLSPACING="0" CELLPADDING="0" WIDTH="6"><TR><TD></TD>
</TR>
</TABLE>
</TD>
<TD VALIGN="TOP" WIDTH="100%" BGCOLOR="#D2D9D2"><TABLE BORDER="0" CELLSPACING="0" CELLPADDING="0" BGCOLOR="#FFFFFF" WIDTH="100%" style="border-style: solid; border-width: 1px; border-color: #6E89AE;padding: 10px;;"><TR><TD><TABLE BORDER="0" CELLSPACING="0" CELLPADDING="0" WIDTH="100%"><TR><TD><p class="C">U++ Core Tutorial</p>
<hr><p class="D">Table of contents</p>
<p class="A">&nbsp;</p>
<p class="A"><a href="#Chapter_1">1. Basics</a></p>
<p class="A">&nbsp;&nbsp;&nbsp;<a href="#Section_1_1">1.1 Logging</a></p>
<p class="A">&nbsp;&nbsp;&nbsp;<a href="#Section_1_2">1.2 String</a></p>
<p class="A">&nbsp;&nbsp;&nbsp;<a href="#Section_1_3">1.3 StringBuffer</a></p>
<p class="A">&nbsp;&nbsp;&nbsp;<a href="#Section_1_4">1.4 WString</a></p>
<p class="A">&nbsp;&nbsp;&nbsp;<a href="#Section_1_5">1.5 Date and Time</a></p>
<p class="A">&nbsp;&nbsp;&nbsp;<a href="#Section_1_6">1.6 AsString, ToString and operator&lt;&lt;</a></p>
<p class="A">&nbsp;&nbsp;&nbsp;<a href="#Section_1_7">1.7 CombineHash</a></p>
<p class="A">&nbsp;&nbsp;&nbsp;<a href="#Section_1_8">1.8 SgnCompare and CombineCompare</a></p>
<p class="A">&nbsp;</p>
<p class="A"><a href="#Chapter_2">2. Streams</a></p>
<p class="A">&nbsp;&nbsp;&nbsp;<a href="#Section_2_1">2.1 Streams basics</a></p>
<p class="A">&nbsp;&nbsp;&nbsp;<a href="#Section_2_2">2.2 Special streams</a></p>
<p class="A">&nbsp;&nbsp;&nbsp;<a href="#Section_2_3">2.3 Binary serialization</a></p>
<p class="A">&nbsp;</p>
<p class="A"><a href="#Chapter_3">3. Array containers</a></p>
<p class="A">&nbsp;&nbsp;&nbsp;<a href="#Section_3_1">3.1 Vector basics</a></p>
<p class="A">&nbsp;&nbsp;&nbsp;<a href="#Section_3_2">3.2 Vector operations</a></p>
<p class="A">&nbsp;&nbsp;&nbsp;<a href="#Section_3_3">3.3 Transfer issues</a></p>
<p class="A">&nbsp;&nbsp;&nbsp;<a href="#Section_3_4">3.4 Client types in U++ containers</a></p>
<p class="A">&nbsp;&nbsp;&nbsp;<a href="#Section_3_5">3.5 Array flavor</a></p>
<p class="A">&nbsp;&nbsp;&nbsp;<a href="#Section_3_6">3.6 Polymorphic Array</a></p>
<p class="A">&nbsp;&nbsp;&nbsp;<a href="#Section_3_7">3.7 Bidirectional containers</a></p>
<p class="A">&nbsp;&nbsp;&nbsp;<a href="#Section_3_8">3.8 Index</a></p>
<p class="A">&nbsp;&nbsp;&nbsp;<a href="#Section_3_9">3.9 Index and client types</a></p>
<p class="A">&nbsp;&nbsp;&nbsp;<a href="#Section_3_10">3.10 VectorMap, ArrayMap</a></p>
<p class="A">&nbsp;&nbsp;&nbsp;<a href="#Section_3_11">3.11 One</a></p>
<p class="A">&nbsp;&nbsp;&nbsp;<a href="#Section_3_12">3.12 Any</a></p>
<p class="A">&nbsp;&nbsp;&nbsp;<a href="#Section_3_13">3.13 InVector, InArray</a></p>
<p class="A">&nbsp;&nbsp;&nbsp;<a href="#Section_3_14">3.14 SortedIndex, SortedVectorMap, SortedArrayMap</a></p>
<p class="A">&nbsp;&nbsp;&nbsp;<a href="#Section_3_15">3.15 Tuples</a></p>
<p class="A">&nbsp;</p>
<p class="A"><a href="#Chapter_4">4. Ranges and algorithms</a></p>
<p class="A">&nbsp;&nbsp;&nbsp;<a href="#Section_4_1">4.1 Range</a></p>
<p class="A">&nbsp;&nbsp;&nbsp;<a href="#Section_4_2">4.2 Algorithms</a></p>
<p class="A">&nbsp;&nbsp;&nbsp;<a href="#Section_4_3">4.3 Sorting</a></p>
<p class="A">&nbsp;</p>
<p class="A"><a href="#Chapter_5">5. Value</a></p>
<p class="A">&nbsp;&nbsp;&nbsp;<a href="#Section_5_1">5.1 Value</a></p>
<p class="A">&nbsp;&nbsp;&nbsp;<a href="#Section_5_2">5.2 Null</a></p>
<p class="A">&nbsp;&nbsp;&nbsp;<a href="#Section_5_3">5.3 Client types and Value, RawValue, RichValue</a></p>
<p class="A">&nbsp;&nbsp;&nbsp;<a href="#Section_5_4">5.4 ValueArray and ValueMap</a></p>
<p class="A">&nbsp;</p>
<p class="A"><a href="#Chapter_6">6. Function and lambdas</a></p>
<p class="A">&nbsp;&nbsp;&nbsp;<a href="#Section_6_1">6.1 Function</a></p>
<p class="A">&nbsp;&nbsp;&nbsp;<a href="#Section_6_2">6.2 Capturing U++ containers into lambdas</a></p>
<p class="A">&nbsp;</p>
<p class="A"><a href="#Chapter_7">7. Multithreading</a></p>
<p class="A">&nbsp;&nbsp;&nbsp;<a href="#Section_7_1">7.1 Thread</a></p>
<p class="A">&nbsp;&nbsp;&nbsp;<a href="#Section_7_2">7.2 Mutex</a></p>
<p class="A">&nbsp;&nbsp;&nbsp;<a href="#Section_7_3">7.3 ConditionVariable</a></p>
<p class="A">&nbsp;&nbsp;&nbsp;<a href="#Section_7_4">7.4 CoWork</a></p>
<p class="A">&nbsp;&nbsp;&nbsp;<a href="#Section_7_5">7.5 AsyncWork</a></p>
<p class="A">&nbsp;&nbsp;&nbsp;<a href="#Section_7_6">7.6 CoPartition</a></p>
<p class="A">&nbsp;&nbsp;&nbsp;<a href="#Section_7_7">7.7 CoDo</a></p>
<p class="A">&nbsp;&nbsp;&nbsp;<a href="#Section_7_8">7.8 Parallel algorithms</a></p>
<hr><p id="Chapter_1" class="D">1. Basics</p>
<p id="Section_1_1" class="E">1.1 Logging</p>
<p class="F">Logging is a useful technique to trace the flow of the code and examine results. In this tutorial we will be using logging extensively, so let us start tutorial with the explanation of logging.</p>
<p class="F">In debug mode and with default settings, macro <span class="G">LOG</span> puts string into output log file. Log file is placed into 'config-directory', which by default is .exe directory in Win32 and ~/.upp/appname in POSIX.</p>
<p class="F">In TheIDE, you can access the log using 'Debug'/'View the log file Alt+L'.</p>
<p class="A">&nbsp;</p>
<p class="H">LOG(&quot;Hello world&quot;);</p>
<p class="A">&nbsp;</p>
<p class="I">Hello world</p>
<p class="A">&nbsp;</p>
<p class="F">You can log values of various types, as long as they have <span class="G">AsString</span> function defined You can chain values in single <span class="G">LOG</span> using <span class="G">operator&lt;&lt;</span>:</p>
<p class="A">&nbsp;</p>
<p class="H">int x = 123;</p>
<p class="H">LOG(&quot;Value of x is &quot; &lt;&lt; x);</p>
<p class="A">&nbsp;</p>
<p class="I">Value of x is 123</p>
<p class="A">&nbsp;</p>
<p class="F">As it is very common to log a value of single variable, <span class="G">DUMP</span> macro provides a useful shortcut, creating a log line with the variable name and value:</p>
<p class="A">&nbsp;</p>
<p class="H">DUMP(x);</p>
<p class="A">&nbsp;</p>
<p class="I">x = 123</p>
<p class="A">&nbsp;</p>
<p class="J"><span class="K">To get the value in hexadecimal code, you can use </span>LOGHEX<span class="K"> / </span>DUMPHEX</p>
<p class="A">&nbsp;</p>
<p class="H">DUMPHEX(x);</p>
<p class="H">String h = &quot;foo&quot;;</p>
<p class="H">DUMPHEX(h);</p>
<p class="A">&nbsp;</p>
<p class="I">x = 0x7b</p>
<p class="I">h = Memory at 0x0208fe08, size 0x3 = 3</p>
<p class="I"> &nbsp;&nbsp;&nbsp;+0 0x0208FE08 66 6F 6F &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foo &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
<p class="A">&nbsp;</p>
<p class="F">To log the value of a container (or generic Range), you can either use normal <span class="G">LOG</span> / <span class="G">DUMP</span>:</p>
<p class="A">&nbsp;</p>
<p class="H">Vector&lt;int&gt; v = { 1, 2, 3 };</p>
<p class="H">&nbsp;</p>
<p class="H">DUMP(v);</p>
<p class="A">&nbsp;</p>
<p class="I">v = [1, 2, 3]</p>
<p class="A">&nbsp;</p>
<p class="F">or you can use DUMPC for multi-line output:</p>
<p class="A">&nbsp;</p>
<p class="H">DUMPC(v);</p>
<p class="A">&nbsp;</p>
<p class="I">v:</p>
<p class="I">&nbsp;&nbsp;&nbsp;&nbsp;[0] = 1</p>
<p class="I">&nbsp;&nbsp;&nbsp;&nbsp;[1] = 2</p>
<p class="I">&nbsp;&nbsp;&nbsp;&nbsp;[2] = 3</p>
<p class="A">&nbsp;</p>
<p class="F">For maps, use DUMPM:</p>
<p class="A">&nbsp;</p>
<p class="H">VectorMap&lt;int, String&gt; map = { { 1, &quot;one&quot; }, { 2, &quot;two&quot; } };</p>
<p class="H">&nbsp;</p>
<p class="H">DUMP(map);</p>
<p class="A">&nbsp;</p>
<p class="I">map = {1: one, 2: two}</p>
<p class="A">&nbsp;</p>
<p class="A">&nbsp;</p>
<p class="H">DUMPM(map);</p>
<p class="A">&nbsp;</p>
<p class="I">map:</p>
<p class="I">&nbsp;&nbsp;&nbsp;&nbsp;[0] = (1) one</p>
<p class="I">&nbsp;&nbsp;&nbsp;&nbsp;[1] = (2) two</p>
<p class="A">&nbsp;</p>
<p class="F">All normal <span class="G">LOG</span>s are removed in release mode. If you need to log things in release mode, you need to use <span class="G">LOG</span>/`DUMP` variant with '<span class="G">R</span>' prefix (<span class="G">RLOG</span>, <span class="G">RDUMP</span>, <span class="G">RDUMPHEX</span>...):</p>
<p class="A">&nbsp;</p>
<p class="H">RLOG(&quot;This will be logged in release mode too!&quot;);</p>
<p class="A">&nbsp;</p>
<p class="I">This will be logged in release mode too!</p>
<p class="A">&nbsp;</p>
<p class="F">Sort of opposite situation is when adding temporary <span class="G">LOG</span>s to the code for debugging. In that case, '<span class="G">D</span>' prefixed variants (<span class="G">DLOG</span>, <span class="G">DDUMP</span>, <span class="G">DDUMPHEX</span>...) are handy - these cause compile error in release mode (unless you define the flag DEBUGCODE in the main configuration), so will not get forgotten in the code past the release:</p>
<p class="A">&nbsp;</p>
<p class="H">DLOG(&quot;This would not compile in release mode.&quot;);</p>
<p class="A">&nbsp;</p>
<p class="I">This would not compile in release mode.</p>
<p class="A">&nbsp;</p>
<p class="F">The last flavor of <span class="G">LOG</span> you can encounter while reading U++ sources is the one prefixed with '<span class="G">L</span>'. This one is not actually defined in U++ library and is just a convention. On the start of file, there is usually something like:</p>
<p class="A">&nbsp;</p>
<p class="H">#define LLOG(x) // DLOG(x)</p>
<p class="A">&nbsp;</p>
<p class="F">and by uncommenting the body part, you can activate the logging in that particular file.</p>
<p class="F">While logging to .log file is default, there are various ways how to affect logging, for example following line adjusts logging to output the log both to the console and .log file:</p>
<p class="A">&nbsp;</p>
<p class="H">StdLogSetup(LOG_COUT|LOG_FILE);</p>
<p class="A">&nbsp;</p>
<hr><p id="Section_1_2" class="E">1.2 String</p>
<p class="F">String is a value type useful for storing text or binary data.</p>
<p class="A">&nbsp;</p>
<p class="H">String a = &quot;Hello&quot;;</p>
<p class="H">DUMP(a);</p>
<p class="A">&nbsp;</p>
<p class="I">a = Hello</p>
<p class="A">&nbsp;</p>
<p class="F">You can concatenate it with another String or literal:</p>
<p class="A">&nbsp;</p>
<p class="H">a = a + &quot; world&quot;;</p>
<p class="H">DUMP(a);</p>
<p class="A">&nbsp;</p>
<p class="I">a = Hello world</p>
<p class="A">&nbsp;</p>
<p class="F">Or single character or specified number of characters from another <span class="G">String</span> or literal:</p>
<p class="A">&nbsp;</p>
<p class="H">a.Cat('!');</p>
<p class="H">DUMP(a);</p>
<p class="A">&nbsp;</p>
<p class="I">a = Hello world!</p>
<p class="A">&nbsp;</p>
<p class="A">&nbsp;</p>
<p class="H">a.Cat(&quot;ABCDEFGHIJKLM&quot;, 3);</p>
<p class="H">DUMP(a);</p>
<p class="A">&nbsp;</p>
<p class="I">a = Hello world!ABC</p>
<p class="A">&nbsp;</p>
<p class="F"><span class="G">Clear</span> method empties the String:</p>
<p class="A">&nbsp;</p>
<p class="H">a.Clear();</p>
<p class="H">DUMP(a);</p>
<p class="A">&nbsp;</p>
<p class="I">a = </p>
<p class="A">&nbsp;</p>
<p class="F">You can use <span class="G">operator&lt;&lt;</span> to append to existing <span class="G">String</span>. Non-string values are converted to appropriate <span class="G">String</span> representation (using standard function <span class="G">AsString</span>, whose default template definition calls <span class="G">ToString</span> method for value):</p>
<p class="A">&nbsp;</p>
<p class="H">for(int i = 0; i &lt; 10; i++)</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;a &lt;&lt; i &lt;&lt; &quot;, &quot;;</p>
<p class="H">&nbsp;</p>
<p class="H">DUMP(a);</p>
<p class="A">&nbsp;</p>
<p class="I">a = 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, </p>
<p class="A">&nbsp;</p>
<p class="F">Sometimes is is useful to use <span class="G">operator&lt;&lt;</span> to produce a temporary <span class="G">String</span> value (e.g. as real argument to function call):</p>
<p class="A">&nbsp;</p>
<p class="H">String b = String() &lt;&lt; &quot;Number is &quot; &lt;&lt; 123 &lt;&lt; &quot;.&quot;;</p>
<p class="H">&nbsp;</p>
<p class="H">DUMP(b);</p>
<p class="A">&nbsp;</p>
<p class="I">b = Number is 123.</p>
<p class="A">&nbsp;</p>
<p class="F">String provides many various methods for obtaining character count, inserting characters into <span class="G">String</span> or removing them:</p>
<p class="A">&nbsp;</p>
<p class="H">a = &quot;0123456789&quot;;</p>
<p class="H">&nbsp;</p>
<p class="H">DUMP(a.GetCount());</p>
<p class="A">&nbsp;</p>
<p class="I">a.GetCount() = 10</p>
<p class="A">&nbsp;</p>
<p class="A">&nbsp;</p>
<p class="H">DUMP(a.GetLength()); // GetLength is a synonym of GetCount</p>
<p class="A">&nbsp;</p>
<p class="I">a.GetLength() = 10</p>
<p class="A">&nbsp;</p>
<p class="A">&nbsp;</p>
<p class="H">a.Insert(6, &quot;&lt;inserted&gt;&quot;);</p>
<p class="H">DUMP(a);</p>
<p class="A">&nbsp;</p>
<p class="I">a = 012345&lt;inserted&gt;6789</p>
<p class="A">&nbsp;</p>
<p class="A">&nbsp;</p>
<p class="H">a.Remove(2, 2);</p>
<p class="H">DUMP(a);</p>
<p class="A">&nbsp;</p>
<p class="I">a = 0145&lt;inserted&gt;6789</p>
<p class="A">&nbsp;</p>
<p class="F">as well as searching and comparing methods:</p>
<p class="A">&nbsp;</p>
<p class="H">DUMP(a.Find('e'));</p>
<p class="H">DUMP(a.ReverseFind('e'));</p>
<p class="A">&nbsp;</p>
<p class="I">a.Find('e') = 8</p>
<p class="I">a.ReverseFind('e') = 11</p>
<p class="A">&nbsp;</p>
<p class="A">&nbsp;</p>
<p class="H">DUMP(a.Find(&quot;ins&quot;));</p>
<p class="A">&nbsp;</p>
<p class="I">a.Find(&quot;ins&quot;) = 5</p>
<p class="A">&nbsp;</p>
<p class="A">&nbsp;</p>
<p class="H">DUMP(a.StartsWith(&quot;ABC&quot;));</p>
<p class="H">DUMP(a.StartsWith(&quot;01&quot;));</p>
<p class="H">DUMP(a.EndsWith(&quot;89&quot;));</p>
<p class="A">&nbsp;</p>
<p class="I">a.StartsWith(&quot;ABC&quot;) = false</p>
<p class="I">a.StartsWith(&quot;01&quot;) = true</p>
<p class="I">a.EndsWith(&quot;89&quot;) = true</p>
<p class="A">&nbsp;</p>
<p class="F">You can get slice of String using Mid method; with single parameter it provides slice to the end of String:</p>
<p class="A">&nbsp;</p>
<p class="H">DUMP(a.Mid(3, 3));</p>
<p class="H">DUMP(a.Mid(3));</p>
<p class="A">&nbsp;</p>
<p class="I">a.Mid(3, 3) = 5&lt;i</p>
<p class="I">a.Mid(3) = 5&lt;inserted&gt;6789</p>
<p class="A">&nbsp;</p>
<p class="F">You can also trim the length of String using Trim (this is faster than using any other method):</p>
<p class="A">&nbsp;</p>
<p class="H">a.Trim(4);</p>
<p class="H">DUMP(a);</p>
<p class="A">&nbsp;</p>
<p class="I">a = 0145</p>
<p class="A">&nbsp;</p>
<p class="F">You can obtain integer values of individual characters using operator[]:</p>
<p class="A">&nbsp;</p>
<p class="H">DUMP(a[0]);</p>
<p class="A">&nbsp;</p>
<p class="I">a[0] = 48</p>
<p class="A">&nbsp;</p>
<p class="F">or the value of first character using operator* (note that if <span class="G">GetCount() == 0</span>, this will return zero terminator):</p>
<p class="A">&nbsp;</p>
<p class="H"> &nbsp;&nbsp;&nbsp;DUMP(*a);</p>
<p class="A">&nbsp;</p>
<p class="I">*a = 48</p>
<p class="A">&nbsp;</p>
<p class="A">&nbsp;</p>
<p class="H"> &nbsp;&nbsp;&nbsp;a.Clear();</p>
<p class="H"> &nbsp;&nbsp;&nbsp;</p>
<p class="H"> &nbsp;&nbsp;&nbsp;DUMP(*a);</p>
<p class="A">&nbsp;</p>
<p class="I">*a = 0</p>
<p class="A">&nbsp;</p>
<p class="F"><span class="G">String</span> has implicit cast to zero terminated <span class="G">const char *ptr</span> (only valid as long as <span class="G">String</span> does not mutate:</p>
<p class="A">&nbsp;</p>
<p class="H">a = &quot;1234&quot;;</p>
<p class="H">const char *s = a;</p>
<p class="H">while(*s)</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;LOG(*s++);</p>
<p class="A">&nbsp;</p>
<p class="I">1</p>
<p class="I">2</p>
<p class="I">3</p>
<p class="I">4</p>
<p class="A">&nbsp;</p>
<p class="F"><span class="G">String</span> also has standard <span class="G">begin</span> <span class="G">end</span> methods, which e.g. allows for C++11 <span class="G">for</span>:</p>
<p class="A">&nbsp;</p>
<p class="H">for(char ch : a)</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;LOG(ch);</p>
<p class="A">&nbsp;</p>
<p class="I">1</p>
<p class="I">2</p>
<p class="I">3</p>
<p class="I">4</p>
<p class="A">&nbsp;</p>
<p class="F">It is absolutely OK and common to use String for storing binary data, including zeroes:</p>
<p class="A">&nbsp;</p>
<p class="H">a.Cat(0);</p>
<p class="H">&nbsp;</p>
<p class="H">DUMPHEX(a);</p>
<p class="A">&nbsp;</p>
<p class="I">a = Memory at 0x0208fde0, size 0x5 = 5</p>
<p class="I"> &nbsp;&nbsp;&nbsp;+0 0x0208FDE0 31 32 33 34 00 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1234. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
<p class="A">&nbsp;</p>
<hr><p id="Section_1_3" class="E">1.3 StringBuffer</p>
<p class="F">If you need a direct write access to <span class="G">String</span>'s C-string character buffer, you can use complementary <span class="G">StringBuffer</span> class. One of reasons to do so is when you have to deal with some C-API functions that expects to write directly to <span class="G">char *</span> and you would like that result converted to the <span class="G">String</span>:</p>
<p class="A">&nbsp;</p>
<p class="H">void CApiFunction(char *c)</p>
<p class="H">{</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;strcpy(c, &quot;Hello&quot;);</p>
<p class="H">}</p>
<p class="H">&nbsp;</p>
<p class="H">StringBuffer b;</p>
<p class="H">b.SetLength(200);</p>
<p class="H">CApiFunction(b);</p>
<p class="H">b.Strlen();</p>
<p class="H">String x = b;</p>
<p class="H">&nbsp;</p>
<p class="H">DUMP(x);</p>
<p class="A">&nbsp;</p>
<p class="I">x = Hello</p>
<p class="A">&nbsp;</p>
<p class="F">In this case, <span class="G">SetLength</span> creates a C array of 200 characters. You can then call C-API function. Later you set the real length using <span class="G">Strlen</span> - this function performs strlen of buffer and sets the length accordingly. Later you simply assign the <span class="G">StringBuffer</span> to <span class="G">String</span>. Note that for performance reasons, this operation clears the <span class="G">StringBuffer</span> content (operation is fast and does not depend on the number of characters).</p>
<p class="F">Another usage scenario of StringBuffer is altering existing String:</p>
<p class="A">&nbsp;</p>
<p class="H">b = x;</p>
<p class="H">b[1] = 'a';</p>
<p class="H">x = b;</p>
<p class="H">&nbsp;</p>
<p class="H">DUMP(x);</p>
<p class="A">&nbsp;</p>
<p class="I">x = Hallo</p>
<p class="A">&nbsp;</p>
<p class="F">Similar to assigning StringBuffer to String, assigning String to StringBuffer clears the source String.</p>
<p class="F">StringBuffer also provides appending operations:</p>
<p class="A">&nbsp;</p>
<p class="H">b = x;</p>
<p class="H">b.Cat('!');</p>
<p class="H">x = b;</p>
<p class="H">&nbsp;</p>
<p class="H">DUMP(x);</p>
<p class="A">&nbsp;</p>
<p class="I">x = Hallo!</p>
<p class="A">&nbsp;</p>
<p class="F">Note that sometimes when creating some String from a lot of single characters, using StringBuffer for the operation is slightly faster then using String directly.</p>
<hr><p id="Section_1_4" class="E">1.4 WString</p>
<p class="F">String works with 8 bit characters. For 16-bit character encoding use <span class="G">WString</span>. Both classes are closely related and share most of interface methods. U++ also provides conversions between <span class="G">String</span> and <span class="G">WString</span> and you can also use 8 bit string literals with <span class="G">WString</span>. Conversion is ruled by current default character set. Default value of default character set is <span class="G">CHARSET_UTF8</span>. This conversion is also used in <span class="G">WString::ToString</span>, e.g. when putting <span class="G">WString</span> to log:</p>
<p class="A">&nbsp;</p>
<p class="H">WString x = &quot;characters 280-300: &quot;; // you can assign 8-bit character literal to WString</p>
<p class="H">for(int i = 280; i &lt; 300; i++)</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;x.Cat(i);</p>
<p class="H">&nbsp;</p>
<p class="H">DUMP(x);</p>
<p class="A">&nbsp;</p>
<p class="I">x = characters 280-300: ĘęĚěĜĝĞğĠġĢģĤĥĦħĨĩĪī</p>
<p class="A">&nbsp;</p>
<p class="F"><span class="G">ToString</span> converts <span class="G">WString</span> to <span class="G">String</span>:</p>
<p class="A">&nbsp;</p>
<p class="H">String y = x.ToString();</p>
<p class="H">DUMP(y);</p>
<p class="A">&nbsp;</p>
<p class="I">y = characters 280-300: ĘęĚěĜĝĞğĠġĢģĤĥĦħĨĩĪī</p>
<p class="A">&nbsp;</p>
<p class="F"><span class="G">ToWString</span> converts <span class="G">String</span> to <span class="G">WString</span>:</p>
<p class="A">&nbsp;</p>
<p class="H">y.Cat(&quot; (appended)&quot;); // you can use 8-bit character literals in most WString operations</p>
<p class="H">x = y.ToWString();</p>
<p class="H">&nbsp;</p>
<p class="H">DUMP(x);</p>
<p class="A">&nbsp;</p>
<p class="I">x = characters 280-300: ĘęĚěĜĝĞğĠġĢģĤĥĦħĨĩĪī (appended)</p>
<p class="A">&nbsp;</p>
<hr><p id="Section_1_5" class="E">1.5 Date and Time</p>
<p class="F">To represent date and time, U++ provides <span class="G">Date</span> and <span class="G">Time</span> concrete types.</p>
<p class="A">&nbsp;</p>
<p class="H">Date date = GetSysDate();</p>
<p class="H">&nbsp;</p>
<p class="H">DUMP(date);</p>
<p class="A">&nbsp;</p>
<p class="I">date = 07/21/2021</p>
<p class="A">&nbsp;</p>
<p class="F">All data members of <span class="G">Date</span> structure are public:</p>
<p class="A">&nbsp;</p>
<p class="H">DUMP((int)date.year); // we need to cast to int because some date members</p>
<p class="H">DUMP((int)date.month); // are of unsigned character type which would log</p>
<p class="H">DUMP((int)date.day); // as characters</p>
<p class="A">&nbsp;</p>
<p class="I">(int)date.year = 2021</p>
<p class="I">(int)date.month = 7</p>
<p class="I">(int)date.day = 21</p>
<p class="A">&nbsp;</p>
<p class="F">Dates can be compared:</p>
<p class="A">&nbsp;</p>
<p class="H">DUMP(date &gt; Date(2000, 1, 1));</p>
<p class="A">&nbsp;</p>
<p class="I">date &gt; Date(2000, 1, 1) = true</p>
<p class="A">&nbsp;</p>
<p class="F">Adding a number to <span class="G">Date</span> adds a number of days to it, incrementing/decrementing goes to the next/previous day:</p>
<p class="A">&nbsp;</p>
<p class="H">DUMP(date + 1);</p>
<p class="H">DUMP(--date);</p>
<p class="H">DUMP(++date);</p>
<p class="A">&nbsp;</p>
<p class="I">date + 1 = 07/22/2021</p>
<p class="I">--date = 07/20/2021</p>
<p class="I">++date = 07/21/2021</p>
<p class="A">&nbsp;</p>
<p class="F">Subtraction of dates yields a number of days between them:</p>
<p class="A">&nbsp;</p>
<p class="H">DUMP(date - Date(2000, 1, 1));</p>
<p class="A">&nbsp;</p>
<p class="I">date - Date(2000, 1, 1) = 7872</p>
<p class="A">&nbsp;</p>
<p class="F">There are several <span class="G">Date</span> and calendar related functions:</p>
<p class="A">&nbsp;</p>
<p class="H">DUMP(IsLeapYear(2012));</p>
<p class="H">DUMP(IsLeapYear(2014));</p>
<p class="H">DUMP(IsLeapYear(2015));</p>
<p class="H">DUMP(IsLeapYear(2016));</p>
<p class="H">DUMP(IsLeapYear(2017));</p>
<p class="A">&nbsp;</p>
<p class="I">IsLeapYear(2012) = true</p>
<p class="I">IsLeapYear(2014) = false</p>
<p class="I">IsLeapYear(2015) = false</p>
<p class="I">IsLeapYear(2016) = true</p>
<p class="I">IsLeapYear(2017) = false</p>
<p class="A">&nbsp;</p>
<p class="A">&nbsp;</p>
<p class="H">DUMP(GetDaysOfMonth(2, 2015));</p>
<p class="H">DUMP(GetDaysOfMonth(2, 2016));</p>
<p class="A">&nbsp;</p>
<p class="I">GetDaysOfMonth(2, 2015) = 28</p>
<p class="I">GetDaysOfMonth(2, 2016) = 29</p>
<p class="A">&nbsp;</p>
<p class="A">&nbsp;</p>
<p class="H">DUMP(DayOfWeek(date)); // 0 is Sunday</p>
<p class="A">&nbsp;</p>
<p class="I">DayOfWeek(date) = 3</p>
<p class="A">&nbsp;</p>
<p class="A">&nbsp;</p>
<p class="H">DUMP(LastDayOfMonth(date));</p>
<p class="H">DUMP(FirstDayOfMonth(date));</p>
<p class="H">DUMP(LastDayOfYear(date));</p>
<p class="H">DUMP(FirstDayOfYear(date));</p>
<p class="H">DUMP(DayOfYear(date)); // number of days since Jan-1 + 1</p>
<p class="H">DUMP(DayOfYear(Date(2016, 1, 1)));</p>
<p class="A">&nbsp;</p>
<p class="I">LastDayOfMonth(date) = 07/31/2021</p>
<p class="I">FirstDayOfMonth(date) = 07/01/2021</p>
<p class="I">LastDayOfYear(date) = 12/31/2021</p>
<p class="I">FirstDayOfYear(date) = 01/01/2021</p>
<p class="I">DayOfYear(date) = 202</p>
<p class="I">DayOfYear(Date(2016, 1, 1)) = 1</p>
<p class="A">&nbsp;</p>
<p class="A">&nbsp;</p>
<p class="H">DUMP(AddMonths(date, 20));</p>
<p class="H">DUMP(GetMonths(date, date + 100)); // number of 'whole months' between two dates</p>
<p class="H">DUMP(GetMonthsP(date, date + 100)); // number of 'whole or partial months' between two dates</p>
<p class="H">DUMP(AddYears(date, 2));</p>
<p class="A">&nbsp;</p>
<p class="I">AddMonths(date, 20) = 03/21/2023</p>
<p class="I">GetMonths(date, date + 100) = 3</p>
<p class="I">GetMonthsP(date, date + 100) = 4</p>
<p class="I">AddYears(date, 2) = 07/21/2023</p>
<p class="A">&nbsp;</p>
<p class="A">&nbsp;</p>
<p class="H">DUMP(GetWeekDate(2015, 1));</p>
<p class="H">int year;</p>
<p class="H">DUMP(GetWeek(Date(2016, 1, 1), year)); // first day of year can belong to previous year</p>
<p class="H">DUMP(year);</p>
<p class="A">&nbsp;</p>
<p class="I">GetWeekDate(2015, 1) = 12/29/2014</p>
<p class="I">GetWeek(Date(2016, 1, 1), year) = 53</p>
<p class="I">year = 2015</p>
<p class="A">&nbsp;</p>
<p class="A">&nbsp;</p>
<p class="H">DUMP(EasterDay(2015));</p>
<p class="H">DUMP(EasterDay(2016));</p>
<p class="A">&nbsp;</p>
<p class="I">EasterDay(2015) = 04/05/2015</p>
<p class="I">EasterDay(2016) = 03/27/2016</p>
<p class="A">&nbsp;</p>
<p class="F">U++ defines the beginning and the end of era, most algorithms can safely assume that as minimal and maximal values <span class="G">Date</span> can represent:</p>
<p class="A">&nbsp;</p>
<p class="H">DUMP(Date::Low());</p>
<p class="H">DUMP(Date::High());</p>
<p class="A">&nbsp;</p>
<p class="I">Date::Low() = 01/01/-4000</p>
<p class="I">Date::High() = 01/01/4000</p>
<p class="A">&nbsp;</p>
<p class="F">Time is derived from <span class="G">Date</span>, adding members to represent time:</p>
<p class="A">&nbsp;</p>
<p class="H">Time time = GetSysTime();</p>
<p class="H">DUMP(time);</p>
<p class="H">DUMP((Date)time);</p>
<p class="H">DUMP((int)time.hour);</p>
<p class="H">DUMP((int)time.minute);</p>
<p class="H">DUMP((int)time.second);</p>
<p class="A">&nbsp;</p>
<p class="I">time = 07/21/2021 15:01:38</p>
<p class="I">(Date)time = 07/21/2021</p>
<p class="I">(int)time.hour = 15</p>
<p class="I">(int)time.minute = 1</p>
<p class="I">(int)time.second = 38</p>
<p class="A">&nbsp;</p>
<p class="F">Times can be compared:</p>
<p class="A">&nbsp;</p>
<p class="H">DUMP(time &gt; Time(1970, 0, 0));</p>
<p class="A">&nbsp;</p>
<p class="I">time &gt; Time(1970, 0, 0) = true</p>
<p class="A">&nbsp;</p>
<p class="F">Warning: As <span class="G">Time</span> is derived from the <span class="G">Date</span>, most operations automatically convert <span class="G">Time</span> back to <span class="G">Date</span>. You have to use <span class="G">ToTime</span> conversion function to convert <span class="G">Date</span> to <span class="G">Time</span>:</p>
<p class="A">&nbsp;</p>
<p class="H">DUMP(time &gt; date); // time gets converted to Date...</p>
<p class="H">DUMP(time &gt; ToTime(date));</p>
<p class="A">&nbsp;</p>
<p class="I">time &gt; date = false</p>
<p class="I">time &gt; ToTime(date) = true</p>
<p class="A">&nbsp;</p>
<p class="F">Like <span class="G">Date</span>, <span class="G">Time</span> supports add and subtract operations, but numbers represent seconds (using <span class="G">int64</span> datatype):</p>
<p class="A">&nbsp;</p>
<p class="H">DUMP(time + 1);</p>
<p class="H">DUMP(time + 24 * 3600);</p>
<p class="H">DUMP(time - date); // time converts to Date, so the result is in days</p>
<p class="H">DUMP(time - ToTime(date)); // Time - Time is in seconds</p>
<p class="A">&nbsp;</p>
<p class="I">time + 1 = 07/21/2021 15:01:39</p>
<p class="I">time + 24 * 3600 = 07/22/2021 15:01:38</p>
<p class="I">time - date = 0</p>
<p class="I">time - ToTime(date) = 54098</p>
<p class="A">&nbsp;</p>
<p class="F"><span class="G">Time</span> defines era limits too:</p>
<p class="A">&nbsp;</p>
<p class="H">DUMP(Time::Low());</p>
<p class="H">DUMP(Time::High());</p>
<p class="A">&nbsp;</p>
<p class="I">Time::Low() = 01/01/-4000 00:00:00</p>
<p class="I">Time::High() = 01/01/4000 00:00:00</p>
<p class="A">&nbsp;</p>
<hr><p id="Section_1_6" class="L"><span class="M">1.6 </span>AsString<span class="M">, </span>ToString<span class="M"> and </span>operator&lt;&lt;</p>
<p class="F">U++ Core provides simple yet effective standard schema for converting values to default textual form. System is based on the combination of template functions (following code is part of U++ library):</p>
<p class="A">&nbsp;</p>
<p class="H">namespace Upp {</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;template &lt;class T&gt;</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;inline String AsString(const T&amp; x)</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;{</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return x.ToString();</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;template &lt;class T&gt;</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;inline Stream&amp; operator&lt;&lt;(Stream&amp; s, const T&amp; x)</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;{</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s &lt;&lt; AsString(x);</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return s;</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;template &lt;class T&gt;</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;inline String&amp; operator&lt;&lt;(String&amp; s, const T&amp; x)</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;{</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s.Cat(AsString(x));</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return s;</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p class="H">};</p>
<p class="A">&nbsp;</p>
<p class="F">Client types have to either define <span class="G">String ToString</span> method or specialize <span class="G">AsString</span> template in <span class="G">Upp</span> namespace. Such types can be appended to Streams or Strings using <span class="G">operator&lt;&lt;</span>. Of course, U++ value types and primitive types have required items predefined by U++:</p>
<p class="A">&nbsp;</p>
<p class="H">FileOut fout(ConfigFile(&quot;test.txt&quot;));</p>
<p class="H">String &nbsp;sout;</p>
<p class="H">&nbsp;</p>
<p class="H">fout &lt;&lt; 1.23 &lt;&lt; ' ' &lt;&lt; GetSysDate() &lt;&lt; ' ' &lt;&lt; GetSysTime();</p>
<p class="H">sout &lt;&lt; 1.23 &lt;&lt; ' ' &lt;&lt; GetSysDate() &lt;&lt; ' ' &lt;&lt; GetSysTime();</p>
<p class="H">&nbsp;</p>
<p class="H">fout.Close();</p>
<p class="H">&nbsp;</p>
<p class="H">DUMP(LoadFile(ConfigFile(&quot;test.txt&quot;)));</p>
<p class="H">DUMP(sout);</p>
<p class="A">&nbsp;</p>
<p class="I">LoadFile(ConfigFile(&quot;test.txt&quot;)) = 1.23 07/21/2021 07/21/2021 15:01:38</p>
<p class="I">sout = 1.23 07/21/2021 07/21/2021 15:01:38</p>
<p class="A">&nbsp;</p>
<p class="F">Getting client types involved into this schema is not too difficult, all you need to do is to add <span class="G">ToString</span> method:</p>
<p class="A">&nbsp;</p>
<p class="H">struct BinFoo {</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;int x;</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;String ToString() const &nbsp;&nbsp;{ return FormatIntBase(x, 2); }</p>
<p class="H">};</p>
<p class="H">&nbsp;</p>
<p class="H">BinFoo bf;</p>
<p class="H">bf.x = 30;</p>
<p class="H">&nbsp;</p>
<p class="H">sout.Clear();</p>
<p class="H">sout &lt;&lt; bf;</p>
<p class="H">DUMP(sout);</p>
<p class="A">&nbsp;</p>
<p class="I">sout = 11110</p>
<p class="A">&nbsp;</p>
<p class="F">If you cannot add <span class="G">ToString</span>, you can still specialize template in Upp namespace:</p>
<p class="A">&nbsp;</p>
<p class="H">struct RomanFoo {</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;int x;</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;RomanFoo(int x) : x(x) {}</p>
<p class="H">};</p>
<p class="H">&nbsp;</p>
<p class="H">namespace Upp {</p>
<p class="H">template &lt;&gt; String Upp::AsString(const RomanFoo&amp; a) { return FormatIntRoman(a.x); }</p>
<p class="H">};</p>
<p class="A">&nbsp;</p>
<hr><p id="Section_1_7" class="E">1.7 CombineHash</p>
<p class="F">To simplify providing of high quality hash codes for composite types, U++ provides <span class="G">CombineHash</span> utility class. This class uses <span class="G">GetHashValue</span> function to gather hash codes of all values and combines them to provide final hash value for composite type:</p>
<p class="A">&nbsp;</p>
<p class="H">struct Foo {</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;String a;</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;int &nbsp;&nbsp;&nbsp;b;</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;unsigned GetHashValue() const { return CombineHash(a, b); }</p>
<p class="H">};</p>
<p class="A">&nbsp;</p>
<p class="F">Note that <span class="G">GetHashValue</span> is defined as function template that calls <span class="G">GetHashValue</span> method of its argument, therefore defining <span class="G">GetHashValue</span> method defines <span class="G">GetHashValue</span> function too:</p>
<p class="A">&nbsp;</p>
<p class="H">Foo x;</p>
<p class="H">x.a = &quot;world&quot;;</p>
<p class="H">x.b = 22;</p>
<p class="H">&nbsp;</p>
<p class="H">DUMP(GetHashValue(x));</p>
<p class="A">&nbsp;</p>
<p class="I">GetHashValue(x) = 3180644175</p>
<p class="A">&nbsp;</p>
<p class="A">&nbsp;</p>
<p class="H">x.a &lt;&lt; '!';</p>
<p class="H">&nbsp;</p>
<p class="H">DUMP(GetHashValue(x));</p>
<p class="A">&nbsp;</p>
<p class="I">GetHashValue(x) = 1959050319</p>
<p class="A">&nbsp;</p>
<hr><p id="Section_1_8" class="E">1.8 SgnCompare and CombineCompare</p>
<p class="F">Traditional approach of C language of representing comparison results was 3-state: comparing a and b results in negative value (if a &lt; b), zero (if a == b) or positive value (a &gt; b). In C++ standard library, comparisons are usually represented with <span class="G">bool</span> predicates.</p>
<p class="F">However, with <span class="G">bool</span> predicate it becomes somewhat more difficult to provide comparisons for composite types:</p>
<p class="A">&nbsp;</p>
<p class="H">struct Foo {</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;String a;</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;int &nbsp;&nbsp;&nbsp;b;</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;int &nbsp;&nbsp;&nbsp;c;</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;// we want to order Foo instances by a first, then b, then c</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;bool operator&lt;(const Foo&amp; x) const {</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return a &lt; x.a ? true</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: a == x.a ? b &lt; x.b ? true</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: b == x.b ? false</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: c &lt; x.c</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: false;</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p class="H">};</p>
<p class="A">&nbsp;</p>
<p class="F">U++ provides standard function <span class="G">SgnCompare</span>, which returns negative value/zero/positive in &quot;C style&quot;:</p>
<p class="A">&nbsp;</p>
<p class="H">int a = 1;</p>
<p class="H">int b = 2;</p>
<p class="H">&nbsp;</p>
<p class="H">DUMP(SgnCompare(a, b));</p>
<p class="H">DUMP(SgnCompare(b, a));</p>
<p class="H">DUMP(SgnCompare(a, a));</p>
<p class="A">&nbsp;</p>
<p class="I">SgnCompare(a, b) = -1</p>
<p class="I">SgnCompare(b, a) = 1</p>
<p class="I">SgnCompare(a, a) = 0</p>
<p class="A">&nbsp;</p>
<p class="F">Default implementation of <span class="G">SgnCompare</span> calls <span class="G">Compare</span> method of value:</p>
<p class="A">&nbsp;</p>
<p class="H">struct MyClass {</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;int val;</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;int Compare(const MyClass&amp; x) const { return SgnCompare(val, x.val); }</p>
<p class="H">};</p>
<p class="A">&nbsp;</p>
<p class="F"><span class="G">SgnCompare</span> is now defined for <span class="G">MyClass</span>:</p>
<p class="A">&nbsp;</p>
<p class="H">MyClass u, v;</p>
<p class="H">u.val = 1;</p>
<p class="H">v.val = 2;</p>
<p class="H">&nbsp;</p>
<p class="H">DUMP(SgnCompare(u, v));</p>
<p class="H">DUMP(SgnCompare(v, u));</p>
<p class="H">DUMP(SgnCompare(v, v));</p>
<p class="A">&nbsp;</p>
<p class="I">SgnCompare(u, v) = -1</p>
<p class="I">SgnCompare(v, u) = 1</p>
<p class="I">SgnCompare(v, v) = 0</p>
<p class="A">&nbsp;</p>
<p class="F">Now getting back to <span class="G">Foo</span>, with <span class="G">SgnCompare</span> <span class="G">operator&lt;</span> becomes much less difficult:</p>
<p class="A">&nbsp;</p>
<p class="H">struct Foo2 {</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;String a;</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;int &nbsp;&nbsp;&nbsp;b;</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;int &nbsp;&nbsp;&nbsp;c;</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;bool operator&lt;(const Foo2&amp; x) const {</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int q = SgnCompare(a, x.a);</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(q) return q &lt; 0;</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;q = SgnCompare(b, x.b);</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(q) return q &lt; 0;</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;q = SgnCompare(c, x.c);</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return q &lt; 0;</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p class="H">};</p>
<p class="A">&nbsp;</p>
<p class="F">Alternatively, it is possible to define just <span class="G">Compare</span> method and use <span class="G">Comparable</span> <a href="https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern">CRTP idiom</a> to define all relation operators:</p>
<p class="A">&nbsp;</p>
<p class="H">struct Foo3 : Comparable&lt;Foo3&gt; {</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;String a;</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;int &nbsp;&nbsp;&nbsp;b;</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;int &nbsp;&nbsp;&nbsp;c;</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;int Compare(const Foo3&amp; x) const {</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int q = SgnCompare(a, x.a);</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(q) return q;</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;q = SgnCompare(b, x.b);</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(q) return q;</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return SgnCompare(c, x.c);</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p class="H">};</p>
<p class="H">&nbsp;</p>
<p class="H">Foo3 m, n;</p>
<p class="H">m.a = &quot;A&quot;;</p>
<p class="H">m.b = 1;</p>
<p class="H">m.c = 2;</p>
<p class="H">n.a = &quot;A&quot;;</p>
<p class="H">n.b = 1;</p>
<p class="H">n.c = 3;</p>
<p class="H">&nbsp;</p>
<p class="H">DUMP(m &lt; n);</p>
<p class="H">DUMP(m == n);</p>
<p class="H">DUMP(m != n);</p>
<p class="H">DUMP(SgnCompare(m, n));</p>
<p class="A">&nbsp;</p>
<p class="I">m &lt; n = true</p>
<p class="I">m == n = false</p>
<p class="I">m != n = true</p>
<p class="I">SgnCompare(m, n) = -1</p>
<p class="A">&nbsp;</p>
<p class="F">While the content of <span class="G">Compare</span> method is trivial, it can be further simplified using <span class="G">CombineCompare</span> helper class:</p>
<p class="A">&nbsp;</p>
<p class="H">struct Foo4 : Comparable&lt;Foo4&gt; {</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;String a;</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;int &nbsp;&nbsp;&nbsp;b;</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;int &nbsp;&nbsp;&nbsp;c;</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;int Compare(const Foo4&amp; x) const {</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return CombineCompare(a, x.a)(b, x.b)(c, x.c);</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p class="H">};</p>
<p class="H">&nbsp;</p>
<p class="H">Foo4 o, p;</p>
<p class="H">o.a = &quot;A&quot;;</p>
<p class="H">o.b = 1;</p>
<p class="H">o.c = 2;</p>
<p class="H">p.a = &quot;A&quot;;</p>
<p class="H">p.b = 1;</p>
<p class="H">p.c = 3;</p>
<p class="H">&nbsp;</p>
<p class="H">DUMP(o &lt; p);</p>
<p class="H">DUMP(o == p);</p>
<p class="H">DUMP(o != p);</p>
<p class="H">DUMP(SgnCompare(o, p));</p>
<p class="A">&nbsp;</p>
<p class="I">o &lt; p = true</p>
<p class="I">o == p = false</p>
<p class="I">o != p = true</p>
<p class="I">SgnCompare(o, p) = -1</p>
<p class="A">&nbsp;</p>
<hr><p id="Chapter_2" class="D">2. Streams</p>
<p id="Section_2_1" class="E">2.1 Streams basics</p>
<p class="F">U++ stream working with files is <span class="G">FileStream</span>. It has 3 derived classes, <span class="G">FileIn</span>, <span class="G">FileOut</span> and <span class="G">FileAppend</span>, for the most common uses.</p>
<p class="A">&nbsp;</p>
<p class="H">FileIn in(GetDataFile(&quot;test.txt&quot;));</p>
<p class="H">if(!in) {</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;LOG(&quot;Failed to open the file&quot;);</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;return;</p>
<p class="H">}</p>
<p class="A">&nbsp;</p>
<p class="F">The most basic operations of streams are <span class="G">Put</span> and <span class="G">Get</span>. <span class="G">Get</span> works in the same ways as good old C getc - it returns negative number on eof or error:</p>
<p class="A">&nbsp;</p>
<p class="H">String h;</p>
<p class="H">int c;</p>
<p class="H">while((c = in.Get()) &gt;= 0)</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;h.Cat(c);</p>
<p class="H">DUMP(h);</p>
<p class="A">&nbsp;</p>
<p class="I">h = Lorem ipsum dolor sit amet, consectetur adipiscing elit,</p>
<p class="I">sed do eiusmod tempor incididunt ut labore et dolore magna</p>
<p class="I">aliqua. Ut enim ad minim veniam, quis nostrud exercitation</p>
<p class="I">ullamco laboris nisi ut aliquip ex ea commodo consequat.</p>
<p class="I">Duis aute irure dolor in reprehenderit in voluptate velit</p>
<p class="I">esse cillum dolore eu fugiat nulla pariatur. Excepteur</p>
<p class="I">sint occaecat cupidatat non proident, sunt in culpa qui</p>
<p class="I">officia deserunt mollit anim id est laborum.</p>
<p class="A">&nbsp;</p>
<p class="F">U++ streams provide no formatting capabilities (that is deferred to text utilities), but they have some unique features. U++ does not distinguish between 'text' and 'binary' mode streams, methods are well suited to work with both in common mode.</p>
<p class="F"><span class="G">GetLine</span> returns <span class="G">String</span> of single line read (lines separator being '\n', '\r' is ignored):</p>
<p class="A">&nbsp;</p>
<p class="H">in.Seek(0);</p>
<p class="H">while(!in.IsEof())</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;DUMP(in.GetLine());</p>
<p class="A">&nbsp;</p>
<p class="I">in.GetLine() = Lorem ipsum dolor sit amet, consectetur adipiscing elit,</p>
<p class="I">in.GetLine() = sed do eiusmod tempor incididunt ut labore et dolore magna</p>
<p class="I">in.GetLine() = aliqua. Ut enim ad minim veniam, quis nostrud exercitation</p>
<p class="I">in.GetLine() = ullamco laboris nisi ut aliquip ex ea commodo consequat.</p>
<p class="I">in.GetLine() = Duis aute irure dolor in reprehenderit in voluptate velit</p>
<p class="I">in.GetLine() = esse cillum dolore eu fugiat nulla pariatur. Excepteur</p>
<p class="I">in.GetLine() = sint occaecat cupidatat non proident, sunt in culpa qui</p>
<p class="I">in.GetLine() = officia deserunt mollit anim id est laborum.</p>
<p class="A">&nbsp;</p>
<p class="F"><span class="G">Peek</span> can be used to look at the next character without actually moving on to the next one:</p>
<p class="A">&nbsp;</p>
<p class="H">in.Seek(0);</p>
<p class="H">DDUMP((char)in.Peek());</p>
<p class="H">DDUMP(in.GetLine());</p>
<p class="A">&nbsp;</p>
<p class="I">(char)in.Peek() = L</p>
<p class="I">in.GetLine() = Lorem ipsum dolor sit amet, consectetur adipiscing elit,</p>
<p class="A">&nbsp;</p>
<p class="F"><span class="G">Get</span> method reads at most specified number of bytes from the stream and returns them as <span class="G">String</span>:</p>
<p class="A">&nbsp;</p>
<p class="H">in.Seek(0);</p>
<p class="H">DUMP(in.Get(10));</p>
<p class="A">&nbsp;</p>
<p class="I">in.Get(10) = Lorem ipsu</p>
<p class="A">&nbsp;</p>
<p class="F">If there is not enough characters in the Stream as required by Get, everything till EOF is returned:</p>
<p class="A">&nbsp;</p>
<p class="H">in.Seek(0);</p>
<p class="H">DUMP(in.Get(999999).GetCount());</p>
<p class="A">&nbsp;</p>
<p class="I">in.Get(999999).GetCount() = 452</p>
<p class="A">&nbsp;</p>
<p class="F">In contrast, <span class="G">GetAll</span> method fails when there is not enough characters in the Stream and returns Void <span class="G">String</span> if Stream is not in <span class="G">LoadThrowing</span> mode:</p>
<p class="A">&nbsp;</p>
<p class="H">in.Seek(0);</p>
<p class="H">h = in.GetAll(100);</p>
<p class="H">DUMP(h.GetCount());</p>
<p class="A">&nbsp;</p>
<p class="I">h.GetCount() = 100</p>
<p class="A">&nbsp;</p>
<p class="A">&nbsp;</p>
<p class="H">h = in.GetAll(999999);</p>
<p class="H">DUMP(h.IsVoid());</p>
<p class="A">&nbsp;</p>
<p class="I">h.IsVoid() = true</p>
<p class="A">&nbsp;</p>
<p class="F">In <span class="G">LoadThrowing</span> mode, <span class="G">Stream</span> throws <span class="G">LoadingError</span> exception when there is problem with input <span class="G">Stream</span>:</p>
<p class="A">&nbsp;</p>
<p class="H">in.LoadThrowing();</p>
<p class="H">try {</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;in.GetAll(999999);</p>
<p class="H">}</p>
<p class="H">catch(LoadingError) {</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;LOG(&quot;Loading error&quot;);</p>
<p class="H">}</p>
<p class="A">&nbsp;</p>
<p class="I">Loading error</p>
<p class="A">&nbsp;</p>
<p class="F">Template variant of <span class="G">Stream::operator&lt;&lt;</span> is using <span class="G">AsString</span> to convert data to text:</p>
<p class="A">&nbsp;</p>
<p class="H">String fn = GetHomeDirFile(&quot;test.txt&quot;);</p>
<p class="H">FileOut out(fn);</p>
<p class="H">if(!out) {</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;LOG(&quot;Failed to open the file&quot;);</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;return;</p>
<p class="H">}</p>
<p class="H">out &lt;&lt; &quot;Some number &quot; &lt;&lt; 321 &lt;&lt; &quot; and Point &quot; &lt;&lt; Point(1, 2);</p>
<p class="H">out.Close();</p>
<p class="A">&nbsp;</p>
<p class="F">When writing to the <span class="G">Stream</span>, the good way to check for errors is to write all data, close the stream and then check for <span class="G">IsError</span>:</p>
<p class="A">&nbsp;</p>
<p class="H">if(out.IsError()) { // check whether file was properly written</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;LOG(&quot;Error&quot;);</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;return;</p>
<p class="H">}</p>
<p class="H">DUMP(LoadFile(fn));</p>
<p class="A">&nbsp;</p>
<p class="I">LoadFile(fn) = Some number 321 and Point [1, 2]</p>
<p class="A">&nbsp;</p>
<p class="F"><span class="G">FileAppend</span> can be used to append data to the file:</p>
<p class="A">&nbsp;</p>
<p class="H">FileAppend out2(fn);</p>
<p class="H">out2 &lt;&lt; &quot;\nSomething more&quot;;</p>
<p class="H">out2.Close();</p>
<p class="H">DUMP(LoadFile(fn));</p>
<p class="A">&nbsp;</p>
<p class="I">LoadFile(fn) = Some number 321 and Point [1, 2]</p>
<p class="I">Something more</p>
<p class="A">&nbsp;</p>
<p class="F">Important and often used type of <span class="G">Stream</span> is <span class="G">StringStream</span> which works with <span class="G">String</span> as input/output.</p>
<p class="F"><span class="G">Stream</span> also provides methods to store/load primitive types, in both little-endian and big-endian modes:</p>
<p class="A">&nbsp;</p>
<p class="H">StringStream ss;</p>
<p class="H">ss.Put32le(0x12345678);</p>
<p class="H">ss.Put32be(0x12345678);</p>
<p class="H">DUMPHEX(ss.GetResult());</p>
<p class="A">&nbsp;</p>
<p class="I">ss.GetResult() = Memory at 0x0208fa48, size 0x8 = 8</p>
<p class="I"> &nbsp;&nbsp;&nbsp;+0 0x0208FA48 78 56 34 12 12 34 56 78 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xV4..4Vx &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
<p class="A">&nbsp;</p>
<p class="A">&nbsp;</p>
<p class="H">StringStream ss2(ss.GetResult());</p>
<p class="H">DUMPHEX(ss2.Get32le());</p>
<p class="H">DUMPHEX(ss2.Get32be());</p>
<p class="A">&nbsp;</p>
<p class="I">ss2.Get32le() = 0x12345678</p>
<p class="I">ss2.Get32be() = 0x12345678</p>
<p class="A">&nbsp;</p>
<hr><p id="Section_2_2" class="E">2.2 Special streams</p>
<p class="F"><span class="G">SizeStream</span> counts the number of bytes written to the stream:</p>
<p class="A">&nbsp;</p>
<p class="H">SizeStream szs;</p>
<p class="H">szs &lt;&lt; &quot;1234567&quot;;</p>
<p class="H">DUMP(szs.GetSize());</p>
<p class="A">&nbsp;</p>
<p class="I">szs.GetSize() = 7</p>
<p class="A">&nbsp;</p>
<p class="F"><span class="G">CompareStream</span> can be used to compare the content of some stream with data written to <span class="G">CompareStream</span>:</p>
<p class="A">&nbsp;</p>
<p class="H">StringStream in(&quot;123456&quot;);</p>
<p class="H">CompareStream cs(in);</p>
<p class="H">cs.Put(&quot;12345&quot;);</p>
<p class="H">DUMP(cs.IsEqual());</p>
<p class="A">&nbsp;</p>
<p class="I">cs.IsEqual() = true</p>
<p class="A">&nbsp;</p>
<p class="A">&nbsp;</p>
<p class="H">cs.Put(&quot;7&quot;);</p>
<p class="H">DUMP(cs.IsEqual());</p>
<p class="A">&nbsp;</p>
<p class="I">cs.IsEqual() = false</p>
<p class="A">&nbsp;</p>
<p class="F"><span class="G">OutStream</span> buffers output data to bigger blocks, then outputs them via <span class="G">Out</span> virtual method:</p>
<p class="A">&nbsp;</p>
<p class="H">struct MyOutStream : OutStream {</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;virtual &nbsp;void &nbsp;Out(const void *data, dword size) {</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DUMPHEX(String((const char *)data, size));</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p class="H">};</p>
<p class="H">&nbsp;</p>
<p class="H">MyOutStream os;</p>
<p class="H">os &lt;&lt; &quot;This is a test &quot; &lt;&lt; 12345;</p>
<p class="H">os.Close();</p>
<p class="A">&nbsp;</p>
<p class="I">String((const char *)data, size) = Memory at 0x07604a10, size 0x14 = 20</p>
<p class="I"> &nbsp;&nbsp;&nbsp;+0 0x07604A10 54 68 69 73 20 69 73 20 61 20 74 65 73 74 20 31 &nbsp;&nbsp;&nbsp;&nbsp;This is a test 1</p>
<p class="I"> &nbsp;&nbsp;+16 0x07604A20 32 33 34 35 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2345 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
<p class="A">&nbsp;</p>
<p class="F"><span class="G">TeeStream</span> sends output data to two separate streams:</p>
<p class="A">&nbsp;</p>
<p class="H">StringStream ss1;</p>
<p class="H">StringStream ss2;</p>
<p class="H">TeeStream tee(ss1, ss2);</p>
<p class="H">tee &lt;&lt; &quot;Tee stream test&quot;;</p>
<p class="H">tee.Close();</p>
<p class="H">DUMP(ss1.GetResult());</p>
<p class="H">DUMP(ss2.GetResult());</p>
<p class="A">&nbsp;</p>
<p class="I">ss1.GetResult() = Tee stream test</p>
<p class="I">ss2.GetResult() = Tee stream test</p>
<p class="A">&nbsp;</p>
<p class="F"><span class="G">MemReadStream</span> can be used to convert read-only memory block to stream data:</p>
<p class="A">&nbsp;</p>
<p class="H">static const char s[] = &quot;Some line\nAnother line&quot;;</p>
<p class="H">MemReadStream ms(s, sizeof(s) - 1);</p>
<p class="H">while(!ms.IsEof())</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;DUMPHEX(ms.GetLine());</p>
<p class="A">&nbsp;</p>
<p class="I">ms.GetLine() = Memory at 0x0208f6f8, size 0x9 = 9</p>
<p class="I"> &nbsp;&nbsp;&nbsp;+0 0x0208F6F8 53 6F 6D 65 20 6C 69 6E 65 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Some line &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
<p class="I">ms.GetLine() = Memory at 0x0208f6f8, size 0xC = 12</p>
<p class="I"> &nbsp;&nbsp;&nbsp;+0 0x0208F6F8 41 6E 6F 74 68 65 72 20 6C 69 6E 65 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Another line &nbsp;&nbsp;&nbsp;</p>
<p class="A">&nbsp;</p>
<hr><p id="Section_2_3" class="E">2.3 Binary serialization</p>
<p class="F">Serialization is a mechanism that converts structured data to/from binary stream. In U++, loading and storing of data is performed by single code, in most cases represented by method <span class="G">Serialize</span>. Serialization is performed directly with basic <span class="G">Stream</span>. To this end, <span class="G">Stream</span> features a single boolean representing the direction of serialization process. The direction can be checked using <span class="G">IsLoading</span> and <span class="G">IsStoring</span> methods and changed with <span class="G">SetStoring</span> and <span class="G">SetLoading</span> methods. Direction is usually set properly by derived classes (e.g. FileOut sets it to storing, FileIn to loading).</p>
<p class="F">Shortcut to calling <span class="G">Serialize</span> method is <span class="G">operator%</span>, which is templated overload that calls <span class="G">Serialize</span> for given variable (primitive types have direct overload in <span class="G">Stream</span> class):</p>
<p class="A">&nbsp;</p>
<p class="H">StringStream ss;</p>
<p class="H">&nbsp;</p>
<p class="H">int x = 123;</p>
<p class="H">Color h = White();</p>
<p class="H">&nbsp;</p>
<p class="H">ss % x % h;</p>
<p class="H">&nbsp;</p>
<p class="H">StringStream ss2(ss.GetResult());</p>
<p class="H">&nbsp;</p>
<p class="H">int x2;</p>
<p class="H">Color h2;</p>
<p class="H">&nbsp;</p>
<p class="H">ss2 % x2 % h2;</p>
<p class="H">&nbsp;</p>
<p class="H">DUMP(x2);</p>
<p class="H">DUMP(h2);</p>
<p class="A">&nbsp;</p>
<p class="I">x2 = 123</p>
<p class="I">h2 = Color(255, 255, 255)</p>
<p class="A">&nbsp;</p>
<p class="F">When serialization fails to load the data (e.g. because of wrong structure or not enough data in the stream), <span class="G">Stream::LoadError</span> is invoked, which can trigger the exception if the stream is <span class="G">LoadThrowing</span>:</p>
<p class="A">&nbsp;</p>
<p class="H">ss2.Seek(0);</p>
<p class="H">ss2.LoadThrowing();</p>
<p class="H">try {</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;ss2 % x2 % h2 % x2;</p>
<p class="H">}</p>
<p class="H">catch(LoadingError) {</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;LOG(&quot;Deserialization has failed&quot;);</p>
<p class="H">}</p>
<p class="A">&nbsp;</p>
<p class="I">Deserialization has failed</p>
<p class="A">&nbsp;</p>
<p class="F">Examples so far serve mostly like basic demonstration of serialization. In practice, the implementation is usually represented by <span class="G">Serialize</span> method of class that is to be compatible with this concept. To that end, it is a good idea to provide means for future expansion of such class:</p>
<p class="A">&nbsp;</p>
<p class="H">struct MyFoo {</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;int &nbsp;&nbsp;&nbsp;number;</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;Color &nbsp;color;</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;void Serialize(Stream&amp; s) {</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int version = 0;</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s / version; // allow backward compatibility in the future</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s.Magic(31415); // put magic number into the stream to check for invalid data</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s % number % color;</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p class="H">};</p>
<p class="H">&nbsp;</p>
<p class="H">MyFoo foo;</p>
<p class="H">foo.number = 321;</p>
<p class="H">foo.color = Blue();</p>
<p class="A">&nbsp;</p>
<p class="F"><span class="G">StoreAsFile</span>, <span class="G">StoreAsString</span>, <span class="G">LoadFromFile</span> and <span class="G">LoadFromString</span> are convenience functions that simplify storing / loading objects to / from the most common forms of storage:</p>
<p class="A">&nbsp;</p>
<p class="H">String data = StoreAsString(foo);</p>
<p class="H">MyFoo foo2;</p>
<p class="H">LoadFromString(foo2, data);</p>
<p class="H">DUMP(foo2.number);</p>
<p class="H">DUMP(foo2.color);</p>
<p class="A">&nbsp;</p>
<p class="I">foo2.number = 321</p>
<p class="I">foo2.color = Color(0, 0, 128)</p>
<p class="A">&nbsp;</p>
<p class="F">Now if <span class="G">MyFoo</span> was to be extended to <span class="G">MyFoo2</span> and we wanted to maintain the ability to load it from binary data stored by original <span class="G">MyFoo</span>, we can branch on previously stored <span class="G">version</span>:</p>
<p class="A">&nbsp;</p>
<p class="H">struct MyFoo2 {</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;int &nbsp;&nbsp;&nbsp;number;</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;Color &nbsp;color;</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;String text;</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;void Serialize(Stream&amp; s) {</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int version = 1;</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s / version;</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s % number % color;</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(version &gt;= 1)</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s % text;</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p class="H">};</p>
<p class="H">MyFoo2 foo3;</p>
<p class="H">LoadFromString(foo3, data);</p>
<p class="H">DUMP(foo3.number);</p>
<p class="H">DUMP(foo3.color);</p>
<p class="A">&nbsp;</p>
<p class="I">foo3.number = 0</p>
<p class="I">foo3.color = Color(Null)</p>
<p class="A">&nbsp;</p>
<p class="F">Note: <span class="G">operator/</span> is Stream method with several overloads optimized for small value - in this case <span class="G">int</span> is stored as single byte if possible (and as 5 bytes if not).</p>
<hr><p id="Chapter_3" class="D">3. Array containers</p>
<p id="Section_3_1" class="E">3.1 <span class="N">Vector</span> basics</p>
<p class="F"><span class="G">Vector</span> is the basic container of U++. It is the random access container similar to <span class="G">std::vector</span> with one important performance related difference: There are rules for elements of <span class="G">Vector</span> that allow its implementation to move elements in memory using plain <span class="G">memcpy</span>/`memmove` (&quot;Moveable&quot; concept).</p>
<p class="F">Anyway, for now let us start with simple <span class="G">Vector</span> of <span class="G">int</span>s:</p>
<p class="A">&nbsp;</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;Vector&lt;int&gt; v;</p>
<p class="A">&nbsp;</p>
<p class="F">You can add elements to the Vector as parameters of the Add method</p>
<p class="A">&nbsp;</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;v.Add(1);</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;v.Add(2);</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;DUMP(v);</p>
<p class="A">&nbsp;</p>
<p class="I">v = [1, 2]</p>
<p class="A">&nbsp;</p>
<p class="F">Alternative and very important possibility for U++ containers is 'in-place creation'. In this case, parameter-less Add returns a reference to a new element in <span class="G">Vector</span>:</p>
<p class="A">&nbsp;</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;v.Add() = 3;</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;DUMP(v);</p>
<p class="A">&nbsp;</p>
<p class="I">v = [1, 2, 3]</p>
<p class="A">&nbsp;</p>
<p class="J"><span class="K">You can also use </span>operator&lt;&lt;</p>
<p class="A">&nbsp;</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;v &lt;&lt; 4 &lt;&lt; 5;</p>
<p class="H">&nbsp;</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;DUMP(v);</p>
<p class="A">&nbsp;</p>
<p class="I">v = [1, 2, 3, 4, 5]</p>
<p class="A">&nbsp;</p>
<p class="F"><span class="G">Vector</span> also supports initializer lists:</p>
<p class="A">&nbsp;</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;v.Append({ 6, 7 });</p>
<p class="H">&nbsp;</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;DUMP(v);</p>
<p class="A">&nbsp;</p>
<p class="I">v = [1, 2, 3, 4, 5, 6, 7]</p>
<p class="A">&nbsp;</p>
<p class="F">To iterate <span class="G">Vector</span> you can use indices:</p>
<p class="A">&nbsp;</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;for(int i = 0; i &lt; v.GetCount(); i++)</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LOG(v[i]);</p>
<p class="A">&nbsp;</p>
<p class="I">1</p>
<p class="I">2</p>
<p class="I">3</p>
<p class="I">4</p>
<p class="I">5</p>
<p class="I">6</p>
<p class="I">7</p>
<p class="A">&nbsp;</p>
<p class="F">begin/end interface:</p>
<p class="A">&nbsp;</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;for(auto q = v.begin(), e = v.end(); q != e; q++)</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LOG(*q);</p>
<p class="A">&nbsp;</p>
<p class="I">1</p>
<p class="I">2</p>
<p class="I">3</p>
<p class="I">4</p>
<p class="I">5</p>
<p class="I">6</p>
<p class="I">7</p>
<p class="A">&nbsp;</p>
<p class="F">C++11 range-for syntax:</p>
<p class="A">&nbsp;</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;for(const auto&amp; q : v)</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LOG(q);</p>
<p class="A">&nbsp;</p>
<p class="I">1</p>
<p class="I">2</p>
<p class="I">3</p>
<p class="I">4</p>
<p class="I">5</p>
<p class="I">6</p>
<p class="I">7</p>
<p class="A">&nbsp;</p>
<hr><p id="Section_3_2" class="E">3.2 <span class="N">Vector</span> operations</p>
<p class="F">You can <span class="G">Insert</span> or <span class="G">Remove</span> elements at random positions of Vector (O(n) complexity):</p>
<p class="A">&nbsp;</p>
<p class="H">Vector&lt;int&gt; v;</p>
<p class="H">v.Add(1);</p>
<p class="H">v.Add(2);</p>
<p class="H">&nbsp;</p>
<p class="H">v.Insert(1, 10);</p>
<p class="H">&nbsp;</p>
<p class="H">DUMP(v);</p>
<p class="A">&nbsp;</p>
<p class="I">v = [1, 10, 2]</p>
<p class="A">&nbsp;</p>
<p class="A">&nbsp;</p>
<p class="H">v.Insert(0, { 7, 6, 5 });</p>
<p class="H">&nbsp;</p>
<p class="H">DUMP(v);</p>
<p class="A">&nbsp;</p>
<p class="I">v = [7, 6, 5, 1, 10, 2]</p>
<p class="A">&nbsp;</p>
<p class="A">&nbsp;</p>
<p class="H">v.Remove(0);</p>
<p class="H">&nbsp;</p>
<p class="H">DUMP(v);</p>
<p class="A">&nbsp;</p>
<p class="I">v = [6, 5, 1, 10, 2]</p>
<p class="A">&nbsp;</p>
<p class="F"><span class="G">At</span> method returns element at specified position ensuring that such a position exists. If there is not enough elements in <span class="G">Vector</span>, required number of elements is added. If second parameter of <span class="G">At</span> is present, newly added elements are initialized to this value.</p>
<p class="A">&nbsp;</p>
<p class="H">v.Clear();</p>
<p class="H">for(int i = 0; i &lt; 10000; i++)</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;v.At(Random(10), 0)++;</p>
<p class="H">&nbsp;</p>
<p class="H">DUMP(v);</p>
<p class="A">&nbsp;</p>
<p class="I">v = [922, 995, 1050, 1007, 1002, 998, 1020, 1023, 1000, 983]</p>
<p class="A">&nbsp;</p>
<p class="F">Referencing invalid index is undefined operation. Sometimes however it is useful to return the element value if index is valid and some default value if it is not. This can be achieved with two parameter Get method:</p>
<p class="A">&nbsp;</p>
<p class="H">DUMP(v.Get(4, 0));</p>
<p class="H">DUMP(v.Get(-10, 0));</p>
<p class="H">DUMP(v.Get(13, -1));</p>
<p class="A">&nbsp;</p>
<p class="I">v.Get(4, 0) = 1002</p>
<p class="I">v.Get(-10, 0) = 0</p>
<p class="I">v.Get(13, -1) = -1</p>
<p class="A">&nbsp;</p>
<p class="F">You can apply algorithms on containers, e.g. Sort</p>
<p class="A">&nbsp;</p>
<p class="H">Sort(v);</p>
<p class="H">&nbsp;</p>
<p class="H">DUMP(v);</p>
<p class="A">&nbsp;</p>
<p class="I">v = [922, 983, 995, 998, 1000, 1002, 1007, 1020, 1023, 1050]</p>
<p class="A">&nbsp;</p>
<hr><p id="Section_3_3" class="E">3.3 Transfer issues</p>
<p class="F">Often you need to pass content of one container to another of the same type. U++ containers always support <a href="srcdoc$Core$pick_$en-us.html">pick semantics</a> (synonym of std::move), and, depending on type stored, also might support <a href="srcdoc$Core$pick_$en-us.html">clone semantics</a>. When transferring the value, you have to explicitly specify which one to use:</p>
<p class="A">&nbsp;</p>
<p class="H">Vector&lt;int&gt; v{ 1, 2 };</p>
<p class="H">&nbsp;</p>
<p class="H">DUMP(v);</p>
<p class="H">&nbsp;</p>
<p class="H">Vector&lt;int&gt; v1 = pick(v);</p>
<p class="H">&nbsp;</p>
<p class="H">DUMP(v);</p>
<p class="H">DUMP(v1);</p>
<p class="A">&nbsp;</p>
<p class="I">v = [1, 2]</p>
<p class="I">v = []</p>
<p class="I">v1 = [1, 2]</p>
<p class="A">&nbsp;</p>
<p class="F">now source <span class="G">Vector</span> <span class="G">v</span> is empty, as elements were 'picked' to <span class="G">v1</span>.</p>
<p class="F">If you really need to preserve value of source (and elements support deep copy operation), you can use <span class="G">clone</span>:</p>
<p class="A">&nbsp;</p>
<p class="H">v = clone(v1);</p>
<p class="H">&nbsp;</p>
<p class="H">DUMP(v);</p>
<p class="H">DUMP(v1);</p>
<p class="A">&nbsp;</p>
<p class="I">v = [1, 2]</p>
<p class="I">v1 = [1, 2]</p>
<p class="A">&nbsp;</p>
<p class="F">The requirement of explicit <span class="G">clone</span> has the advantage of avoiding unexpected deep copies. For example:</p>
<p class="A">&nbsp;</p>
<p class="H">Vector&lt;Vector&lt;int&gt;&gt; x;</p>
<p class="H">x.Add() &lt;&lt; 1 &lt;&lt; 2 &lt;&lt; 3;</p>
<p class="H">&nbsp;</p>
<p class="H">for(auto i : x) { LOG(i); }</p>
<p class="A">&nbsp;</p>
<p class="F">results in run-time error, whereas the equivalent code with <span class="G">std::vector</span> compiles but silently performs deep copy for each iteration:</p>
<p class="A">&nbsp;</p>
<p class="H">std::vector&lt;std::vector&lt;int&gt;&gt; sv;</p>
<p class="H">sv.push_back({1, 2, 3});</p>
<p class="H">for(auto i : sv) // invokes std::vector&lt;int&gt; copy constructor</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;for(auto j : i)</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DUMP(j);</p>
<p class="A">&nbsp;</p>
<p class="F">That said, in certain cases it is simpler to have default copy instead of explicit <span class="G">clone</span>. You can easily achieve that using <span class="G">WithDeepCopy</span> template:</p>
<p class="A">&nbsp;</p>
<p class="H">WithDeepCopy&lt;Vector&lt;int&gt;&gt; v2;</p>
<p class="H">&nbsp;</p>
<p class="H">v2 = v;</p>
<p class="H">&nbsp;</p>
<p class="H">DUMP(v);</p>
<p class="H">DUMP(v2);</p>
<p class="A">&nbsp;</p>
<p class="I">v = [1, 2]</p>
<p class="I">v2 = [1, 2]</p>
<p class="A">&nbsp;</p>
<hr><p id="Section_3_4" class="E">3.4 Client types in U++ containers</p>
<p class="F">So far we were using int as type of elements. In order to store client defined types into the <span class="G">Vector</span> (and the Vector <a href="topic://Core/src/Overview$en-us">flavor</a>) the type must satisfy <a href="topic://Core/src/Moveable$en-us">moveable</a> requirement - in short, it must not contain back-pointers nor virtual methods. Type must be marked as <span class="O">moveable</span> in order to define interface contract using <span class="G">Moveable</span> <a href="https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern">CRTP idiom</a>:</p>
<p class="A">&nbsp;</p>
<p class="H">struct Distribution : Moveable&lt;Distribution&gt; {</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;String &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;text;</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;Vector&lt;int&gt; data;</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;String ToString() const { return text + &quot;: &quot; + AsString(data); }</p>
<p class="H">};</p>
<p class="A">&nbsp;</p>
<p class="F">Now to add <span class="G">Distribution</span> elements you cannot use <span class="G">Vector::Add(const T&amp;)</span>, because it requires elements to have default deep-copy constructor - and <span class="G">Distribution does not have one, as </span>Vector&lt;int&gt;` has default pick-constructor, so Distribution itself has pick-constructor. It would no be a good idea either, because deep-copy would involve expensive copying of inner Vector.</p>
<p class="F">Instead, Add without parameters has to be used - it default constructs (that is cheap) element in Vector and returns reference to it:</p>
<p class="A">&nbsp;</p>
<p class="H">Vector&lt;Distribution&gt; dist;</p>
<p class="H">for(int n = 5; n &lt;= 10; n++) {</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;Distribution&amp; d = dist.Add();</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;d.text &lt;&lt; &quot;Test &quot; &lt;&lt; n;</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;for(int i = 0; i &lt; 10000; i++)</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d.data.At(Random(n), 0)++;</p>
<p class="H">}</p>
<p class="H">&nbsp;</p>
<p class="H">DUMPC(dist);</p>
<p class="A">&nbsp;</p>
<p class="I">dist:</p>
<p class="I">&nbsp;&nbsp;&nbsp;&nbsp;[0] = Test 5: [2006, 2009, 2025, 1958, 2002]</p>
<p class="I">&nbsp;&nbsp;&nbsp;&nbsp;[1] = Test 6: [1691, 1660, 1665, 1664, 1633, 1687]</p>
<p class="I">&nbsp;&nbsp;&nbsp;&nbsp;[2] = Test 7: [1433, 1400, 1413, 1426, 1429, 1476, 1423]</p>
<p class="I">&nbsp;&nbsp;&nbsp;&nbsp;[3] = Test 8: [1266, 1272, 1139, 1267, 1263, 1233, 1289, 1271]</p>
<p class="I">&nbsp;&nbsp;&nbsp;&nbsp;[4] = Test 9: [1076, 1127, 1132, 1129, 1155, 1089, 1045, 1114, 1133]</p>
<p class="I">&nbsp;&nbsp;&nbsp;&nbsp;[5] = Test 10: [998, 995, 1012, 973, 1003, 1000, 1009, 1010, 991, 1009]</p>
<p class="A">&nbsp;</p>
<p class="F">Another possibility is to use <span class="G">Vector::Add(T&amp;&amp;)</span> method, which uses pick-constructor instead of deep-copy constructor. E.g. <span class="G">Distribution</span> elements might be generated by some function:</p>
<p class="A">&nbsp;</p>
<p class="H">Distribution CreateDist(int n);</p>
<p class="A">&nbsp;</p>
<p class="F">and code for adding such elements to Vector then looks like:</p>
<p class="A">&nbsp;</p>
<p class="H">for(n = 5; n &lt;= 10; n++)</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;dist.Add(CreateDist(n));</p>
<p class="A">&nbsp;</p>
<p class="F">alternatively, you can use default-constructed variant too</p>
<p class="A">&nbsp;</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;dist.Add() = CreateDist();</p>
<p class="A">&nbsp;</p>
<hr><p id="Section_3_5" class="E">3.5 Array flavor</p>
<p class="F">If elements are not <span class="G">Moveable</span> and therefore cannot be stored in <span class="G">Vector</span> flavor, they can still be stored in <span class="G">Array</span> flavor. Another reason for using Array is the need for referencing elements - Array flavor never invalidates references or pointers to them. Finally, if sizeof(T) is large (say more than 100-200 bytes), using Array might be better from performance perspective.</p>
<p class="F">Example of elements that cannot be stored in Vector flavor are standard library objects like <span class="G">std::string</span> (because obviously, standard library knows nothing about U++ Moveable concept):</p>
<p class="A">&nbsp;</p>
<p class="H">Array&lt;std::string&gt; as;</p>
<p class="H">for(int i = 0; i &lt; 4; i++)</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;as.Add(&quot;Test&quot;);</p>
<p class="H">&nbsp;</p>
<p class="H">for(auto s : as)</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;DUMP(s.c_str());</p>
<p class="A">&nbsp;</p>
<p class="I">s.c_str() = Test</p>
<p class="I">s.c_str() = Test</p>
<p class="I">s.c_str() = Test</p>
<p class="I">s.c_str() = Test</p>
<p class="A">&nbsp;</p>
<hr><p id="Section_3_6" class="L"><span class="M">3.6 Polymorphic </span>Array</p>
<p class="F"><span class="G">Array</span> can even be used for storing polymorphic elements:</p>
<p class="A">&nbsp;</p>
<p class="H">struct Number {</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;virtual double Get() const = 0;</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;String ToString() const { return AsString(Get()); }</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;virtual ~Number() {}</p>
<p class="H">};</p>
<p class="H">&nbsp;</p>
<p class="H">struct Integer : public Number {</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;int n;</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;virtual double Get() const { return n; }</p>
<p class="H">};</p>
<p class="H">&nbsp;</p>
<p class="H">struct Double : public Number {</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;double n;</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;virtual double Get() const { return n; }</p>
<p class="H">};</p>
<p class="A">&nbsp;</p>
<p class="F">To add such derived types to <span class="G">Array</span>, you can best use in-place creation with <span class="G">Create</span> method:</p>
<p class="A">&nbsp;</p>
<p class="H">Array&lt;Number&gt; num;</p>
<p class="H">num.Create&lt;Double&gt;().n = 15.5;</p>
<p class="H">num.Create&lt;Integer&gt;().n = 3;</p>
<p class="H">&nbsp;</p>
<p class="H">DUMP(num);</p>
<p class="A">&nbsp;</p>
<p class="I">num = [15.5, 3]</p>
<p class="A">&nbsp;</p>
<p class="F">Alternatively, you can use <span class="G">Add(T *)</span> method and provide a pointer to the newly created instance on the heap (<span class="G">Add</span> returns a reference to the instance):</p>
<p class="A">&nbsp;</p>
<p class="H">Double *nd = new Double;</p>
<p class="H">nd-&gt;n = 1.1;</p>
<p class="H">num.Add(nd);</p>
<p class="H">&nbsp;</p>
<p class="H">DUMP(num);</p>
<p class="A">&nbsp;</p>
<p class="I">num = [15.5, 3, 1.1]</p>
<p class="A">&nbsp;</p>
<p class="F">Array takes ownership of heap object and deletes it as appropriate. We recommend to use this variant only if in-place creation with <span class="G">Create</span> is not possible.</p>
<p class="F">It is OK do directly apply U++ algorithms on <span class="G">Array</span> (the most stringent requirement of any of basic algorithms is that there is <span class="G">IterSwap</span> provided for container iterators and that is specialized for <span class="G">Array</span> iterators):</p>
<p class="A">&nbsp;</p>
<p class="H">Sort(num, [](const Number&amp; a, const Number&amp; b) { return a.Get() &lt; b.Get(); });</p>
<p class="H">&nbsp;</p>
<p class="H">DUMP(num);</p>
<p class="A">&nbsp;</p>
<p class="I">num = [1.1, 3, 15.5]</p>
<p class="A">&nbsp;</p>
<hr><p id="Section_3_7" class="E">3.7 Bidirectional containers</p>
<p class="F"><span class="G">Vector</span> and <span class="G">Array</span> containers allow fast adding and removing elements at the end of sequence. Sometimes, same is needed at begin of sequence too (usually to support FIFO queues). <span class="G">BiVector</span> and <span class="G">BiArray</span> are optimal for this scenario:</p>
<p class="A">&nbsp;</p>
<p class="H">BiVector&lt;int&gt; n;</p>
<p class="H">n.AddHead(1);</p>
<p class="H">n.AddTail(2);</p>
<p class="H">n.AddHead(3);</p>
<p class="H">n.AddTail(4);</p>
<p class="H">DUMP(n);</p>
<p class="A">&nbsp;</p>
<p class="I">n = [3, 1, 2, 4]</p>
<p class="A">&nbsp;</p>
<p class="A">&nbsp;</p>
<p class="H">n.DropHead();</p>
<p class="H">DUMP(n);</p>
<p class="A">&nbsp;</p>
<p class="I">n = [1, 2, 4]</p>
<p class="A">&nbsp;</p>
<p class="A">&nbsp;</p>
<p class="H">n.DropTail();</p>
<p class="H">DUMP(n);</p>
<p class="A">&nbsp;</p>
<p class="I">n = [1, 2]</p>
<p class="A">&nbsp;</p>
<p class="A">&nbsp;</p>
<p class="H">struct Val {</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;virtual String ToString() const = 0;</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;virtual ~Val() {}</p>
<p class="H">};</p>
<p class="H">&nbsp;</p>
<p class="H">struct Number : Val {</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;int n;</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;virtual String ToString() const { return AsString(n); }</p>
<p class="H">};</p>
<p class="H">&nbsp;</p>
<p class="H">struct Text : Val {</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;String s;</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;virtual String ToString() const { return s; }</p>
<p class="H">};</p>
<p class="H">&nbsp;</p>
<p class="H">BiArray&lt;Val&gt; num;</p>
<p class="H">num.CreateHead&lt;Number&gt;().n = 3;</p>
<p class="H">num.CreateTail&lt;Text&gt;().s = &quot;Hello&quot;;</p>
<p class="H">num.CreateHead&lt;Text&gt;().s = &quot;World&quot;;</p>
<p class="H">num.CreateTail&lt;Number&gt;().n = 2;</p>
<p class="H">&nbsp;</p>
<p class="H">DUMP(num);</p>
<p class="A">&nbsp;</p>
<p class="I">num = [World, 3, Hello, 2]</p>
<p class="A">&nbsp;</p>
<hr><p id="Section_3_8" class="L"><span class="M">3.8 </span>Index</p>
<p class="F"><span class="G">Index</span> is the the foundation of all U++ associative operations and is one of defining features of U++.</p>
<p class="F"><span class="G">Index</span> is a container very similar to the plain <span class="G">Vector</span> (it is random access array of elements with fast addition at the end) with one additional feature - it is able to fast retrieve position of element with required value using <span class="G">Find</span> method:</p>
<p class="A">&nbsp;</p>
<p class="H">Index&lt;String&gt; ndx;</p>
<p class="H">ndx.Add(&quot;alfa&quot;);</p>
<p class="H">ndx.Add(&quot;beta&quot;);</p>
<p class="H">ndx.Add(&quot;gamma&quot;);</p>
<p class="H">ndx.Add(&quot;delta&quot;);</p>
<p class="H">ndx.Add(&quot;kappa&quot;);</p>
<p class="H">&nbsp;</p>
<p class="H">DUMP(ndx);</p>
<p class="H">DUMP(ndx.Find(&quot;beta&quot;));</p>
<p class="A">&nbsp;</p>
<p class="I">ndx = [alfa, beta, gamma, delta, kappa]</p>
<p class="I">ndx.Find(&quot;beta&quot;) = 1</p>
<p class="A">&nbsp;</p>
<p class="F">If element is not present in <span class="G">Index</span>, <span class="G">Find</span> returns a negative value:</p>
<p class="A">&nbsp;</p>
<p class="H">DUMP(ndx.Find(&quot;something&quot;));</p>
<p class="A">&nbsp;</p>
<p class="I">ndx.Find(&quot;something&quot;) = -1</p>
<p class="A">&nbsp;</p>
<p class="F">Any element can be replaced using <span class="G">Set</span> method:</p>
<p class="A">&nbsp;</p>
<p class="H">ndx.Set(1, &quot;alfa&quot;);</p>
<p class="H">&nbsp;</p>
<p class="H">DUMP(ndx);</p>
<p class="A">&nbsp;</p>
<p class="I">ndx = [alfa, alfa, gamma, delta, kappa]</p>
<p class="A">&nbsp;</p>
<p class="F">If there are more elements with the same value, they can be iterated using <span class="G">FindNext</span> method:</p>
<p class="A">&nbsp;</p>
<p class="H">int fi = ndx.Find(&quot;alfa&quot;);</p>
<p class="H">while(fi &gt;= 0) {</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;DUMP(fi);</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;fi = ndx.FindNext(fi);</p>
<p class="H">}</p>
<p class="A">&nbsp;</p>
<p class="I">fi = 0</p>
<p class="I">fi = 1</p>
<p class="A">&nbsp;</p>
<p class="F"><span class="G">FindAdd</span> method retrieves position of element like <span class="G">Find</span>, but if element is not present in <span class="G">Index</span>, it is added:</p>
<p class="A">&nbsp;</p>
<p class="H">DUMP(ndx.FindAdd(&quot;one&quot;));</p>
<p class="H">DUMP(ndx.FindAdd(&quot;two&quot;));</p>
<p class="H">DUMP(ndx.FindAdd(&quot;three&quot;));</p>
<p class="H">DUMP(ndx.FindAdd(&quot;two&quot;));</p>
<p class="H">DUMP(ndx.FindAdd(&quot;three&quot;));</p>
<p class="H">DUMP(ndx.FindAdd(&quot;one&quot;));</p>
<p class="A">&nbsp;</p>
<p class="I">ndx.FindAdd(&quot;one&quot;) = 5</p>
<p class="I">ndx.FindAdd(&quot;two&quot;) = 6</p>
<p class="I">ndx.FindAdd(&quot;three&quot;) = 7</p>
<p class="I">ndx.FindAdd(&quot;two&quot;) = 6</p>
<p class="I">ndx.FindAdd(&quot;three&quot;) = 7</p>
<p class="I">ndx.FindAdd(&quot;one&quot;) = 5</p>
<p class="A">&nbsp;</p>
<p class="F">Removing elements from random access sequence tends to be expensive, that is why rather than remove, <span class="G">Index</span> supports <span class="G">Unlink</span> and <span class="G">UnlinkKey</span> operations, which retain the element in <span class="G">Index</span> but make it invisible for <span class="G">Find</span> operation:</p>
<p class="A">&nbsp;</p>
<p class="H">ndx.Unlink(2);</p>
<p class="H">ndx.UnlinkKey(&quot;kappa&quot;);</p>
<p class="H">&nbsp;</p>
<p class="H">DUMP(ndx.Find(ndx[2]));</p>
<p class="H">DUMP(ndx.Find(&quot;kappa&quot;));</p>
<p class="A">&nbsp;</p>
<p class="I">ndx.Find(ndx[2]) = -1</p>
<p class="I">ndx.Find(&quot;kappa&quot;) = -1</p>
<p class="A">&nbsp;</p>
<p class="F">You can test whether element at given position is unlinked using <span class="G">IsUnlinked</span> method</p>
<p class="A">&nbsp;</p>
<p class="H">DUMP(ndx.IsUnlinked(1));</p>
<p class="H">DUMP(ndx.IsUnlinked(2));</p>
<p class="A">&nbsp;</p>
<p class="I">ndx.IsUnlinked(1) = false</p>
<p class="I">ndx.IsUnlinked(2) = true</p>
<p class="A">&nbsp;</p>
<p class="F">Unlinked positions can be reused by <span class="G">Put</span> method:</p>
<p class="A">&nbsp;</p>
<p class="H">ndx.Put(&quot;foo&quot;);</p>
<p class="H">&nbsp;</p>
<p class="H">DUMP(ndx);</p>
<p class="H">DUMP(ndx.Find(&quot;foo&quot;));</p>
<p class="A">&nbsp;</p>
<p class="I">ndx = [alfa, alfa, gamma, delta, foo, one, two, three]</p>
<p class="I">ndx.Find(&quot;foo&quot;) = 4</p>
<p class="A">&nbsp;</p>
<p class="F">You can also remove all unlinked elements from <span class="G">Index</span> using <span class="G">Sweep</span> method:</p>
<p class="A">&nbsp;</p>
<p class="H">ndx.Sweep();</p>
<p class="H">&nbsp;</p>
<p class="H">DUMP(ndx);</p>
<p class="A">&nbsp;</p>
<p class="I">ndx = [alfa, alfa, delta, foo, one, two, three]</p>
<p class="A">&nbsp;</p>
<p class="F">Operations directly removing or inserting elements of Index are expensive, but available too:</p>
<p class="A">&nbsp;</p>
<p class="H">ndx.Remove(1);</p>
<p class="H">&nbsp;</p>
<p class="H">DUMP(ndx);</p>
<p class="A">&nbsp;</p>
<p class="I">ndx = [alfa, delta, foo, one, two, three]</p>
<p class="A">&nbsp;</p>
<p class="A">&nbsp;</p>
<p class="H">ndx.RemoveKey(&quot;two&quot;);</p>
<p class="H">&nbsp;</p>
<p class="H">DUMP(ndx);</p>
<p class="A">&nbsp;</p>
<p class="I">ndx = [alfa, delta, foo, one, three]</p>
<p class="A">&nbsp;</p>
<p class="A">&nbsp;</p>
<p class="H">ndx.Insert(0, &quot;insert&quot;);</p>
<p class="H">&nbsp;</p>
<p class="H">DUMP(ndx);</p>
<p class="A">&nbsp;</p>
<p class="I">ndx = [insert, alfa, delta, foo, one, three]</p>
<p class="A">&nbsp;</p>
<p class="F">PickKeys operation allows you to obtain Vector of elements of Index in low constant time operation (while destroying source Index)</p>
<p class="A">&nbsp;</p>
<p class="H">Vector&lt;String&gt; d = ndx.PickKeys();</p>
<p class="H">&nbsp;</p>
<p class="H">DUMP(d);</p>
<p class="A">&nbsp;</p>
<p class="I">d = [insert, alfa, delta, foo, one, three]</p>
<p class="A">&nbsp;</p>
<p class="F">Pick-assigning <span class="G">Vector</span> to <span class="G">Index</span> is supported as well:</p>
<p class="A">&nbsp;</p>
<p class="H">d[0] = &quot;test&quot;;</p>
<p class="H">&nbsp;</p>
<p class="H">ndx = pick(d);</p>
<p class="H">&nbsp;</p>
<p class="H">DUMP(ndx);</p>
<p class="A">&nbsp;</p>
<p class="I">ndx = [test, alfa, delta, foo, one, three]</p>
<p class="A">&nbsp;</p>
<hr><p id="Section_3_9" class="E">3.9 Index and client types</p>
<p class="F">In order to store elements to <span class="G">Index</span>, they type must be <span class="G">Moveable</span>, have deep copy and defined the <span class="G">operator==</span> and a <span class="G">GetHashValue</span> function or method to compute the hash code. It is recommended to use <span class="G">CombineHash</span> to combine hash values of types that already provide <span class="G">GetHashValue</span>:</p>
<p class="A">&nbsp;</p>
<p class="H">struct Person : Moveable&lt;Person&gt; {</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;String name;</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;String surname;</p>
<p class="H">&nbsp;</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;unsigned GetHashValue() const &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ return CombineHash(name, surname); }</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;bool operator==(const Person&amp; b) const { return name == b.name &amp;&amp; surname == b.surname; }</p>
<p class="H">&nbsp;</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;Person(String name, String surname) : name(name), surname(surname) {}</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;Person() {}</p>
<p class="H">};</p>
<p class="H">&nbsp;</p>
<p class="H">Index&lt;Person&gt; p;</p>
<p class="H">p.Add(Person(&quot;John&quot;, &quot;Smith&quot;));</p>
<p class="H">p.Add(Person(&quot;Paul&quot;, &quot;Carpenter&quot;));</p>
<p class="H">p.Add(Person(&quot;Carl&quot;, &quot;Engles&quot;));</p>
<p class="H">&nbsp;</p>
<p class="H">DUMP(p.Find(Person(&quot;Paul&quot;, &quot;Carpenter&quot;)));</p>
<p class="A">&nbsp;</p>
<p class="I">p.Find(Person(&quot;Paul&quot;, &quot;Carpenter&quot;)) = 1</p>
<p class="A">&nbsp;</p>
<hr><p id="Section_3_10" class="L"><span class="M">3.10 </span>VectorMap<span class="M">, </span>ArrayMap</p>
<p class="F"><span class="G">VectorMap</span> is nothing else than a simple composition of <span class="G">Index</span> of keys and <span class="G">Vector</span> of values. You can use <span class="G">Add</span> methods to put elements into the <span class="G">VectorMap</span>:</p>
<p class="A">&nbsp;</p>
<p class="H">struct Person : Moveable&lt;Person&gt; {</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;String name;</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;String surname;</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;String ToString() const { return String() &lt;&lt; name &lt;&lt; ' ' &lt;&lt; surname; }</p>
<p class="H">&nbsp;</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;Person(String name, String surname) : name(name), surname(surname) {}</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;Person() {}</p>
<p class="H">};</p>
<p class="H">&nbsp;</p>
<p class="H">VectorMap&lt;String, Person&gt; m;</p>
<p class="H">&nbsp;</p>
<p class="H">m.Add(&quot;1&quot;, Person(&quot;John&quot;, &quot;Smith&quot;));</p>
<p class="H">m.Add(&quot;2&quot;, Person(&quot;Carl&quot;, &quot;Engles&quot;));</p>
<p class="H">&nbsp;</p>
<p class="H">Person&amp; p = m.Add(&quot;3&quot;);</p>
<p class="H">p.name = &quot;Paul&quot;;</p>
<p class="H">p.surname = &quot;Carpenter&quot;;</p>
<p class="H">&nbsp;</p>
<p class="H">DUMP(m);</p>
<p class="A">&nbsp;</p>
<p class="I">m = {1: John Smith, 2: Carl Engles, 3: Paul Carpenter}</p>
<p class="A">&nbsp;</p>
<p class="F"><span class="G">VectorMap</span> provides read-only access to its <span class="G">Index</span> of keys and read-write access to its <span class="G">Vector</span> of values:</p>
<p class="A">&nbsp;</p>
<p class="H">DUMP(m.GetKeys());</p>
<p class="H">DUMP(m.GetValues());</p>
<p class="A">&nbsp;</p>
<p class="I">m.GetKeys() = [1, 2, 3]</p>
<p class="I">m.GetValues() = [John Smith, Carl Engles, Paul Carpenter]</p>
<p class="A">&nbsp;</p>
<p class="A">&nbsp;</p>
<p class="H">m.GetValues()[2].name = &quot;Peter&quot;;</p>
<p class="H">&nbsp;</p>
<p class="H">DUMP(m);</p>
<p class="A">&nbsp;</p>
<p class="I">m = {1: John Smith, 2: Carl Engles, 3: Peter Carpenter}</p>
<p class="A">&nbsp;</p>
<p class="F">You can use indices to iterate <span class="G">VectorMap</span> contents:</p>
<p class="A">&nbsp;</p>
<p class="H">for(int i = 0; i &lt; m.GetCount(); i++)</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;LOG(m.GetKey(i) &lt;&lt; &quot;: &quot; &lt;&lt; m[i]);</p>
<p class="A">&nbsp;</p>
<p class="I">1: John Smith</p>
<p class="I">2: Carl Engles</p>
<p class="I">3: Peter Carpenter</p>
<p class="A">&nbsp;</p>
<p class="F">Standard <span class="G">begin</span> / <span class="G">end</span> pair for <span class="G">VectorMap</span> is the range of just values (internal Vector) - it corresponds with <span class="G">operator[]</span> returning values:</p>
<p class="A">&nbsp;</p>
<p class="H">for(const auto&amp; p : m)</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;DUMP(p);</p>
<p class="A">&nbsp;</p>
<p class="I">p = John Smith</p>
<p class="I">p = Carl Engles</p>
<p class="I">p = Peter Carpenter</p>
<p class="A">&nbsp;</p>
<p class="F">To iterate through keys, you can use <span class="G">begin</span>/`end` of internal <span class="G">Index</span>:</p>
<p class="A">&nbsp;</p>
<p class="H">for(const auto&amp; p : m.GetKeys())</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;DUMP(p);</p>
<p class="A">&nbsp;</p>
<p class="I">p = 1</p>
<p class="I">p = 2</p>
<p class="I">p = 3</p>
<p class="A">&nbsp;</p>
<p class="F">Alternatively, it is possible to create 'projection range' of VectorMap that provides convenient key/value iteration, using <span class="G">operator~</span> (note that is also removes 'unlinked' items, see later):</p>
<p class="A">&nbsp;</p>
<p class="H">for(const auto&amp; e : ~m) {</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;DUMP(e.key);</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;DUMP(e.value);</p>
<p class="H">}</p>
<p class="A">&nbsp;</p>
<p class="I">e.key = 1</p>
<p class="I">e.value = John Smith</p>
<p class="I">e.key = 2</p>
<p class="I">e.value = Carl Engles</p>
<p class="I">e.key = 3</p>
<p class="I">e.value = Peter Carpenter</p>
<p class="A">&nbsp;</p>
<p class="F">Note that the 'projection range' obtained by <span class="G">operator~</span> is temporary value, which means that if mutating operation is required for values, r-value reference has to be used instead of plain reference:</p>
<p class="A">&nbsp;</p>
<p class="H">for(const auto&amp; e : ~m)</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;if(e.key == &quot;2&quot;)</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e.value.surname = &quot;May&quot;;</p>
<p class="H">&nbsp;</p>
<p class="H">DUMP(m);</p>
<p class="A">&nbsp;</p>
<p class="I">m = {1: John Smith, 2: Carl May, 3: Peter Carpenter}</p>
<p class="A">&nbsp;</p>
<p class="F">You can use Find method to retrieve position of element with required key:</p>
<p class="A">&nbsp;</p>
<p class="H">DUMP(m.Find(&quot;2&quot;));</p>
<p class="A">&nbsp;</p>
<p class="I">m.Find(&quot;2&quot;) = 1</p>
<p class="A">&nbsp;</p>
<p class="F">or Get method to retrieve corresponding value:</p>
<p class="A">&nbsp;</p>
<p class="H">DUMP(m.Get(&quot;2&quot;));</p>
<p class="A">&nbsp;</p>
<p class="I">m.Get(&quot;2&quot;) = Carl May</p>
<p class="A">&nbsp;</p>
<p class="F">Passing key not present in <span class="G">VectorMap</span> as <span class="G">Get</span> parameter is undefined behavior (ASSERT fails in debug mode), but there exists two parameter version of <span class="G">Get</span> that returns second parameter if the key is not found in VectorMap:</p>
<p class="A">&nbsp;</p>
<p class="H">DUMP(m.Get(&quot;33&quot;, Person(&quot;unknown&quot;, &quot;person&quot;)));</p>
<p class="A">&nbsp;</p>
<p class="I">m.Get(&quot;33&quot;, Person(&quot;unknown&quot;, &quot;person&quot;)) = unknown person</p>
<p class="A">&nbsp;</p>
<p class="F">As with <span class="G">Index</span>, you can use <span class="G">Unlink</span> to make elements invisible for Find operations:</p>
<p class="A">&nbsp;</p>
<p class="H">m.Unlink(1);</p>
<p class="H">DUMP(m.Find(&quot;2&quot;));</p>
<p class="A">&nbsp;</p>
<p class="I">m.Find(&quot;2&quot;) = -1</p>
<p class="A">&nbsp;</p>
<p class="F"><span class="G">SetKey</span> changes the key of the element:</p>
<p class="A">&nbsp;</p>
<p class="H">m.SetKey(1, &quot;33&quot;);</p>
<p class="H">DUMP(m.Get(&quot;33&quot;, Person(&quot;unknown&quot;, &quot;person&quot;)));</p>
<p class="A">&nbsp;</p>
<p class="I">m.Get(&quot;33&quot;, Person(&quot;unknown&quot;, &quot;person&quot;)) = Carl May</p>
<p class="A">&nbsp;</p>
<p class="F">If there are more elements with the same key in <span class="G">VectorMap</span>, you can iterate them using <span class="G">FindNext</span> method:</p>
<p class="A">&nbsp;</p>
<p class="H">m.Add(&quot;33&quot;, Person(&quot;Peter&quot;, &quot;Pan&quot;));</p>
<p class="H">&nbsp;</p>
<p class="H">int q = m.Find(&quot;33&quot;);</p>
<p class="H">while(q &gt;= 0) {</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;DUMP(m[q]);</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;q = m.FindNext(q);</p>
<p class="H">}</p>
<p class="A">&nbsp;</p>
<p class="I">m[q] = Carl May</p>
<p class="I">m[q] = Peter Pan</p>
<p class="A">&nbsp;</p>
<p class="F">Unlinked positions can be 'reused' using Put method:</p>
<p class="A">&nbsp;</p>
<p class="H">m.UnlinkKey(&quot;33&quot;);</p>
<p class="H">m.Put(&quot;22&quot;, Person(&quot;Ali&quot;, &quot;Baba&quot;));</p>
<p class="H">m.Put(&quot;44&quot;, Person(&quot;Ivan&quot;, &quot;Wilks&quot;));</p>
<p class="H">&nbsp;</p>
<p class="H">DUMP(m);</p>
<p class="A">&nbsp;</p>
<p class="I">m = {1: John Smith, 44: Ivan Wilks, 3: Peter Carpenter, 22: Ali Baba}</p>
<p class="A">&nbsp;</p>
<p class="F"><span class="G">PickValues</span> / <span class="G">PickIndex</span> / <span class="G">PickKeys</span> / pick internal <span class="G">Vector</span> / <span class="G">Index</span> / <span class="G">Vector</span> of <span class="G">Index</span>:</p>
<p class="A">&nbsp;</p>
<p class="H">Vector&lt;Person&gt; ps = m.PickValues();</p>
<p class="H">Vector&lt;String&gt; ks = m.PickKeys();</p>
<p class="H">&nbsp;</p>
<p class="H">DUMP(ps);</p>
<p class="H">DUMP(ks);</p>
<p class="H">DUMP(m);</p>
<p class="A">&nbsp;</p>
<p class="I">ps = [John Smith, Ivan Wilks, Peter Carpenter, Ali Baba]</p>
<p class="I">ks = [1, 44, 3, 22]</p>
<p class="I">m = {}</p>
<p class="A">&nbsp;</p>
<p class="F"><span class="G">VectorMap</span> pick constructor to create map by picking:</p>
<p class="A">&nbsp;</p>
<p class="H">ks[0] = &quot;Changed key&quot;;</p>
<p class="H">&nbsp;</p>
<p class="H">m = VectorMap&lt;String, Person&gt;(pick(ks), pick(ps));</p>
<p class="H">&nbsp;</p>
<p class="H">DUMP(m);</p>
<p class="A">&nbsp;</p>
<p class="I">m = {Changed key: John Smith, 44: Ivan Wilks, 3: Peter Carpenter, 22: Ali Baba}</p>
<p class="A">&nbsp;</p>
<p class="F"><span class="G">ArrayMap</span> is composition of Index and Array, for cases where Array is better fit for value type (e.g. they are polymorphic):</p>
<p class="A">&nbsp;</p>
<p class="H">ArrayMap&lt;String, Person&gt; am;</p>
<p class="H">am.Create&lt;Person&gt;(&quot;key&quot;, &quot;new&quot;, &quot;person&quot;);</p>
<p class="H">&nbsp;</p>
<p class="H">DUMP(am);</p>
<p class="A">&nbsp;</p>
<p class="I">am = {key: new person}</p>
<p class="A">&nbsp;</p>
<hr><p id="Section_3_11" class="L"><span class="M">3.11 </span>One</p>
<p class="F"><span class="G">One</span> is a container that can store none or one element of T or derived from T. It is functionally quite similar to <span class="G">std::unique_ptr</span>, but has some convenient features.</p>
<p class="A">&nbsp;</p>
<p class="H">struct Base {</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;virtual String Get() = 0;</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;virtual ~Base() {}</p>
<p class="H">};</p>
<p class="H">&nbsp;</p>
<p class="H">struct Derived1 : Base {</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;virtual String Get() { return &quot;Derived1&quot;; }</p>
<p class="H">};</p>
<p class="H">&nbsp;</p>
<p class="H">struct Derived2 : Base {</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;virtual String Get() { return &quot;Derived2&quot;; }</p>
<p class="H">};</p>
<p class="H">&nbsp;</p>
<p class="H">One&lt;Base&gt; s;</p>
<p class="A">&nbsp;</p>
<p class="F"><span class="G">operator bool</span> of one returns true if it contains an element:</p>
<p class="A">&nbsp;</p>
<p class="H">DUMP((bool)s);</p>
<p class="A">&nbsp;</p>
<p class="I">(bool)s = false</p>
<p class="A">&nbsp;</p>
<p class="A">&nbsp;</p>
<p class="H">s.Create&lt;Derived1&gt;();</p>
<p class="H">DUMP((bool)s);</p>
<p class="H">DUMP(s-&gt;Get());</p>
<p class="A">&nbsp;</p>
<p class="I">(bool)s = true</p>
<p class="I">s-&gt;Get() = Derived1</p>
<p class="A">&nbsp;</p>
<p class="F">You can use <span class="G">Is</span> to check if certain type is currently stored in <span class="G">One</span>:</p>
<p class="A">&nbsp;</p>
<p class="H">DUMP(s.Is&lt;Derived1&gt;());</p>
<p class="H">DUMP(s.Is&lt;Base&gt;());</p>
<p class="H">DUMP(s.Is&lt;Derived2&gt;());</p>
<p class="A">&nbsp;</p>
<p class="I">s.Is&lt;Derived1&gt;() = true</p>
<p class="I">s.Is&lt;Base&gt;() = true</p>
<p class="I">s.Is&lt;Derived2&gt;() = false</p>
<p class="A">&nbsp;</p>
<p class="F">To get a pointer to the contained instance, use <span class="G">operator~</span>:</p>
<p class="A">&nbsp;</p>
<p class="H">Base *b = ~s;</p>
<p class="H">DUMP(b-&gt;Get());</p>
<p class="A">&nbsp;</p>
<p class="I">b-&gt;Get() = Derived1</p>
<p class="A">&nbsp;</p>
<p class="F">Clear method removes the element from One:</p>
<p class="A">&nbsp;</p>
<p class="H">s.Clear();</p>
<p class="H">DUMP((bool)s);</p>
<p class="A">&nbsp;</p>
<p class="I">(bool)s = false</p>
<p class="A">&nbsp;</p>
<p class="F">Helper function MakeOne derived from One can be used to create contained element:</p>
<p class="A">&nbsp;</p>
<p class="H">s = MakeOne&lt;Derived1&gt;();</p>
<p class="H">DUMP(s-&gt;Get());</p>
<p class="A">&nbsp;</p>
<p class="I">s-&gt;Get() = Derived1</p>
<p class="A">&nbsp;</p>
<p class="A">&nbsp;</p>
<p class="H">auto t = pick(s);</p>
<p class="H">DUMP(t-&gt;Get());</p>
<p class="A">&nbsp;</p>
<p class="I">t-&gt;Get() = Derived1</p>
<p class="A">&nbsp;</p>
<hr><p id="Section_3_12" class="L"><span class="M">3.12 </span>Any</p>
<p class="F"><span class="G">Any</span> is a container that can contain none or one element of <span class="O">any</span> type. <span class="G">Any::Is</span> method matches exact type ignoring class hierarchies (unlike <span class="G">One::Is</span>). You can use <span class="G">Get</span> to retrieve a reference to the instance stored:</p>
<p class="A">&nbsp;</p>
<p class="H">for(int pass = 0; pass &lt; 2; pass++) {</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;Any x;</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;if(pass)</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x.Create&lt;String&gt;() = &quot;Hello!&quot;;</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;else</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x.Create&lt;Color&gt;() = Blue();</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;if(x.Is&lt;String&gt;())</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LOG(&quot;Any is now String: &quot; &lt;&lt; x.Get&lt;String&gt;());</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;if(x.Is&lt;Color&gt;())</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LOG(&quot;Any is now Color: &quot; &lt;&lt; x.Get&lt;Color&gt;());</p>
<p class="H">}</p>
<p class="A">&nbsp;</p>
<p class="I">Any is now Color: Color(0, 0, 128)</p>
<p class="I">Any is now String: Hello!</p>
<p class="A">&nbsp;</p>
<hr><p id="Section_3_13" class="L"><span class="M">3.13 </span>InVector<span class="M">, </span>InArray</p>
<p class="F"><span class="G">InVector</span> and <span class="G">InArray</span> are container types quite similar to <span class="G">Vector</span>/`Array`, but they trade the speed of <span class="G">operator[]</span> with the ability to insert or remove elements at any position quickly. You can expect <span class="G">operator[]</span> to be about 10 times slower than in Vector (but that is still quite fast), while <span class="G">Insert</span> at any position scales well up to hundreds of megabytes of data (e.g. <span class="G">InVector</span> containing 100M of String elements is handled without problems).</p>
<p class="A">&nbsp;</p>
<p class="H">InVector&lt;int&gt; v;</p>
<p class="H">for(int i = 0; i &lt; 1000000; i++)</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;v.Add(i);</p>
<p class="H">v.Insert(0, -1); // This is fast</p>
<p class="A">&nbsp;</p>
<p class="F">While the interface of <span class="G">InVector</span>/`InArray` is almost identical to <span class="G">Vector</span>/`Array`, <span class="G">InVector</span>/`InArray` in addition implements <span class="G">FindLowerBound</span>/`FindUpperBound` methods - while normal generic range algorithms work, it is possible to provide <span class="G">InVector</span>/`InArray` specific optimizations that basically match the performace of <span class="G">Find*Bound</span> on simple <span class="G">Vector</span>.</p>
<p class="A">&nbsp;</p>
<p class="H">DUMP(v.FindLowerBound(55));</p>
<p class="A">&nbsp;</p>
<p class="I">v.FindLowerBound(55) = 56</p>
<p class="A">&nbsp;</p>
<hr><p id="Section_3_14" class="L"><span class="M">3.14 </span>SortedIndex<span class="M">, </span>SortedVectorMap<span class="M">, </span>SortedArrayMap</p>
<p class="F"><span class="G">SortedIndex</span> is similar to regular <span class="G">Index</span>, but keeps its elements in sorted order (sorting predicate is a template parameter, defaults to <span class="G">StdLess</span>). Implementation is using <span class="G">InVector</span>, so it works fine even with very large number of elements (performance is similar to tree based <span class="G">std::set</span>). Unlike <span class="G">Index</span>, <span class="G">SortedIndex</span> provides lower/upper bounds searches, so it allows range search.</p>
<p class="A">&nbsp;</p>
<p class="H">SortedIndex&lt;int&gt; x;</p>
<p class="H">x.Add(5);</p>
<p class="H">x.Add(3);</p>
<p class="H">x.Add(7);</p>
<p class="H">x.Add(1);</p>
<p class="H">&nbsp;</p>
<p class="H">DUMPC(x);</p>
<p class="H">DUMP(x.Find(3));</p>
<p class="H">DUMP(x.Find(3));</p>
<p class="H">DUMP(x.FindLowerBound(3));</p>
<p class="H">DUMP(x.FindUpperBound(6));</p>
<p class="A">&nbsp;</p>
<p class="I">x:</p>
<p class="I">&nbsp;&nbsp;&nbsp;&nbsp;[0] = 1</p>
<p class="I">&nbsp;&nbsp;&nbsp;&nbsp;[1] = 3</p>
<p class="I">&nbsp;&nbsp;&nbsp;&nbsp;[2] = 5</p>
<p class="I">&nbsp;&nbsp;&nbsp;&nbsp;[3] = 7</p>
<p class="I">x.Find(3) = 1</p>
<p class="I">x.Find(3) = 1</p>
<p class="I">x.FindLowerBound(3) = 1</p>
<p class="I">x.FindUpperBound(6) = 3</p>
<p class="A">&nbsp;</p>
<p class="F"><span class="G">SortedVectorMap</span> and <span class="G">SortedArrayMap</span> are then <span class="G">SortedIndex</span> based equivalents to <span class="G">VectorMap</span>/`ArrayMap`:</p>
<p class="A">&nbsp;</p>
<p class="H">SortedVectorMap&lt;String, int&gt; m;</p>
<p class="H">m.Add(&quot;zulu&quot;, 11);</p>
<p class="H">m.Add(&quot;frank&quot;, 12);</p>
<p class="H">m.Add(&quot;alfa&quot;, 13);</p>
<p class="H">&nbsp;</p>
<p class="H">DUMPM(m);</p>
<p class="H">DUMP(m.Get(&quot;zulu&quot;));</p>
<p class="A">&nbsp;</p>
<p class="I">m:</p>
<p class="I">&nbsp;&nbsp;&nbsp;&nbsp;[0] = (alfa) 13</p>
<p class="I">&nbsp;&nbsp;&nbsp;&nbsp;[1] = (frank) 12</p>
<p class="I">&nbsp;&nbsp;&nbsp;&nbsp;[2] = (zulu) 11</p>
<p class="I">m.Get(&quot;zulu&quot;) = 11</p>
<p class="A">&nbsp;</p>
<hr><p id="Section_3_15" class="E">3.15 Tuples</p>
<p class="F">Template class <span class="G">Tuple</span> allows combining 2-4 values with different types. These are principally similar to <span class="G">std::tuple</span>, with some advantages. Unlike <span class="G">std::tuple</span>, individual elements are directly accessible as member variables <span class="G">a</span>..`d`, <span class="G">Tuple</span> supports persistent storage patterns (<span class="G">Serialize</span>, <span class="G">Jsonize</span>, <span class="G">Xmlize</span>), hash code (<span class="G">GetHashValue</span>), conversion to <span class="G">String</span> and Value conversions.</p>
<p class="F">To create a <span class="G">Tuple</span> value, you can use the <span class="G">MakeTuple</span> function.</p>
<p class="A">&nbsp;</p>
<p class="H">Tuple&lt;int, String, String&gt; x = MakeTuple(12, &quot;hello&quot;, &quot;world&quot;);</p>
<p class="A">&nbsp;</p>
<p class="F">Individual values are accessible as members <span class="G">a</span> .. <span class="G">d</span>:</p>
<p class="A">&nbsp;</p>
<p class="H">DUMP(x.a);</p>
<p class="H">DUMP(x.b);</p>
<p class="H">DUMP(x.c);</p>
<p class="A">&nbsp;</p>
<p class="I">x.a = 12</p>
<p class="I">x.b = hello</p>
<p class="I">x.c = world</p>
<p class="A">&nbsp;</p>
<p class="F">Or using <span class="G">Get</span>:</p>
<p class="A">&nbsp;</p>
<p class="H">DUMP(x.Get&lt;1&gt;());</p>
<p class="H">DUMP(x.Get&lt;int&gt;());</p>
<p class="A">&nbsp;</p>
<p class="I">x.Get&lt;1&gt;() = hello</p>
<p class="I">x.Get&lt;int&gt;() = 12</p>
<p class="A">&nbsp;</p>
<p class="F">As long as all individual types have conversion to <span class="G">String</span> (<span class="G">AsString</span>), the tuple also has such conversion and thus can e.g. be easily logged:</p>
<p class="A">&nbsp;</p>
<p class="H">DUMP(x);</p>
<p class="A">&nbsp;</p>
<p class="I">x = (12, hello, world)</p>
<p class="A">&nbsp;</p>
<p class="F">As long as individual types have defined <span class="G">GetHashValue</span>, so does <span class="G">Tuple</span>:</p>
<p class="A">&nbsp;</p>
<p class="H">DUMP(GetHashValue(x));</p>
<p class="A">&nbsp;</p>
<p class="I">GetHashValue(x) = 2465159845</p>
<p class="A">&nbsp;</p>
<p class="F">As long as individual types have defined <span class="G">operator==</span>, <span class="G">Tuple</span> has defined <span class="G">operator==</span> and <span class="G">operator!=</span>:</p>
<p class="A">&nbsp;</p>
<p class="H">Tuple&lt;int, String, String&gt; y = x;</p>
<p class="H">DUMP(x == y);</p>
<p class="H">DUMP(x != y);</p>
<p class="H">y.a++;</p>
<p class="H">DUMP(x == y);</p>
<p class="H">DUMP(x != y);</p>
<p class="A">&nbsp;</p>
<p class="I">x == y = true</p>
<p class="I">x != y = false</p>
<p class="I">x == y = false</p>
<p class="I">x != y = true</p>
<p class="A">&nbsp;</p>
<p class="F">As long as all individual types have defined <span class="G">SgnCompare</span>, Tuple has SgnCompare, Compare method and operators &lt;, &lt;=, &gt;, &gt;=:</p>
<p class="A">&nbsp;</p>
<p class="H">DUMP(x.Compare(y));</p>
<p class="H">DUMP(SgnCompare(x, y));</p>
<p class="H">DUMP(x &lt; y);</p>
<p class="A">&nbsp;</p>
<p class="I">x.Compare(y) = -1</p>
<p class="I">SgnCompare(x, y) = -1</p>
<p class="I">x &lt; y = true</p>
<p class="A">&nbsp;</p>
<p class="F">GetCount returns the width of <span class="G">Tuple</span>:</p>
<p class="A">&nbsp;</p>
<p class="H">DUMP(x.GetCount());</p>
<p class="A">&nbsp;</p>
<p class="I">x.GetCount() = 3</p>
<p class="A">&nbsp;</p>
<p class="F">Elements that are directly convertible with <span class="G">Value</span> can be 'Get'/'Set':</p>
<p class="A">&nbsp;</p>
<p class="H">for(int i = 0; i &lt; x.GetCount(); i++)</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;DUMP(x.Get(i));</p>
<p class="A">&nbsp;</p>
<p class="I">x.Get(i) = 12</p>
<p class="I">x.Get(i) = hello</p>
<p class="I">x.Get(i) = world</p>
<p class="A">&nbsp;</p>
<p class="A">&nbsp;</p>
<p class="H">x.Set(1, &quot;Hi&quot;);</p>
<p class="H">DUMP(x);</p>
<p class="A">&nbsp;</p>
<p class="I">x = (12, Hi, world)</p>
<p class="A">&nbsp;</p>
<p class="F">As long as all individual types are convertible with <span class="G">Value</span>, you can convert Tuple to <span class="G">ValueArray</span> and back:</p>
<p class="A">&nbsp;</p>
<p class="H">ValueArray va = x.GetArray();</p>
<p class="H">DUMP(va);</p>
<p class="H">&nbsp;</p>
<p class="H">va.Set(2, &quot;Joe&quot;);</p>
<p class="H">x.SetArray(va);</p>
<p class="A">&nbsp;</p>
<p class="I">va = [12, Hi, world]</p>
<p class="A">&nbsp;</p>
<p class="F">It is OK to assign <span class="G">Tuple</span> to <span class="G">Tuple</span> with different individual types, as long as types are directly convertible:</p>
<p class="A">&nbsp;</p>
<p class="H">Tuple&lt;double, String, String&gt; d = x;</p>
<p class="H">DUMP(d);</p>
<p class="A">&nbsp;</p>
<p class="I">d = (12, Hi, Joe)</p>
<p class="A">&nbsp;</p>
<p class="F">Tie can be used to assign tuple to l-values:</p>
<p class="A">&nbsp;</p>
<p class="H">int i;</p>
<p class="H">String s1, s2;</p>
<p class="H">&nbsp;</p>
<p class="H">Tie(i, s1, s2) = x;</p>
<p class="H">&nbsp;</p>
<p class="H">DUMP(i);</p>
<p class="H">DUMP(s1);</p>
<p class="H">DUMP(s2);</p>
<p class="A">&nbsp;</p>
<p class="I">i = 12</p>
<p class="I">s1 = Hi</p>
<p class="I">s2 = Joe</p>
<p class="A">&nbsp;</p>
<p class="F">U++ Tuples are carefully designed as POD type, which allows POD arrays to be intialized with classic C style:</p>
<p class="A">&nbsp;</p>
<p class="H">static Tuple2&lt;int, const char *&gt; map[] = {</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;{ 1, &quot;one&quot; },</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;{ 2, &quot;one&quot; },</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;{ 3, &quot;one&quot; },</p>
<p class="H">};</p>
<p class="A">&nbsp;</p>
<p class="F">Simple FindTuple template function is provided to search for tuple based on the first value (<span class="G">a</span>) (linear O(n) search):</p>
<p class="A">&nbsp;</p>
<p class="H">DUMP(FindTuple(map, __countof(map), 3)-&gt;b);</p>
<p class="A">&nbsp;</p>
<p class="I">FindTuple(map, __countof(map), 3)-&gt;b = one</p>
<p class="A">&nbsp;</p>
<hr><p id="Chapter_4" class="D">4. Ranges and algorithms</p>
<p id="Section_4_1" class="E">4.1 Range</p>
<p class="F">Unlike STL, which interface algorithms with data using <span class="G">begin</span> / <span class="G">end</span> pair, U++ algorithms usually work on <span class="O">Ranges</span>. Range is an object that has <span class="G">begin</span> / <span class="G">end</span> methods providing random access to elements (all U++ containers are random access), <span class="G">operator[]</span> and <span class="G">GetCount</span> method.</p>
<p class="F">Obviously, U++ containers are ranges:</p>
<p class="A">&nbsp;</p>
<p class="H">Vector&lt;int&gt; x = { 1, 2, 3, 4, 5, 1, 2, 3, 4 };</p>
<p class="H">&nbsp;</p>
<p class="H">DUMP(FindIndex(x, 2)); // FindIndex is a trivial algorithm that does linear search</p>
<p class="A">&nbsp;</p>
<p class="I">FindIndex(x, 2) = 1</p>
<p class="A">&nbsp;</p>
<p class="F">If you want the algorithm to run on part of container only, you can use <span class="G">SubRange</span> instance:</p>
<p class="A">&nbsp;</p>
<p class="H">DUMP(SubRange(x, 3, 6));</p>
<p class="H">DUMP(FindIndex(SubRange(x, 3, 6), 4));</p>
<p class="A">&nbsp;</p>
<p class="I">SubRange(x, 3, 6) = [4, 5, 1, 2, 3, 4]</p>
<p class="I">FindIndex(SubRange(x, 3, 6), 4) = 0</p>
<p class="A">&nbsp;</p>
<p class="F">As a side-job, SubRange can also be created from 'begin' / 'end' pair, thus e.g. allowing algorithms to work on C arrays:</p>
<p class="A">&nbsp;</p>
<p class="H">int a[] = { 1, 22, 4, 2, 8 };</p>
<p class="H">&nbsp;</p>
<p class="H">auto ar = SubRange(std::begin(a), std::end(a));</p>
<p class="H">&nbsp;</p>
<p class="H">DUMP(ar);</p>
<p class="A">&nbsp;</p>
<p class="I">ar = [1, 22, 4, 2, 8]</p>
<p class="A">&nbsp;</p>
<p class="A">&nbsp;</p>
<p class="H">Sort(ar);</p>
<p class="H">DUMP(ar);</p>
<p class="A">&nbsp;</p>
<p class="I">ar = [1, 2, 4, 8, 22]</p>
<p class="A">&nbsp;</p>
<p class="F">There are some macro aliases that make type management of ranges easier:</p>
<p class="A">&nbsp;</p>
<p class="H">DUMP(typeid(ValueTypeOf&lt;decltype(x)&gt;).name());</p>
<p class="H">DUMP(typeid(ValueTypeOf&lt;decltype(SubRange(x, 1, 1))&gt;).name());</p>
<p class="H">DUMP(typeid(IteratorOf&lt;decltype(x)&gt;).name());</p>
<p class="H">DUMP(typeid(ConstIteratorOf&lt;decltype(SubRange(x, 1, 1))&gt;).name());</p>
<p class="H">DUMP(typeid(SubRangeOf&lt;Vector&lt;int&gt;&gt;).name());</p>
<p class="A">&nbsp;</p>
<p class="I">typeid(ValueTypeOf&lt;decltype(x)&gt;).name() = i</p>
<p class="I">typeid(ValueTypeOf&lt;decltype(SubRange(x, 1, 1))&gt;).name() = i</p>
<p class="I">typeid(IteratorOf&lt;decltype(x)&gt;).name() = Pi</p>
<p class="I">typeid(ConstIteratorOf&lt;decltype(SubRange(x, 1, 1))&gt;).name() = Pi</p>
<p class="I">typeid(SubRangeOf&lt;Vector&lt;int&gt;&gt;).name() = N3Upp13SubRangeClassIPiEE</p>
<p class="A">&nbsp;</p>
<p class="F">While containers themselves and SubRange are the two most common range types, U++ has two special ranges. <span class="G">ConstRange</span> simply provides the range of single value:</p>
<p class="A">&nbsp;</p>
<p class="H">DUMP(ConstRange(1, 10));</p>
<p class="A">&nbsp;</p>
<p class="I">ConstRange(1, 10) = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]</p>
<p class="A">&nbsp;</p>
<p class="F"><span class="G">ReverseRange</span> reverses the order of elements in the source range:</p>
<p class="A">&nbsp;</p>
<p class="H">Vector&lt;int&gt; v{ 1, 2, 3, 4 };</p>
<p class="H">&nbsp;</p>
<p class="H">DUMP(ReverseRange(v));</p>
<p class="A">&nbsp;</p>
<p class="I">ReverseRange(v) = [4, 3, 2, 1]</p>
<p class="A">&nbsp;</p>
<p class="F"><span class="G">ViewRange</span> picks a source range and <span class="G">Vector</span> of integer indices a provides a view of source range through this <span class="G">Vector</span>:</p>
<p class="A">&nbsp;</p>
<p class="H">Vector&lt;int&gt; h{ 2, 4, 0 };</p>
<p class="H">&nbsp;</p>
<p class="H">DUMP(ViewRange(x, clone(h)));</p>
<p class="A">&nbsp;</p>
<p class="I">ViewRange(x, clone(h)) = [3, 5, 1]</p>
<p class="A">&nbsp;</p>
<p class="A">&nbsp;</p>
<p class="H">Sort(ViewRange(x, clone(h)));</p>
<p class="H">DUMP(ViewRange(x, clone(h)));</p>
<p class="H">DUMP(x);</p>
<p class="A">&nbsp;</p>
<p class="I">ViewRange(x, clone(h)) = [1, 3, 5]</p>
<p class="I">x = [5, 2, 1, 4, 3, 1, 2, 3, 4]</p>
<p class="A">&nbsp;</p>
<p class="F"><span class="G">SortedRange</span> returns range sorted by predicate (default is std::less):</p>
<p class="A">&nbsp;</p>
<p class="H">DUMP(SortedRange(x));</p>
<p class="A">&nbsp;</p>
<p class="I">SortedRange(x) = [1, 1, 2, 2, 3, 3, 4, 4, 5]</p>
<p class="A">&nbsp;</p>
<p class="F">Finally <span class="G">FilterRange</span> creates a subrange of elements satisfying certain condition:</p>
<p class="A">&nbsp;</p>
<p class="H">DUMP(FilterRange(x, [](int x) { return x &gt; 3; }));</p>
<p class="A">&nbsp;</p>
<p class="I">FilterRange(x, [](int x) { return x &gt; 3; }) = [5, 4, 4]</p>
<p class="A">&nbsp;</p>
<p class="F">Various Range functions can be combined to produce complex results:</p>
<p class="A">&nbsp;</p>
<p class="H">DUMP(ReverseRange(FilterRange(x, [](int x) { return x &lt; 4; })));</p>
<p class="A">&nbsp;</p>
<p class="I">ReverseRange(FilterRange(x, [](int x) { return x &lt; 4; })) = [3, 2, 1, 3, 1, 2]</p>
<p class="A">&nbsp;</p>
<hr><p id="Section_4_2" class="E">4.2 Algorithms</p>
<p class="F">In principle, is is possible to apply C++ standard library algorithms on U++ containers or ranges.</p>
<p class="F">U++ algorithms are tuned for U++ approach - they work on ranges and they prefer indices. Sometimes, U++ algorithm will perform faster with U++ types than standard library algorithm.</p>
<p class="F"><span class="G">FindIndex</span> performs linear search to find element with given value and returns its index or -1 if not found:</p>
<p class="A">&nbsp;</p>
<p class="H">Vector&lt;int&gt; data { 5, 3, 7, 9, 3, 4, 2 };</p>
<p class="H">&nbsp;</p>
<p class="H">&nbsp;</p>
<p class="H">DUMP(FindIndex(data, 3));</p>
<p class="H">DUMP(FindIndex(data, 6));</p>
<p class="A">&nbsp;</p>
<p class="I">FindIndex(data, 3) = 1</p>
<p class="I">FindIndex(data, 6) = -1</p>
<p class="A">&nbsp;</p>
<p class="F"><span class="G">SubRange</span> can be used to apply algorithm on subrange of container:</p>
<p class="A">&nbsp;</p>
<p class="H">DUMP(FindIndex(SubRange(data, 2, data.GetCount() - 2), 3));</p>
<p class="A">&nbsp;</p>
<p class="I">FindIndex(SubRange(data, 2, data.GetCount() - 2), 3) = 2</p>
<p class="A">&nbsp;</p>
<p class="F"><span class="G">FindMin</span> and <span class="G">FindMax</span> return the index of minimal / maximal element:</p>
<p class="A">&nbsp;</p>
<p class="H">DUMP(FindMin(data));</p>
<p class="H">DUMP(FindMax(data));</p>
<p class="A">&nbsp;</p>
<p class="I">FindMin(data) = 6</p>
<p class="I">FindMax(data) = 3</p>
<p class="A">&nbsp;</p>
<p class="F"><span class="G">Min</span> and <span class="G">Max</span> return the <span class="O">value</span> of minimal / maximal element:</p>
<p class="A">&nbsp;</p>
<p class="H">DUMP(Min(data));</p>
<p class="H">DUMP(Max(data));</p>
<p class="A">&nbsp;</p>
<p class="I">Min(data) = 2</p>
<p class="I">Max(data) = 9</p>
<p class="A">&nbsp;</p>
<p class="F">If the range is empty, <span class="G">Min</span> and <span class="G">Max</span> are undefined (ASSERT fails in debug mode), unless the value is specified as second parameter to be used in this case:</p>
<p class="A">&nbsp;</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;Vector&lt;int&gt; empty;</p>
<p class="H">//&nbsp;&nbsp;&nbsp;&nbsp;DUMP(Min(empty)); // This is undefined (fails in ASSERT)</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;DUMP(Min(empty, -99999));</p>
<p class="A">&nbsp;</p>
<p class="I">Min(empty, -99999) = -99999</p>
<p class="A">&nbsp;</p>
<p class="F"><span class="G">Count</span> returns the number of elements with specified value, <span class="G">CountIf</span> the number of elements that satisfy predicate:</p>
<p class="A">&nbsp;</p>
<p class="H">DUMP(Count(data, 11));</p>
<p class="H">DUMP(CountIf(data, [=](int c) { return c &gt;= 5; }));</p>
<p class="A">&nbsp;</p>
<p class="I">Count(data, 11) = 0</p>
<p class="I">CountIf(data, [=](int c) { return c &gt;= 5; }) = 3</p>
<p class="A">&nbsp;</p>
<p class="F"><span class="G">Sum</span> return the sum of all elements in range:</p>
<p class="A">&nbsp;</p>
<p class="H">DUMP(Sum(data));</p>
<p class="A">&nbsp;</p>
<p class="I">Sum(data) = 33</p>
<p class="A">&nbsp;</p>
<p class="F">Sorted containers can be searched with bisection. U++ provides usual upper / lower bound algorithms. <span class="G">FindBinary</span> returns the index of element with given value or -1 if not found:</p>
<p class="A">&nbsp;</p>
<p class="H">data = { 5, 7, 9, &nbsp;9, 14, 20, 23, 50 };</p>
<p class="H"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 0 &nbsp;1 &nbsp;2 &nbsp;&nbsp;3 &nbsp;&nbsp;4 &nbsp;&nbsp;5 &nbsp;&nbsp;6 &nbsp;&nbsp;7</p>
<p class="H">DUMP(FindLowerBound(data, 9));</p>
<p class="H">DUMP(FindUpperBound(data, 9));</p>
<p class="H">DUMP(FindBinary(data, 9));</p>
<p class="H">DUMP(FindLowerBound(data, 10));</p>
<p class="H">DUMP(FindUpperBound(data, 10));</p>
<p class="H">DUMP(FindBinary(data, 10));</p>
<p class="A">&nbsp;</p>
<p class="I">FindLowerBound(data, 9) = 2</p>
<p class="I">FindUpperBound(data, 9) = 4</p>
<p class="I">FindBinary(data, 9) = 2</p>
<p class="I">FindLowerBound(data, 10) = 4</p>
<p class="I">FindUpperBound(data, 10) = 4</p>
<p class="I">FindBinary(data, 10) = -1</p>
<p class="A">&nbsp;</p>
<hr><p id="Section_4_3" class="E">4.3 Sorting</p>
<p class="F">Unsurprisingly, <span class="G">Sort</span> function sorts a range. You can specify sorting predicate, default is <span class="G">operator&lt;</span>:</p>
<p class="A">&nbsp;</p>
<p class="H">Vector&lt;String&gt; x { &quot;1&quot;, &quot;2&quot;, &quot;10&quot; };</p>
<p class="H">&nbsp;</p>
<p class="H">Sort(x);</p>
<p class="H">&nbsp;</p>
<p class="H">DUMP(x);</p>
<p class="A">&nbsp;</p>
<p class="I">x = [1, 10, 2]</p>
<p class="A">&nbsp;</p>
<p class="A">&nbsp;</p>
<p class="H">Sort(x, [](const String&amp; a, const String&amp; b) { return atoi(a) &lt; atoi(b); });</p>
<p class="H">&nbsp;</p>
<p class="H">DUMP(x);</p>
<p class="A">&nbsp;</p>
<p class="I">x = [1, 2, 10]</p>
<p class="A">&nbsp;</p>
<p class="F"><span class="G">IndexSort</span> is sort variant that is able to sort two ranges (like <span class="G">Vector</span> or <span class="G">Array</span>) of the same size, based on values in the first range:</p>
<p class="A">&nbsp;</p>
<p class="H">Vector&lt;int&gt; a { 5, 10, 2, 9, 7, 3 };</p>
<p class="H">Vector&lt;String&gt; b { &quot;five&quot;, &quot;ten&quot;, &quot;two&quot;, &quot;nine&quot;, &quot;seven&quot;, &quot;three&quot; };</p>
<p class="H">&nbsp;</p>
<p class="H">IndexSort(a, b);</p>
<p class="H">&nbsp;</p>
<p class="H">DUMP(a);</p>
<p class="H">DUMP(b);</p>
<p class="A">&nbsp;</p>
<p class="I">a = [2, 3, 5, 7, 9, 10]</p>
<p class="I">b = [two, three, five, seven, nine, ten]</p>
<p class="A">&nbsp;</p>
<p class="A">&nbsp;</p>
<p class="H">IndexSort(b, a);</p>
<p class="H">&nbsp;</p>
<p class="H">DUMP(a);</p>
<p class="H">DUMP(b);</p>
<p class="A">&nbsp;</p>
<p class="I">a = [5, 9, 7, 10, 3, 2]</p>
<p class="I">b = [five, nine, seven, ten, three, two]</p>
<p class="A">&nbsp;</p>
<p class="F">There are also <span class="G">IndexSort2</span> and <span class="G">IndexSort3</span> variants that sort 2 or 3 dependent ranges.</p>
<p class="F">Sometimes, instead of sorting items in the range, it is useful to know the order of items as sorted, using <span class="G">GetSortOrder</span>:</p>
<p class="A">&nbsp;</p>
<p class="H">Vector&lt;int&gt; o = GetSortOrder(a);</p>
<p class="H">&nbsp;</p>
<p class="H">DUMP(o);</p>
<p class="A">&nbsp;</p>
<p class="I">o = [5, 4, 0, 2, 1, 3]</p>
<p class="A">&nbsp;</p>
<p class="F">Normal <span class="G">Sort</span> is not stable - equal items can appear in sorted range in random order. If maintaining original order of equal items is important, use <span class="G">StableSort</span> variant (with performance penalty):</p>
<p class="A">&nbsp;</p>
<p class="H">Vector&lt;Point&gt; t { Point(10, 10), Point(7, 1), Point(7, 2), Point(7, 3), Point(1, 0) };</p>
<p class="H">StableSort(t, [](const Point&amp; a, const Point&amp; b) { return a.x &lt; b.x; });</p>
<p class="H">&nbsp;</p>
<p class="H">DUMP(t);</p>
<p class="A">&nbsp;</p>
<p class="I">t = [[1, 0], [7, 1], [7, 2], [7, 3], [10, 10]]</p>
<p class="A">&nbsp;</p>
<p class="F">All sorting algorithms have they 'Stable' variant, so there is <span class="G">StableIndexSort</span>, <span class="G">GetStableSortOrder</span> etc...</p>
<hr><p id="Chapter_5" class="D">5. Value</p>
<p id="Section_5_1" class="E">5.1 Value</p>
<p class="F">Value is sort of equivalent of polymorphic data types from scripting languages like Python or JavaSript. <span class="G">Value</span> can represent values of concrete types, some types also have extended interoperability with <span class="G">Value</span> and it is then possible to e.g. compare <span class="G">Value</span>s containing such types against each other or serialize them for persistent storage.</p>
<p class="F">Usually, Value compatible types define typecast operator to <span class="G">Value</span> and constructor from <span class="G">Value</span>, so that interaction is for the most part seamless:</p>
<p class="A">&nbsp;</p>
<p class="H">Value a = 1;</p>
<p class="H">Value b = 2.34;</p>
<p class="H">Value c = GetSysDate();</p>
<p class="H">Value d = &quot;hello&quot;;</p>
<p class="H">&nbsp;</p>
<p class="H">DUMP(a);</p>
<p class="H">DUMP(b);</p>
<p class="H">DUMP(c);</p>
<p class="H">DUMP(d);</p>
<p class="H">&nbsp;</p>
<p class="H">int x = a;</p>
<p class="H">double y = b;</p>
<p class="H">Date z = c;</p>
<p class="H">String s = d;</p>
<p class="H">&nbsp;</p>
<p class="H">DUMP(x);</p>
<p class="H">DUMP(y);</p>
<p class="H">DUMP(z);</p>
<p class="H">DUMP(s);</p>
<p class="A">&nbsp;</p>
<p class="I">a = 1</p>
<p class="I">b = 2.34</p>
<p class="I">c = 07/21/2021</p>
<p class="I">d = hello</p>
<p class="I">x = 1</p>
<p class="I">y = 2.34</p>
<p class="I">z = 07/21/2021</p>
<p class="I">s = hello</p>
<p class="A">&nbsp;</p>
<p class="F">As for primitive types, Value seamlessly works with <span class="G">int</span>, <span class="G">int64</span>, <span class="G">bool</span> and <span class="G">double</span>. Casting <span class="G">Value</span> to a type that it does not contain throws an exception:</p>
<p class="A">&nbsp;</p>
<p class="H">try {</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;s = a;</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;DUMP(s); // we never get here....</p>
<p class="H">}</p>
<p class="H">catch(ValueTypeError) {</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;LOG(&quot;Failed Value conversion&quot;);</p>
<p class="H">}</p>
<p class="A">&nbsp;</p>
<p class="I">Failed Value conversion</p>
<p class="A">&nbsp;</p>
<p class="F">However, conversion between related types is possible (as long as it is supported by these types):</p>
<p class="A">&nbsp;</p>
<p class="H">double i = a;</p>
<p class="H">int j = b;</p>
<p class="H">Time k = c;</p>
<p class="H">WString t = d;</p>
<p class="H">&nbsp;</p>
<p class="H">DUMP(i);</p>
<p class="H">DUMP(j);</p>
<p class="H">DUMP(k);</p>
<p class="H">DUMP(t);</p>
<p class="A">&nbsp;</p>
<p class="I">i = 1</p>
<p class="I">j = 2</p>
<p class="I">k = 07/21/2021 00:00:00</p>
<p class="I">t = hello</p>
<p class="A">&nbsp;</p>
<p class="F">To determine type of value stored in <span class="G">Value</span>, you can use <span class="G">Is</span> method:</p>
<p class="A">&nbsp;</p>
<p class="H">DUMP(a.Is&lt;int&gt;());</p>
<p class="H">DUMP(a.Is&lt;double&gt;());</p>
<p class="H">DUMP(b.Is&lt;double&gt;());</p>
<p class="H">DUMP(c.Is&lt;int&gt;());</p>
<p class="H">DUMP(c.Is&lt;Date&gt;());</p>
<p class="H">DUMP(d.Is&lt;String&gt;());</p>
<p class="A">&nbsp;</p>
<p class="I">a.Is&lt;int&gt;() = true</p>
<p class="I">a.Is&lt;double&gt;() = false</p>
<p class="I">b.Is&lt;double&gt;() = true</p>
<p class="I">c.Is&lt;int&gt;() = false</p>
<p class="I">c.Is&lt;Date&gt;() = true</p>
<p class="I">d.Is&lt;String&gt;() = true</p>
<p class="A">&nbsp;</p>
<p class="F">Note that Is tests for absolute type match, not for compatible types. For that reason, for widely used compatible types helper functions are defined:</p>
<p class="A">&nbsp;</p>
<p class="H">DUMP(IsNumber(a));</p>
<p class="H">DUMP(IsNumber(b));</p>
<p class="H">DUMP(IsDateTime(c));</p>
<p class="H">DUMP(IsString(d));</p>
<p class="A">&nbsp;</p>
<p class="I">IsNumber(a) = true</p>
<p class="I">IsNumber(b) = true</p>
<p class="I">IsDateTime(c) = true</p>
<p class="I">IsString(d) = true</p>
<p class="A">&nbsp;</p>
<hr><p id="Section_5_2" class="L"><span class="M">5.2 </span>Null</p>
<p class="F">U++ defines a special <span class="G">Null</span> constant to represent an empty value. This constant is convertible to many value types including primitive types <span class="G">double</span>, <span class="G">int</span> and <span class="G">int64</span> (defined as lowest number the type can represent). If type supports ordering (&lt;, &gt;), all values of the type are greater than Null value. To test whether a value is empty, use <span class="G">IsNull</span> function.</p>
<p class="A">&nbsp;</p>
<p class="H">int x = Null;</p>
<p class="H">int y = 120;</p>
<p class="H">Date d = Null;</p>
<p class="H">Date e = GetSysDate();</p>
<p class="H">&nbsp;</p>
<p class="H">DUMP(x);</p>
<p class="H">DUMP(y);</p>
<p class="H">DUMP(d);</p>
<p class="H">DUMP(e &gt; d);</p>
<p class="A">&nbsp;</p>
<p class="I">x = </p>
<p class="I">y = 120</p>
<p class="I">d = </p>
<p class="I">e &gt; d = true</p>
<p class="A">&nbsp;</p>
<p class="F"><span class="G">Null</span> is the only instance of <span class="G">Nuller</span> type. Assigning <span class="G">Null</span> to primitive types is achieved by cast operators of <span class="G">Nuller</span>, other types can do it using constructor from <span class="G">Nuller</span>.</p>
<p class="F">As a special case, if <span class="G">Value</span> contains <span class="G">Null</span>, it is convertible to any value type that can contain <span class="G">Null</span>:</p>
<p class="A">&nbsp;</p>
<p class="H">Value v = x; // x is int</p>
<p class="H">e = v; // e is Date, but v is Null, so Null is assigned to e</p>
<p class="H">&nbsp;</p>
<p class="H">DUMP(IsNull(e));</p>
<p class="A">&nbsp;</p>
<p class="I">IsNull(e) = true</p>
<p class="A">&nbsp;</p>
<p class="F">Function <span class="G">Nvl</span> is U++ analog of well known SQL function coalesce (ifnull, Nvl), which returns the first non-null argument (or <span class="G">Null</span> if all are <span class="G">Null</span>).</p>
<p class="A">&nbsp;</p>
<p class="H">int a = Null;</p>
<p class="H">int b = 123;</p>
<p class="H">int c = 1;</p>
<p class="H">&nbsp;</p>
<p class="H">DUMP(Nvl(a, b, c));</p>
<p class="A">&nbsp;</p>
<p class="I">Nvl(a, b, c) = 123</p>
<p class="A">&nbsp;</p>
<hr><p id="Section_5_3" class="L"><span class="M">5.3 Client types and </span>Value<span class="M">, </span>RawValue<span class="M">, </span>RichValue</p>
<p class="F">There are two Value compatibility levels. The simple one, <span class="G">RawValue</span>, has little requirements for the type used - only copy constructor and assignment operator are required (and there are even forms of <span class="G">RawValue</span> that work for types missing these):</p>
<p class="A">&nbsp;</p>
<p class="H">struct RawFoo {</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;String x;</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;// default copy constructor and assignment operator are provided by compiler</p>
<p class="H">};</p>
<p class="A">&nbsp;</p>
<p class="F">To convert such type to <span class="G">Value</span>, use <span class="G">RawToValue</span>:</p>
<p class="A">&nbsp;</p>
<p class="H">RawFoo h;</p>
<p class="H">h.x = &quot;hello&quot;;</p>
<p class="H">Value q = RawToValue(h);</p>
<p class="H">&nbsp;</p>
<p class="H">DUMP(q.Is&lt;RawFoo&gt;());</p>
<p class="A">&nbsp;</p>
<p class="I">q.Is&lt;RawFoo&gt;() = true</p>
<p class="A">&nbsp;</p>
<p class="F">To convert it back, us 'To' templated member function of <span class="G">Value</span>, it returns a constant reference to the value:</p>
<p class="A">&nbsp;</p>
<p class="H">DUMP(q.To&lt;RawFoo&gt;().x);</p>
<p class="A">&nbsp;</p>
<p class="I">q.To&lt;RawFoo&gt;().x = hello</p>
<p class="A">&nbsp;</p>
<p class="F"><span class="G">RichValue</span> level <span class="G">Value</span>s provide more operations for <span class="G">Value</span> - equality test, <span class="G">IsNull</span> test, hashing, conversion to text, serialization (possibly to XML and Json), comparison. In order to make serialization work, type must also have assigned an integer id (client types should use ids in range 10000..20000). Type can provide the support for these operations via template function specializations or (perhaps more convenient) using defined methods and inheriting from <span class="G">ValueType</span> base class template:</p>
<p class="A">&nbsp;</p>
<p class="H">struct Foo : ValueType&lt;Foo, 10010&gt; {</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;int x;</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;Foo(const Nuller&amp;) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ x = Null; }</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;Foo(int x) : x(x) {}</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;Foo() {}</p>
<p class="H">&nbsp;</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;// We provide these methods to allow automatic conversion of Foo to/from Value</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;operator Value() const &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ return RichToValue(*this); }</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;Foo(const Value&amp; v) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ *this = v.Get&lt;Foo&gt;(); }</p>
<p class="H">&nbsp;</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;String ToString() const &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ return AsString(x); }</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;unsigned GetHashValue() const &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ return x; }</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;void Serialize(Stream&amp; s) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ s % x; }</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;bool operator==(const Foo&amp; b) const { return x == b.x; }</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;bool IsNullInstance() const &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ return IsNull(x); }</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;int &nbsp;Compare(const Foo&amp; b) const &nbsp;&nbsp;&nbsp;{ return SgnCompare(x, b.x); }</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;// This type does not define XML nor Json serialization</p>
<p class="H">};</p>
<p class="H">&nbsp;</p>
<p class="H">INITBLOCK { // This has to be at file level scope</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;Value::Register&lt;Foo&gt;(); // need to register value type integer id to allow serialization</p>
<p class="H">}</p>
<p class="H">&nbsp;</p>
<p class="H">Value a = Foo(54321); // uses Foo::operator Value</p>
<p class="H">Value b = Foo(54321);</p>
<p class="H">Value c = Foo(600);</p>
<p class="H">&nbsp;</p>
<p class="H">DUMP(a); // uses Foo::ToString</p>
<p class="H">DUMP(a == b); // uses Foo::operator==</p>
<p class="H">DUMP(a == c);</p>
<p class="H">DUMP(c &lt; a); // uses Foo::Compare</p>
<p class="H">&nbsp;</p>
<p class="H">DUMP(IsNull(a)); // uses Foo::IsNullInstance</p>
<p class="H">&nbsp;</p>
<p class="H">Foo foo = c; // Uses Foo::Foo(const Value&amp;)</p>
<p class="H">DUMP(foo);</p>
<p class="A">&nbsp;</p>
<p class="I">a = 54321</p>
<p class="I">a == b = true</p>
<p class="I">a == c = false</p>
<p class="I">c &lt; a = true</p>
<p class="I">IsNull(a) = false</p>
<p class="I">foo = 600</p>
<p class="A">&nbsp;</p>
<p class="A">&nbsp;</p>
<p class="H">String s = StoreAsString(a); // Uses Foo::Serialize</p>
<p class="H">&nbsp;</p>
<p class="H">Value loaded;</p>
<p class="H">// Using registered (Value::Registered) integer id creates the correct type, then uses</p>
<p class="H">// Foo::Serialize to load the data from the stream</p>
<p class="H">LoadFromString(loaded, s);</p>
<p class="H">&nbsp;</p>
<p class="H">DUMP(loaded);</p>
<p class="A">&nbsp;</p>
<p class="I">loaded = 54321</p>
<p class="A">&nbsp;</p>
<hr><p id="Section_5_4" class="L"><span class="M">5.4 </span>ValueArray<span class="M"> and </span>ValueMap</p>
<p class="F"><span class="G">ValueArray</span> is a type that represents an array of <span class="G">Value</span>s:</p>
<p class="A">&nbsp;</p>
<p class="H">ValueArray va{1, 2, 3};</p>
<p class="H">&nbsp;</p>
<p class="H">DUMP(va);</p>
<p class="A">&nbsp;</p>
<p class="I">va = [1, 2, 3]</p>
<p class="A">&nbsp;</p>
<p class="F">ValueArray can be assigned to Value (and back):</p>
<p class="A">&nbsp;</p>
<p class="H">Value v = va;</p>
<p class="H">&nbsp;</p>
<p class="H">DUMP(v);</p>
<p class="H">DUMP(v.Is&lt;ValueArray&gt;()); // must be exactly ValueArray</p>
<p class="H">DUMP(IsValueArray(v)); // is ValueArray or ValueMap (which is convertible to ValueArray)</p>
<p class="H">&nbsp;</p>
<p class="H">ValueArray va2 = v;</p>
<p class="H">&nbsp;</p>
<p class="H">DUMP(va2);</p>
<p class="A">&nbsp;</p>
<p class="I">v = [1, 2, 3]</p>
<p class="I">v.Is&lt;ValueArray&gt;() = true</p>
<p class="I">IsValueArray(v) = true</p>
<p class="I">va2 = [1, 2, 3]</p>
<p class="A">&nbsp;</p>
<p class="F">Elements can be appended using <span class="G">Add</span> method or <span class="G">operator&lt;&lt;</span>, element at index can be changed with <span class="G">Set</span>:</p>
<p class="A">&nbsp;</p>
<p class="H">va.Add(10);</p>
<p class="H">va &lt;&lt; 20 &lt;&lt; 21;</p>
<p class="H">va.Set(0, 999);</p>
<p class="H">&nbsp;</p>
<p class="H">DUMP(va);</p>
<p class="A">&nbsp;</p>
<p class="I">va = [999, 2, 3, 10, 20, 21]</p>
<p class="A">&nbsp;</p>
<p class="F">Elements can be removed:</p>
<p class="A">&nbsp;</p>
<p class="H">va.Remove(0, 2);</p>
<p class="H">&nbsp;</p>
<p class="H">DUMP(va);</p>
<p class="A">&nbsp;</p>
<p class="I">va = [3, 10, 20, 21]</p>
<p class="A">&nbsp;</p>
<p class="F">and inserted:</p>
<p class="A">&nbsp;</p>
<p class="H">va.Insert(1, v);</p>
<p class="H">&nbsp;</p>
<p class="H">DUMP(va);</p>
<p class="A">&nbsp;</p>
<p class="I">va = [3, 1, 2, 3, 10, 20, 21]</p>
<p class="A">&nbsp;</p>
<p class="F">It is possible to get a reference to element at index, however note that some <a href="srcdoc$Core$ValueReference$en-us.html">special rules</a> apply here:</p>
<p class="A">&nbsp;</p>
<p class="H">va.At(0) = 222;</p>
<p class="H">&nbsp;</p>
<p class="H">DUMP(va);</p>
<p class="A">&nbsp;</p>
<p class="I">va = [222, 1, 2, 3, 10, 20, 21]</p>
<p class="A">&nbsp;</p>
<p class="F">If <span class="G">Value</span> contains <span class="G">ValueArray</span>, <span class="G">Value::GetCount</span> method returns the number of elements in the array (if there is no <span class="G">ValueArray</span> in <span class="G">Value</span>, it returns zero). You can use <span class="G">Value::operator[](int)</span> to get constant reference to <span class="G">ValueArray</span> elements:</p>
<p class="A">&nbsp;</p>
<p class="H">for(int i = 0; i &lt; v.GetCount(); i++)</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;LOG(v[i]);</p>
<p class="A">&nbsp;</p>
<p class="I">1</p>
<p class="I">2</p>
<p class="I">3</p>
<p class="A">&nbsp;</p>
<p class="F">It is even possible to directly add element to <span class="G">Value</span> if it contains <span class="G">ValueArray</span>:</p>
<p class="A">&nbsp;</p>
<p class="H">v.Add(4);</p>
<p class="H">&nbsp;</p>
<p class="H">DUMP(v);</p>
<p class="A">&nbsp;</p>
<p class="I">v = [1, 2, 3, 4]</p>
<p class="A">&nbsp;</p>
<p class="F">Or even get a reference to element at some index (with <a href="srcdoc$Core$ValueReference$en-us.html">special rules</a>):</p>
<p class="A">&nbsp;</p>
<p class="H">v.At(0) = 111;</p>
<p class="H">&nbsp;</p>
<p class="H">DUMP(v);</p>
<p class="A">&nbsp;</p>
<p class="I">v = [111, 2, 3, 4]</p>
<p class="A">&nbsp;</p>
<p class="F"><span class="G">ValueMap</span> can store key - value pairs and retrieve value for key quickly. Note that keys are not limited to <span class="G">String</span>, but can be any <span class="G">Value</span> with <span class="G">operator==</span> and hash code defined.</p>
<p class="F"><span class="G">Add</span> method or <span class="G">operator()</span> add data to <span class="G">ValueMap</span>:</p>
<p class="A">&nbsp;</p>
<p class="H">ValueMap m;</p>
<p class="H">&nbsp;</p>
<p class="H">m.Add(&quot;one&quot;, 1);</p>
<p class="H">m(&quot;two&quot;, 2)(&quot;three&quot;, 3);</p>
<p class="H">&nbsp;</p>
<p class="H">DUMP(m);</p>
<p class="A">&nbsp;</p>
<p class="I">m = { one: 1, two: 2, three: 3 }</p>
<p class="A">&nbsp;</p>
<p class="F"><span class="G">operator[]</span> retrieves the value at the key:</p>
<p class="A">&nbsp;</p>
<p class="H">DUMP(m[&quot;two&quot;]);</p>
<p class="A">&nbsp;</p>
<p class="I">m[&quot;two&quot;] = 2</p>
<p class="A">&nbsp;</p>
<p class="F">When key is not present in the map, <span class="G">operator[]</span> returns void Value (which is also Null):</p>
<p class="A">&nbsp;</p>
<p class="H">DUMP(m[&quot;key&quot;]);</p>
<p class="H">DUMP(m[&quot;key&quot;].IsVoid());</p>
<p class="H">DUMP(IsNull(m[&quot;key&quot;]));</p>
<p class="A">&nbsp;</p>
<p class="I">m[&quot;key&quot;] = </p>
<p class="I">m[&quot;key&quot;].IsVoid() = true</p>
<p class="I">IsNull(m[&quot;key&quot;]) = true</p>
<p class="A">&nbsp;</p>
<p class="F">Just like <span class="G">VectorMap</span>, <span class="G">ValueMap</span> is ordered, so the order of adding pairs to it matters:</p>
<p class="A">&nbsp;</p>
<p class="H">ValueMap m2;</p>
<p class="H">&nbsp;</p>
<p class="H">m2.Add(&quot;two&quot;, 2);</p>
<p class="H">m2(&quot;one&quot;, 1)(&quot;three&quot;, 3);</p>
<p class="H">&nbsp;</p>
<p class="H">DUMP(m2);</p>
<p class="H">DUMP(m == m2); // different order of adding means they are not equal</p>
<p class="A">&nbsp;</p>
<p class="I">m2 = { two: 2, one: 1, three: 3 }</p>
<p class="I">m == m2 = false</p>
<p class="A">&nbsp;</p>
<p class="F">'Unordered' equality test can be done using <span class="G">IsSame</span>:</p>
<p class="A">&nbsp;</p>
<p class="H">DUMP(m.IsSame(m2));</p>
<p class="A">&nbsp;</p>
<p class="I">m.IsSame(m2) = true</p>
<p class="A">&nbsp;</p>
<p class="F">Iterating ValueMap can be achieved with <span class="G">GetCount</span>, <span class="G">GetKey</span> and <span class="G">GetValue</span>:</p>
<p class="A">&nbsp;</p>
<p class="H">for(int i = 0; i &lt; m.GetCount(); i++)</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;LOG(m.GetKey(i) &lt;&lt; &quot; = &quot; &lt;&lt; m.GetValue(i));</p>
<p class="A">&nbsp;</p>
<p class="I">one = 1</p>
<p class="I">two = 2</p>
<p class="I">three = 3</p>
<p class="A">&nbsp;</p>
<p class="F">It is possible to get <span class="G">ValueArray</span> of values:</p>
<p class="A">&nbsp;</p>
<p class="H">LOG(m.GetValues());</p>
<p class="A">&nbsp;</p>
<p class="I">[1, 2, 3]</p>
<p class="A">&nbsp;</p>
<p class="F"><span class="G">GetKeys</span> gets constant reference to <span class="G">Index&lt;Value&gt;</span> of keys:</p>
<p class="A">&nbsp;</p>
<p class="H">LOG(m.GetKeys());</p>
<p class="A">&nbsp;</p>
<p class="I">[one, two, three]</p>
<p class="A">&nbsp;</p>
<p class="F">It is possible to change the value with <span class="G">Set</span>:</p>
<p class="A">&nbsp;</p>
<p class="H">m.Set(&quot;two&quot;, 4);</p>
<p class="H">&nbsp;</p>
<p class="H">DUMP(m);</p>
<p class="A">&nbsp;</p>
<p class="I">m = { one: 1, two: 4, three: 3 }</p>
<p class="A">&nbsp;</p>
<p class="F">Or to change the value of key with <span class="G">SetKey</span>:</p>
<p class="A">&nbsp;</p>
<p class="H">m.SetKey(1, &quot;four&quot;);</p>
<p class="H">&nbsp;</p>
<p class="H">DUMP(m);</p>
<p class="A">&nbsp;</p>
<p class="I">m = { one: 1, four: 4, three: 3 }</p>
<p class="A">&nbsp;</p>
<p class="F">It is possible get a reference of value at given key, (with <a href="srcdoc$Core$ValueReference$en-us.html">special rules</a>) with <span class="G">GetAdd</span> or <span class="G">operator()</span>:</p>
<p class="A">&nbsp;</p>
<p class="H">Value&amp; h = m(&quot;five&quot;);</p>
<p class="H">&nbsp;</p>
<p class="H">h = 5;</p>
<p class="H">&nbsp;</p>
<p class="H">DUMP(m);</p>
<p class="A">&nbsp;</p>
<p class="I">m = { one: 1, four: 4, three: 3, five: 5 }</p>
<p class="A">&nbsp;</p>
<p class="F">When ValueMap is stored into Value, <span class="G">operator[](String)</span> provides access to value at key. Note that this narrows keys to text values:</p>
<p class="A">&nbsp;</p>
<p class="H">v = m;</p>
<p class="H">DUMP(v);</p>
<p class="H">DUMP(v[&quot;five&quot;]);</p>
<p class="A">&nbsp;</p>
<p class="I">v = { one: 1, four: 4, three: 3, five: 5 }</p>
<p class="I">v[&quot;five&quot;] = 5</p>
<p class="A">&nbsp;</p>
<p class="F"><span class="G">Value::GetAdd</span> and <span class="G">Value::operator()</span> provide a reference to value at key, with <a href="srcdoc$Core$ValueReference$en-us.html">special rules</a>:</p>
<p class="A">&nbsp;</p>
<p class="H">v.GetAdd(&quot;newkey&quot;) = &quot;foo&quot;;</p>
<p class="H">v(&quot;five&quot;) = &quot;FIVE&quot;;</p>
<p class="H">&nbsp;</p>
<p class="H">DUMP(v);</p>
<p class="A">&nbsp;</p>
<p class="I">v = { one: 1, four: 4, three: 3, five: FIVE, newkey: foo }</p>
<p class="A">&nbsp;</p>
<p class="F"><span class="G">ValueMap</span> and <span class="G">ValueArray</span> are convertible with each other. When assigning <span class="G">ValueMap</span> to <span class="G">ValueArray</span>, values are simply used:</p>
<p class="A">&nbsp;</p>
<p class="H">ValueArray v2 = m;</p>
<p class="H">&nbsp;</p>
<p class="H">DUMP(v2);</p>
<p class="A">&nbsp;</p>
<p class="I">v2 = [1, 4, 3, 5]</p>
<p class="A">&nbsp;</p>
<p class="F">When assigning <span class="G">ValueArray</span> to <span class="G">ValueMap</span>, keys are set as indices of elements:</p>
<p class="A">&nbsp;</p>
<p class="H">ValueMap m3 = v2;</p>
<p class="H">&nbsp;</p>
<p class="H">DUMP(m3);</p>
<p class="A">&nbsp;</p>
<p class="I">m3 = { 0: 1, 1: 4, 2: 3, 3: 5 }</p>
<p class="A">&nbsp;</p>
<p class="F">With basic <span class="G">Value</span> types <span class="G">int</span>, <span class="G">String</span>, <span class="G">ValueArray</span> and <span class="G">ValueMap</span>, <span class="G">Value</span> can represent JSON:</p>
<p class="A">&nbsp;</p>
<p class="H">Value j = ParseJSON(&quot;{ \&quot;array\&quot; : [ 1, 2, 3 ] }&quot;);</p>
<p class="H">&nbsp;</p>
<p class="H">DUMP(j);</p>
<p class="A">&nbsp;</p>
<p class="I">j = { array: [1, 2, 3] }</p>
<p class="A">&nbsp;</p>
<p class="A">&nbsp;</p>
<p class="H">j(&quot;value&quot;) = m;</p>
<p class="H">&nbsp;</p>
<p class="H">DUMP(AsJSON(j));</p>
<p class="A">&nbsp;</p>
<p class="I">AsJSON(j) = {&quot;array&quot;:[1,2,3],&quot;value&quot;:{&quot;one&quot;:1,&quot;four&quot;:4,&quot;three&quot;:3,&quot;five&quot;:5}}</p>
<p class="A">&nbsp;</p>
<p class="A">&nbsp;</p>
<p class="H">j(&quot;array&quot;).At(1) = ValueMap()(&quot;key&quot;, 1);</p>
<p class="H">&nbsp;</p>
<p class="H">DUMP(AsJSON(j));</p>
<p class="A">&nbsp;</p>
<p class="I">AsJSON(j) = {&quot;array&quot;:[1,{&quot;key&quot;:1},3],&quot;value&quot;:{&quot;one&quot;:1,&quot;four&quot;:4,&quot;three&quot;:3,&quot;five&quot;:5}}</p>
<p class="A">&nbsp;</p>
<hr><p id="Chapter_6" class="D">6. Function and lambdas</p>
<p id="Section_6_1" class="E">6.1 Function</p>
<p class="F">U++ <span class="G">Function</span> is quite similar to <span class="G">std::function</span> - it is a function wrapper that can store/copy/invoke any callable target. There are two important differences. First, invoking empty <span class="G">Function</span> is NOP, if <span class="G">Function</span> has return type <span class="G">T</span>, it returns <span class="G">T()</span>. Second, <span class="G">Function</span> allows effective chaining of callable targets using <span class="G">operator&lt;&lt;</span>, if <span class="G">Function</span> has return type, the return type of last callable appended is used.</p>
<p class="F">Usually, the callable target is C++11 lambda:</p>
<p class="A">&nbsp;</p>
<p class="H">Function&lt;int (int)&gt; fn = [](int n) { LOG(&quot;Called A&quot;); return 3 * n; };</p>
<p class="H">&nbsp;</p>
<p class="H">LOG(&quot;About to call function&quot;);</p>
<p class="H">int n = fn(7);</p>
<p class="H">DUMP(n);</p>
<p class="A">&nbsp;</p>
<p class="I">About to call function</p>
<p class="I">Called A</p>
<p class="I">n = 21</p>
<p class="A">&nbsp;</p>
<p class="F">If you chain another lambda into <span class="G">Function</span>, all are called, but the last one's return value is used:</p>
<p class="A">&nbsp;</p>
<p class="H">fn &lt;&lt; [](int n) { LOG(&quot;Called B&quot;); return n * n; };</p>
<p class="H">LOG(&quot;About to call combined function&quot;);</p>
<p class="H">n = fn(7);</p>
<p class="H">DUMP(n);</p>
<p class="A">&nbsp;</p>
<p class="I">About to call combined function</p>
<p class="I">Called A</p>
<p class="I">Called B</p>
<p class="I">n = 49</p>
<p class="A">&nbsp;</p>
<p class="F">Invoking empty lambda does nothing and returns default constructed return value. This is quite useful for GUI classes, which have a lot of output events represented by <span class="G">Function</span> which are often unassigned to any action.</p>
<p class="A">&nbsp;</p>
<p class="H">fn.Clear();</p>
<p class="H">LOG(&quot;About to call empty function&quot;);</p>
<p class="H">n = fn(7);</p>
<p class="H">DUMP(n);</p>
<p class="A">&nbsp;</p>
<p class="I">About to call empty function</p>
<p class="I">n = 0</p>
<p class="A">&nbsp;</p>
<p class="F">While using <span class="G">Function</span> with lambda expression is the most common, you can use any target that has corresponding <span class="G">operator()</span> defined:</p>
<p class="A">&nbsp;</p>
<p class="H">struct Functor {</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;int operator()(int x) { LOG(&quot;Called Foo&quot;); return x % 2; }</p>
<p class="H">};</p>
<p class="H">&nbsp;</p>
<p class="H">fn = Functor();</p>
<p class="H">LOG(&quot;About to call Functor&quot;);</p>
<p class="H">n = fn(7);</p>
<p class="H">DUMP(n);</p>
<p class="A">&nbsp;</p>
<p class="I">About to call Functor</p>
<p class="I">Called Foo</p>
<p class="I">n = 1</p>
<p class="A">&nbsp;</p>
<p class="F">As <span class="G">Function</span> with <span class="G">void</span> and <span class="G">bool</span> return types are the most frequently used, U++ defines template aliases <span class="G">Event</span>:</p>
<p class="A">&nbsp;</p>
<p class="H">Event&lt;&gt; ev = [] { LOG(&quot;Event invoked&quot;); };</p>
<p class="H">&nbsp;</p>
<p class="H">ev();</p>
<p class="A">&nbsp;</p>
<p class="I">Event invoked</p>
<p class="A">&nbsp;</p>
<p class="F">and <span class="G">Gate</span>:</p>
<p class="A">&nbsp;</p>
<p class="H">Gate&lt;int&gt; gt = [](int x) { LOG(&quot;Gate invoked with &quot; &lt;&lt; x); return x &lt; 10; };</p>
<p class="H">&nbsp;</p>
<p class="H">bool b = gt(9);</p>
<p class="H">DUMP(b);</p>
<p class="H">b = gt(10);</p>
<p class="H">DUMP(b);</p>
<p class="A">&nbsp;</p>
<p class="I">Gate invoked with 9</p>
<p class="I">b = true</p>
<p class="I">Gate invoked with 10</p>
<p class="I">b = false</p>
<p class="A">&nbsp;</p>
<p class="F">Using lambda to define calls to methods with more parameters can be verbose and error-prone. The issue can be simplified by using <span class="G">THISFN</span> macro:</p>
<p class="A">&nbsp;</p>
<p class="H">struct Foo {</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;void Test(int a, const String&amp; b) { LOG(&quot;Foo::Test &quot; &lt;&lt; a &lt;&lt; &quot;, &quot; &lt;&lt; b); }</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;typedef Foo CLASSNAME; // required for THISFN</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;void Do() {</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Event&lt;int, const String&amp;&gt; fn;</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fn = [=](int a, const String&amp; b) { Test(a, b); };</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fn(1, &quot;using lambda&quot;);</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fn = THISFN(Test); // this is functionally equivalent, but less verbose</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fn(2, &quot;using THISFN&quot;);</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p class="H">};</p>
<p class="H">&nbsp;</p>
<p class="H">Foo f;</p>
<p class="H">f.Do();</p>
<p class="A">&nbsp;</p>
<p class="I">Foo::Test 1, using lambda</p>
<p class="I">Foo::Test 2, using THISFN</p>
<p class="A">&nbsp;</p>
<hr><p id="Section_6_2" class="E">6.2 Capturing U++ containers into lambdas</p>
<p class="F">Capturing objects with pick/clone semantics can be achieved using <span class="O">capture with an initializer</span>:</p>
<p class="A">&nbsp;</p>
<p class="H">Vector&lt;int&gt; x{ 1, 2 };</p>
<p class="H">Array&lt;String&gt; y{ &quot;one&quot;, &quot;two&quot; };</p>
<p class="H">Event&lt;&gt; ev = [x = pick(x), y = clone(y)] { DUMP(x); DUMP(y); };</p>
<p class="H">&nbsp;</p>
<p class="H">DUMP(x); // x is picked, so empty</p>
<p class="H">DUMP(y); // y was cloned, so it retains original value</p>
<p class="H">&nbsp;</p>
<p class="H">LOG(&quot;About to invoke event&quot;);</p>
<p class="H">&nbsp;</p>
<p class="H">ev();</p>
<p class="A">&nbsp;</p>
<p class="I">x = []</p>
<p class="I">y = [one, two]</p>
<p class="I">About to invoke event</p>
<p class="I">x = [1, 2]</p>
<p class="I">y = [one, two]</p>
<p class="A">&nbsp;</p>
<hr><p id="Chapter_7" class="D">7. Multithreading</p>
<p id="Section_7_1" class="L"><span class="M">7.1 </span>Thread</p>
<p class="F">Since C++11, there is now a reasonable support for threads in standard library. There are however reasons to use U++ threads instead. One of them is that U++ high performance memory allocator needs a cleanup call at the the thread exit, which is naturally implemented into <span class="G">Upp::Thread</span>. Second 'hard' reason is that Microsoft compiler is using Win32 API function for condition variable that are not available for Windows XP, while U++ has alternative implementation for Windows XP, thus making executable compatible with it.</p>
<p class="F">Then of course we believe U++ multithreading / parallel programming support is easier to use and leads to higher performance...</p>
<p class="F"><span class="G">Thread</span> class can start the thread and allows launching thread to <span class="G">Wait</span> for its completion:</p>
<p class="A">&nbsp;</p>
<p class="H">Thread t;</p>
<p class="H">t.Run([] {</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;for(int i = 0; i &lt; 10; i++) {</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LOG(&quot;In the thread &quot; &lt;&lt; i);</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sleep(100);</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;LOG(&quot;Thread is ending...&quot;);</p>
<p class="H">});</p>
<p class="H">for(int i = 0; i &lt; 5; i++) {</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;LOG(&quot;In the main thread &quot; &lt;&lt; i);</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;Sleep(100);</p>
<p class="H">}</p>
<p class="H">LOG(&quot;About to wait for thread to finish&quot;);</p>
<p class="H">t.Wait();</p>
<p class="H">LOG(&quot;Wait for thread done&quot;);</p>
<p class="A">&nbsp;</p>
<p class="I">In the main thread 0</p>
<p class="I">In the thread 0</p>
<p class="I">In the thread 1</p>
<p class="I">In the main thread 1</p>
<p class="I">In the main thread 2</p>
<p class="I">In the thread 2</p>
<p class="I">In the main thread 3</p>
<p class="I">In the thread 3</p>
<p class="I">In the main thread 4</p>
<p class="I">In the thread 4</p>
<p class="I">About to wait for thread to finish</p>
<p class="I">In the thread 5</p>
<p class="I">In the thread 6</p>
<p class="I">In the thread 7</p>
<p class="I">In the thread 8</p>
<p class="I">In the thread 9</p>
<p class="I">Thread is ending...</p>
<p class="I">Wait for thread done</p>
<p class="A">&nbsp;</p>
<p class="F"><span class="G">Thread</span> destructor calls <span class="G">Detach</span> method with 'disconnects' <span class="G">Thread</span> from the thread. Thread continues running.</p>
<p class="F"><span class="G">Thread::Start</span> static method launches a thread without possibility to wait for its completion; if you need to wait, you have to use some other method:</p>
<p class="A">&nbsp;</p>
<p class="H">bool x = false;</p>
<p class="H">&nbsp;</p>
<p class="H">Thread::Start([&amp;x] { LOG(&quot;In the Started thread&quot;); x = true; });</p>
<p class="H">&nbsp;</p>
<p class="H">LOG(&quot;About to wait for thread to finish&quot;);</p>
<p class="H">while(!x) { Sleep(1); } // Do not do this in real code!</p>
<p class="H">LOG(&quot;Wait for thread done&quot;);</p>
<p class="A">&nbsp;</p>
<p class="I">About to wait for thread to finish</p>
<p class="I">In the Started thread</p>
<p class="I">Wait for thread done</p>
<p class="A">&nbsp;</p>
<p class="F">(method used here is horrible, but should demonstrate the point).</p>
<hr><p id="Section_7_2" class="L"><span class="M">7.2 </span>Mutex</p>
<p class="F">Mutex (&quot;mutual exclusion&quot;) is a well known concept in multithreaded programming: When multiple threads write and read the same data, the access has to be serialized using Mutex. Following invalid code demonstrates why:</p>
<p class="A">&nbsp;</p>
<p class="H">Thread t;</p>
<p class="H">&nbsp;</p>
<p class="H">int sum = 0;</p>
<p class="H">t.Run([&amp;sum] {</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;for(int i = 0; i &lt; 1000000; i++)</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sum++;</p>
<p class="H">});</p>
<p class="H">&nbsp;</p>
<p class="H">for(int i = 0; i &lt; 1000000; i++)</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;sum++;</p>
<p class="H">&nbsp;</p>
<p class="H">t.Wait();</p>
<p class="H">DUMP(sum);</p>
<p class="A">&nbsp;</p>
<p class="I">sum = 1631489</p>
<p class="A">&nbsp;</p>
<p class="F">While the expected value is 2000000, produced value is different. The problem is that both thread read / modify / write <span class="G">sum</span> value without any locking. Using <span class="G">Mutex</span> locks the <span class="G">sum</span> and thus serializes access to it - read / modify / write sequence &nbsp;is now exclusive for the thread that has <span class="G">Mutex</span> locked, this fixing the issue. <span class="G">Mutex</span> can be locked / unlocked with <span class="G">Enter</span> / <span class="G">Leave</span> methods. Alternatively, <span class="G">Mutex::Lock</span> helper class locks <span class="G">Mutex</span> in constructor and unlocks it in destructor:</p>
<p class="A">&nbsp;</p>
<p class="H">Mutex m;</p>
<p class="H">sum = 0;</p>
<p class="H">t.Run([&amp;sum, &amp;m] {</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;for(int i = 0; i &lt; 1000000; i++) {</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m.Enter();</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sum++;</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m.Leave();</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p class="H">});</p>
<p class="H">&nbsp;</p>
<p class="H">for(int i = 0; i &lt; 1000000; i++) {</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;Mutex::Lock __(m); // Lock m till the end of scope</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;sum++;</p>
<p class="H">}</p>
<p class="H">&nbsp;</p>
<p class="H">t.Wait();</p>
<p class="H">DUMP(sum);</p>
<p class="A">&nbsp;</p>
<p class="I">sum = 2000000</p>
<p class="A">&nbsp;</p>
<hr><p id="Section_7_3" class="L"><span class="M">7.3 </span>ConditionVariable</p>
<p class="F"><span class="G">ConditionVariable</span> in general is a synchronization primitive used to block/awaken the thread. <span class="G">ConditionVariable</span> is associated with <span class="G">Mutex</span> used to protect some data; in the thread that is to be blocked, <span class="G">Mutex</span> has to locked; call to <span class="G">Wait</span> atomically unlocks the <span class="G">Mutex</span> and puts the thread to waiting. Another thread then can resume the thread by calling <span class="G">Signal</span>, which also causes <span class="G">Mutex</span> to lock again. Multiple threads can be waiting on single <span class="G">ConditionVariable</span>; <span class="G">Signal</span> resumes single waiting thread, <span class="G">Brodcast</span> resumes all waitng threads.</p>
<p class="A">&nbsp;</p>
<p class="H">bool &nbsp;stop = false;</p>
<p class="H">BiVector&lt;int&gt; data;</p>
<p class="H">Mutex m;</p>
<p class="H">ConditionVariable cv;</p>
<p class="H">&nbsp;</p>
<p class="H">Thread t;</p>
<p class="H">t.Run([&amp;stop, &amp;data, &amp;m, &amp;cv] {</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;Mutex::Lock __(m);</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;for(;;) {</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while(data.GetCount()) {</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int q = data.PopTail();</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LOG(&quot;Data received: &quot; &lt;&lt; q);</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(stop)</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cv.Wait(m);</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p class="H">});</p>
<p class="H">&nbsp;</p>
<p class="H">for(int i = 0; i &lt; 10; i++) {</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;{</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Mutex::Lock __(m);</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data.AddHead(i);</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;cv.Signal();</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;Sleep(1);</p>
<p class="H">}</p>
<p class="H">stop = true;</p>
<p class="H">cv.Signal();</p>
<p class="H">t.Wait();</p>
<p class="A">&nbsp;</p>
<p class="I">Data received: 0</p>
<p class="I">Data received: 1</p>
<p class="I">Data received: 2</p>
<p class="I">Data received: 3</p>
<p class="I">Data received: 4</p>
<p class="I">Data received: 5</p>
<p class="I">Data received: 6</p>
<p class="I">Data received: 7</p>
<p class="I">Data received: 8</p>
<p class="I">Data received: 9</p>
<p class="A">&nbsp;</p>
<p class="F">Important note: rarely thread can be resumed from <span class="G">Wait</span> even if no other called <span class="G">Signal</span>. This is not a bug, but <a href="https://en.wikipedia.org/wiki/Spurious_wakeup">design decision for performance reason</a>. In practice it only means that situation has to be (re)checked after resume.</p>
<hr><p id="Section_7_4" class="L"><span class="M">7.4 </span>CoWork</p>
<p class="F"><span class="G">CoWork</span> is intented to be use when thread are used to speedup code by distributing tasks over multiple CPU cores. <span class="G">CoWork</span> spans a single set of worker threads that exist for the whole duration of program run. <span class="G">CoWork</span> instances then manage assigning jobs to these worker threads and waiting for the all work to finish.</p>
<p class="F">Job units to <span class="G">CoWork</span> are represented by <span class="G">Function&lt;void ()&gt;</span> and thus can be written inline as lambdas.</p>
<p class="F">As an example, following code reads input file by lines, splits lines into words (this is the parallelized work) and then adds resulting words to <span class="G">Index</span>:</p>
<p class="A">&nbsp;</p>
<p class="H">FileIn in(GetDataFile(&quot;test.txt&quot;)); // let us open some tutorial testing data</p>
<p class="H">&nbsp;</p>
<p class="H">Index&lt;String&gt; w;</p>
<p class="H">Mutex m; // need mutex to serialize access to w</p>
<p class="H">&nbsp;</p>
<p class="H">CoWork co;</p>
<p class="H">while(!in.IsEof()) {</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;String ln = in.GetLine();</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;co &amp; [ln, &amp;w, &amp;m] {</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vector&lt;String&gt; h = Split(ln, [](int c) { return IsAlpha(c) ? 0 : c; });</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Mutex::Lock __(m);</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(const auto&amp; s : h)</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;w.FindAdd(s);</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;};</p>
<p class="H">}</p>
<p class="H">co.Finish();</p>
<p class="H">&nbsp;</p>
<p class="H">DUMP(w);</p>
<p class="A">&nbsp;</p>
<p class="I">w = [Lorem, ipsum, dolor, sit, amet, consectetur, adipiscing, elit, sed, do, eiusmod, tempor, incididunt, ut, labore, et, dolore, magna, aliqua, Ut, enim, ad, minim, veniam, quis, nostrud, exercitation, ullamco, laboris, nisi, aliquip, ex, ea, commodo, consequat, esse, cillum, eu, fugiat, nulla, pariatur, Excepteur, Duis, aute, irure, in, reprehenderit, voluptate, velit, officia, deserunt, mollit, anim, id, est, laborum, sint, occaecat, cupidatat, non, proident, sunt, culpa, qui]</p>
<p class="A">&nbsp;</p>
<p class="F">Adding words to <span class="G">w</span> requires <span class="G">Mutex</span>. Alternative to this 'result gathering' <span class="G">Mutex</span> is <span class="G">CoWork::FinLock</span>. The idea behind this is that CoWork requires an internal <span class="G">Mutex</span> to serialize access to common data, so why <span class="G">FinLock</span> locks this internal mutex a bit earlier, saving CPU cycles required to lock and unlock dedicated mutex. From API contract perspective, you can consider <span class="G">FinLock</span> to serialize code till the end of worker job.</p>
<p class="A">&nbsp;</p>
<p class="H">in.Seek(0);</p>
<p class="H">while(!in.IsEof()) {</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;String ln = in.GetLine();</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;co &amp; [ln, &amp;w, &amp;m] {</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vector&lt;String&gt; h = Split(ln, [](int c) { return IsAlpha(c) ? 0 : c; });</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CoWork::FinLock(); // replaces the mutex, locked till the end of CoWork job</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(const auto&amp; s : h)</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;w.FindAdd(s);</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;};</p>
<p class="H">}</p>
<p class="H">co.Finish();</p>
<p class="H">&nbsp;</p>
<p class="H">DUMP(w);</p>
<p class="A">&nbsp;</p>
<p class="I">w = [Lorem, ipsum, dolor, sit, amet, consectetur, adipiscing, elit, sed, do, eiusmod, tempor, incididunt, ut, labore, et, dolore, magna, aliqua, Ut, enim, ad, minim, veniam, quis, nostrud, exercitation, ullamco, laboris, nisi, aliquip, ex, ea, commodo, consequat, esse, cillum, eu, fugiat, nulla, pariatur, Excepteur, Duis, aute, irure, in, reprehenderit, voluptate, velit, officia, deserunt, mollit, anim, id, est, laborum, sint, occaecat, cupidatat, non, proident, sunt, culpa, qui]</p>
<p class="A">&nbsp;</p>
<p class="F">Of course, the code performed after <span class="G">FinLock</span> should not take long, otherwise there is negative impact on all <span class="G">CoWork</span> instances. In fact, from this perspective, above code is probably past the threshold...</p>
<p class="F">When exception is thrown in <span class="G">CoWork</span>, it is propagated to the thread that calls <span class="G">Finish</span> and <span class="G">CoWork</span> is canceled. If more than single job throws, one of exceptions is selected randomly to be rethrown in Finish.</p>
<p class="F">As <span class="G">CoWork</span> destructor calls <span class="G">Finish</span> too, it is possible that it will be thrown by destructor, which is not exactly recommended thing to do in C++, but is well defined and really the best option here:</p>
<p class="A">&nbsp;</p>
<p class="H">in.Seek(0);</p>
<p class="H">try {</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;while(!in.IsEof()) {</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String ln = in.GetLine();</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;co &amp; [ln, &amp;w, &amp;m] {</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(ln.GetCount() &gt; 75)</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw &quot;Input line was too long!&quot;;</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vector&lt;String&gt; h = Split(ln, [](int c) { return IsAlpha(c) ? 0 : c; });</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CoWork::FinLock(); // replaces the mutex, locked till the end of CoWork job</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(const auto&amp; s : h)</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;w.FindAdd(s);</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;co.Finish();</p>
<p class="H">}</p>
<p class="H">catch(const char *exception) {</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;DUMP(exception);</p>
<p class="H">}</p>
<p class="A">&nbsp;</p>
<p class="F">Sometimes there is a need for cancellation of the whole <span class="G">CoWork</span>. <span class="G">Cancel</span> method cancels all scheduled jobs that have not been yet executed and sets <span class="G">CoWork</span> to canceled state, which can be checked in job routine using <span class="G">CoWork::IsCanceled</span>:</p>
<p class="A">&nbsp;</p>
<p class="H">for(int i = 0; i &lt; 100; i++)</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;co &amp; [] {</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(;;) {</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(CoWork::IsCanceled()) {</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LOG(&quot;Job was canceled&quot;);</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sleep(1);</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;};</p>
<p class="H">Sleep(200); // Give CoWork a chance to start some jobs</p>
<p class="H">co.Cancel();</p>
<p class="A">&nbsp;</p>
<p class="I">Job was canceled</p>
<p class="I">Job was canceled</p>
<p class="I">Job was canceled</p>
<p class="I">Job was canceled</p>
<p class="I">Job was canceled</p>
<p class="I">Job was canceled</p>
<p class="I">Job was canceled</p>
<p class="I">Job was canceled</p>
<p class="I">Job was canceled</p>
<p class="I">Job was canceled</p>
<p class="I">Job was canceled</p>
<p class="I">Job was canceled</p>
<p class="I">Job was canceled</p>
<p class="I">Job was canceled</p>
<p class="I">Job was canceled</p>
<p class="I">Job was canceled</p>
<p class="I">Job was canceled</p>
<p class="I">Job was canceled</p>
<p class="A">&nbsp;</p>
<p class="F">Canceling CoWork is common in GUI applications.</p>
<hr><p id="Section_7_5" class="L"><span class="M">7.5 </span>AsyncWork</p>
<p class="F"><span class="G">AsyncWork</span> is <span class="G">CoWork</span> based tool that resembles std::future. <span class="G">AsyncWork</span> instances are created using <span class="G">Async</span> function and represent a work that can be done in parallel with current thread. <span class="G">AsyncWork</span> supports returning values. A call to <span class="G">AsyncWork::Get</span> makes sure that a work routine was finished and returns the return value (if any):</p>
<p class="A">&nbsp;</p>
<p class="H">auto a = Async([](int n) -&gt; double {</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;double f = 1;</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;for(int i = 2; i &lt;= n; i++)</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f *= i;</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;return f;</p>
<p class="H">}, 100);</p>
<p class="H">&nbsp;</p>
<p class="H">DUMP(a.Get());</p>
<p class="A">&nbsp;</p>
<p class="I">a.Get() = 9.33262154439441e157</p>
<p class="A">&nbsp;</p>
<p class="F">Exceptions thrown in Async work are propagated upon call to <span class="G">Get</span>:</p>
<p class="A">&nbsp;</p>
<p class="H">auto b = Async([] { throw &quot;error&quot;; });</p>
<p class="H">&nbsp;</p>
<p class="H">try {</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;b.Get();</p>
<p class="H">}</p>
<p class="H">catch(...) {</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;LOG(&quot;Exception has been caught&quot;);</p>
<p class="H">}</p>
<p class="A">&nbsp;</p>
<p class="I">Exception has been caught</p>
<p class="A">&nbsp;</p>
<p class="F"><span class="G">AsyncWork</span> instances can be canceled (and are canceled in destructor if Get is not called on them):</p>
<p class="A">&nbsp;</p>
<p class="H">{</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;auto c = Async([] {</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(;;)</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(CoWork::IsCanceled()) {</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LOG(&quot;Work was canceled&quot;);</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;});</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;Sleep(100); // give it chance to start</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;// c destructor cancels the work (can be explicitly canceled by Cancel method too)</p>
<p class="H">}</p>
<p class="A">&nbsp;</p>
<p class="I">Work was canceled</p>
<p class="A">&nbsp;</p>
<hr><p id="Section_7_6" class="E">7.6 CoPartition</p>
<p class="F">There is some overhead associated with CoWork worker threads. That is why e.g. performing a simple operation on the array spawning worker thread for each element is not a good idea performance wise:</p>
<p class="A">&nbsp;</p>
<p class="H">Vector&lt;int&gt; data;</p>
<p class="H">for(int i = 0; i &lt; 10000; i++)</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;data.Add(i);</p>
<p class="H">&nbsp;</p>
<p class="H">int sum = 0;</p>
<p class="H">&nbsp;</p>
<p class="H">CoWork co;</p>
<p class="H">for(int i = 0; i &lt; data.GetCount(); i++)</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;co &amp; [i, &amp;sum, &amp;data] { CoWork::FinLock(); sum += data[i]; };</p>
<p class="H">co.Finish();</p>
<p class="H">DUMP(sum);</p>
<p class="A">&nbsp;</p>
<p class="I">sum = 49995000</p>
<p class="A">&nbsp;</p>
<p class="F">Above code computes the sum of all elements in the <span class="G">Vector</span>, using CoWorker job for each element. While producing the correct result, it is likely to run much slower than single-threaded version.</p>
<p class="F">The solution to the problem is to split the array into small number of larger subranges that are processed in parallel. This is what <span class="G">CoPartition</span> template algorithm does:</p>
<p class="A">&nbsp;</p>
<p class="H">sum = 0;</p>
<p class="H">CoPartition(data, [&amp;sum](const auto&amp; subrange) {</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;int partial_sum = 0;</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;for(const auto&amp; x : subrange)</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;partial_sum += x;</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;CoWork::FinLock(); // available as CoPartition uses CoWork</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;sum += partial_sum;</p>
<p class="H">});</p>
<p class="H">DUMP(sum);</p>
<p class="A">&nbsp;</p>
<p class="I">sum = 49995000</p>
<p class="A">&nbsp;</p>
<p class="F">Note that CoWork is still internally used, so <span class="G">CoWork::FinLock</span> is available. Instead of working on subranges, it is also possible to use iterators:</p>
<p class="A">&nbsp;</p>
<p class="H">sum = 0;</p>
<p class="H">CoPartition(data.begin(), data.end(), [&amp;sum] (auto l, auto h) {</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;int partial_sum = 0;</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;while(l != h)</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;partial_sum += *l++;</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;CoWork::FinLock(); // available as CoPartition uses CoWork</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;sum += partial_sum;</p>
<p class="H">});</p>
<p class="H">DUMP(sum);</p>
<p class="A">&nbsp;</p>
<p class="I">sum = 49995000</p>
<p class="A">&nbsp;</p>
<p class="F">There is no requirement on the type of iterators, so it is even possible to use just indices:</p>
<p class="A">&nbsp;</p>
<p class="H">sum = 0;</p>
<p class="H">CoPartition(0, data.GetCount(), [&amp;sum, &amp;data] (int l, int h) {</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;int partial_sum = 0;</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;while(l != h)</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;partial_sum += data[l++];</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;CoWork::FinLock(); // available as CoPartition uses CoWork</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;sum += partial_sum;</p>
<p class="H">});</p>
<p class="H">DUMP(sum);</p>
<p class="A">&nbsp;</p>
<p class="I">sum = 49995000</p>
<p class="A">&nbsp;</p>
<hr><p id="Section_7_7" class="E">7.7 CoDo</p>
<p class="F">An alternative to <span class="G">CoPartition</span> is <span class="G">CoDo</span>. In this pattern, the job is simply started in all threads and the code is responsible for scheduling the work. <span class="G">CoDo</span> waits for all started threads to finish. Scheduling is the responsibility of client code, but can be easily managed using the std::atomic counter. This way, the overhead associated with creating lambdas and scheduling them is kept to the minimum (basically the cost of atomic increment). Once again, CoDo is based on CoWork, so <span class="G">CoWork::FinLock</span> is available.</p>
<p class="A">&nbsp;</p>
<p class="H">Vector&lt;String&gt; data;</p>
<p class="H">for(int i = 0; i &lt; 100; i++)</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;data.Add(AsString(1.0 / i));</p>
<p class="H">&nbsp;</p>
<p class="H">double sum = 0;</p>
<p class="H">&nbsp;</p>
<p class="H">std::atomic&lt;int&gt; ii(0);</p>
<p class="H">&nbsp;</p>
<p class="H">CoDo([&amp;] {</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;double m = 0;</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;for(int i = ii++; i &lt; data.GetCount(); i = ii++)</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m += atof(data[i]);</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;CoWork::FinLock();</p>
<p class="H">&nbsp;&nbsp;&nbsp;&nbsp;sum += m;</p>
<p class="H">});</p>
<p class="H">&nbsp;</p>
<p class="H">DUMP(sum);</p>
<p class="A">&nbsp;</p>
<p class="I">sum = 5.17737751763962</p>
<p class="A">&nbsp;</p>
<hr><p id="Section_7_8" class="E">7.8 Parallel algorithms</p>
<p class="F">U++ provides a parallel versions of algorithms where it makes sense. The naming scheme is 'Co' prefix before the name of algorithm designates the parallel version.</p>
<p class="F">So the parallel version of e.g. <span class="G">FindIndex</span> is <span class="G">CoFindIndex</span>, for <span class="G">Sort</span> it is <span class="G">CoSort</span>:</p>
<p class="A">&nbsp;</p>
<p class="H">Vector&lt;String&gt; x{ &quot;zero&quot;, &quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot; };</p>
<p class="H">&nbsp;</p>
<p class="H">DUMP(FindIndex(x, &quot;two&quot;));</p>
<p class="H">DUMP(CoFindIndex(x, &quot;two&quot;));</p>
<p class="H">&nbsp;</p>
<p class="H">CoSort(x);</p>
<p class="H">DUMP(x);</p>
<p class="A">&nbsp;</p>
<p class="I">FindIndex(x, &quot;two&quot;) = 2</p>
<p class="I">CoFindIndex(x, &quot;two&quot;) = 2</p>
<p class="I">x = [five, four, one, three, two, zero]</p>
<p class="A">&nbsp;</p>
<p class="F">Caution should be exercised when using these algorithms - for small datasets, they are almost certainly slower than single-threaded versions.</p>
<p class="F">&nbsp;</p>
</TD>
</TR>
</TABLE>
</TD>
</TR>
</TABLE>
<TABLE BORDER="0" WIDTH="100%"><TR><TD></TD>
</TR>
</TABLE>
<TABLE BORDER="0" CELLSPACING="0" CELLPADDING="0" BGCOLOR="#FFFFFF" WIDTH="100%" style="border-style: solid; border-width: 1px; border-color: #6E89AE;padding: 10px;;"><TR><TD><TABLE BORDER="0" CELLSPACING="0" CELLPADDING="0" WIDTH="100%"><TR><TD><p class="A"><span class="B"> </span><a href="www$uppweb$contribweb$en-us.html">Do you want to contribute?</a></p>
</TD>
</TR>
</TABLE>
</TD>
</TR>
</TABLE>
</TD>
</TR>
</TABLE>
<script type="text/javascript">var a={};var p=window.location.pathname.split("/");p=p[p.length-1];var s='<select id="lang" onchange="window.location=document.getElementById(\'lang\').value;">';for(l in a){if(p==l){d=" selected=1"}else{d=""}s+='<option value="'+l+'"'+d+'>'+a[l]+'</option>'}s+='</select>';var d=document.createElement('div');d.innerHTML=s;var c=document.getElementById('langs');c.replaceChild(d,c.firstChild);document.getElementById('langbox').style.display='block';</script></BODY>
